好的，这是 `autogen_api_reference_zh.md` 文件的完整汉化内容：

--- START OF FILE autogen_api_reference_zh.md ---

# AutoGen API 参考文档

**原文档链接**: [AutoGen API Reference](https://microsoft.github.io/autogen/stable/reference/index.html)

**注意**: 未安装翻译工具，此文档保留英文原文并添加了翻译标记。API名称、参数名和代码示例保持英文原样。

## 目录

- [AutoGen AgentChat](#autogen-agentchat)
  - [autogen_agentchat](#autogen_agentchat)
  - [autogen_agentchat](#autogen_agentchat)
  - [autogen_agentchat.agents](#autogen_agentchatagents)
  - [autogen_agentchat.agents](#autogen_agentchatagents)
  - [autogen_agentchat.base](#autogen_agentchatbase)
  - [autogen_agentchat.base](#autogen_agentchatbase)
  - [autogen_agentchat.conditions](#autogen_agentchatconditions)
  - [autogen_agentchat.conditions](#autogen_agentchatconditions)
  - [autogen_agentchat.messages](#autogen_agentchatmessages)
  - [autogen_agentchat.messages](#autogen_agentchatmessages)
  - [autogen_agentchat.state](#autogen_agentchatstate)
  - [autogen_agentchat.state](#autogen_agentchatstate)
  - [autogen_agentchat.teams](#autogen_agentchatteams)
  - [autogen_agentchat.teams](#autogen_agentchatteams)
  - [autogen_agentchat.tools](#autogen_agentchattools)
  - [autogen_agentchat.tools](#autogen_agentchattools)
  - [autogen_agentchat.ui](#autogen_agentchatui)
  - [autogen_agentchat.ui](#autogen_agentchatui)
  - [next
autogen_agentchat](#next-autogen_agentchat)
- [其他 API 参考](#other-api-references)
  - [autogen_core](#autogen_core)
  - [autogen_core](#autogen_core)
  - [autogen_core.code_executor](#autogen_corecode_executor)
  - [autogen_core.code_executor](#autogen_corecode_executor)
  - [autogen_core.exceptions](#autogen_coreexceptions)
  - [autogen_core.exceptions](#autogen_coreexceptions)
  - [autogen_core.logging](#autogen_corelogging)
  - [autogen_core.logging](#autogen_corelogging)
  - [autogen_core.memory](#autogen_corememory)
  - [autogen_core.memory](#autogen_corememory)
  - [autogen_core.model_context](#autogen_coremodel_context)
  - [autogen_core.model_context](#autogen_coremodel_context)
  - [autogen_core.models](#autogen_coremodels)
  - [autogen_core.models](#autogen_coremodels)
  - [autogen_core.tool_agent](#autogen_coretool_agent)
  - [autogen_core.tool_agent](#autogen_coretool_agent)
  - [autogen_core.tools](#autogen_coretools)
  - [autogen_core.tools](#autogen_coretools)
  - [autogen_ext.agents.azure](#autogen_extagentsazure)
  - [autogen_ext.agents.azure](#autogen_extagentsazure)
  - [autogen_ext.agents.file_surfer](#autogen_extagentsfile_surfer)
  - [autogen_ext.agents.file_surfer](#autogen_extagentsfile_surfer)
  - [autogen_ext.agents.magentic_one](#autogen_extagentsmagentic_one)
  - [autogen_ext.agents.magentic_one](#autogen_extagentsmagentic_one)
  - [autogen_ext.agents.openai](#autogen_extagentsopenai)
  - [autogen_ext.agents.openai](#autogen_extagentsopenai)
  - [autogen_ext.agents.video_surfer](#autogen_extagentsvideo_surfer)
  - [autogen_ext.agents.video_surfer](#autogen_extagentsvideo_surfer)
  - [autogen_ext.agents.video_surfer.tools](#autogen_extagentsvideo_surfertools)
  - [autogen_ext.agents.video_surfer.tools](#autogen_extagentsvideo_surfertools)
  - [autogen_ext.agents.web_surfer](#autogen_extagentsweb_surfer)
  - [autogen_ext.agents.web_surfer](#autogen_extagentsweb_surfer)
  - [autogen_ext.auth.azure](#autogen_extauthazure)
  - [autogen_ext.auth.azure](#autogen_extauthazure)
  - [autogen_ext.cache_store.diskcache](#autogen_extcache_storediskcache)
  - [autogen_ext.cache_store.diskcache](#autogen_extcache_storediskcache)
  - [autogen_ext.cache_store.redis](#autogen_extcache_storeredis)
  - [autogen_ext.cache_store.redis](#autogen_extcache_storeredis)
  - [autogen_ext.code_executors.azure](#autogen_extcode_executorsazure)
  - [autogen_ext.code_executors.azure](#autogen_extcode_executorsazure)
  - [autogen_ext.code_executors.docker](#autogen_extcode_executorsdocker)
  - [autogen_ext.code_executors.docker](#autogen_extcode_executorsdocker)
  - [autogen_ext.code_executors.docker_jupyter](#autogen_extcode_executorsdocker_jupyter)
  - [autogen_ext.code_executors.docker_jupyter](#autogen_extcode_executorsdocker_jupyter)
  - [autogen_ext.code_executors.jupyter](#autogen_extcode_executorsjupyter)
  - [autogen_ext.code_executors.jupyter](#autogen_extcode_executorsjupyter)
  - [autogen_ext.code_executors.local](#autogen_extcode_executorslocal)
  - [autogen_ext.code_executors.local](#autogen_extcode_executorslocal)
  - [autogen_ext.experimental.task_centric_memory](#autogen_extexperimentaltask_centric_memory)
  - [autogen_ext.experimental.task_centric_memory](#autogen_extexperimentaltask_centric_memory)
  - [autogen_ext.experimental.task_centric_memory.utils](#autogen_extexperimentaltask_centric_memoryutils)
  - [autogen_ext.experimental.task_centric_memory.utils](#autogen_extexperimentaltask_centric_memoryutils)
  - [autogen_ext.memory.canvas](#autogen_extmemorycanvas)
  - [autogen_ext.memory.canvas](#autogen_extmemorycanvas)
  - [autogen_ext.models.anthropic](#autogen_extmodelsanthropic)
  - [autogen_ext.models.anthropic](#autogen_extmodelsanthropic)
  - [autogen_ext.models.azure](#autogen_extmodelsazure)
  - [autogen_ext.models.azure](#autogen_extmodelsazure)
  - [autogen_ext.models.cache](#autogen_extmodelscache)
  - [autogen_ext.models.cache](#autogen_extmodelscache)
  - [autogen_ext.models.llama_cpp](#autogen_extmodelsllama_cpp)
  - [autogen_ext.models.llama_cpp](#autogen_extmodelsllama_cpp)
  - [autogen_ext.models.ollama](#autogen_extmodelsollama)
  - [autogen_ext.models.ollama](#autogen_extmodelsollama)
  - [autogen_ext.models.openai](#autogen_extmodelsopenai)
  - [autogen_ext.models.openai](#autogen_extmodelsopenai)
  - [autogen_ext.models.replay](#autogen_extmodelsreplay)
  - [autogen_ext.models.replay](#autogen_extmodelsreplay)
  - [autogen_ext.models.semantic_kernel](#autogen_extmodelssemantic_kernel)
  - [autogen_ext.models.semantic_kernel](#autogen_extmodelssemantic_kernel)
  - [autogen_ext.runtimes.grpc](#autogen_extruntimesgrpc)
  - [autogen_ext.runtimes.grpc](#autogen_extruntimesgrpc)
  - [autogen_ext.teams.magentic_one](#autogen_extteamsmagentic_one)
  - [autogen_ext.teams.magentic_one](#autogen_extteamsmagentic_one)
  - [autogen_ext.tools.azure](#autogen_exttoolsazure)
  - [autogen_ext.tools.azure](#autogen_exttoolsazure)
  - [autogen_ext.tools.code_execution](#autogen_exttoolscode_execution)
  - [autogen_ext.tools.code_execution](#autogen_exttoolscode_execution)
  - [autogen_ext.tools.graphrag](#autogen_exttoolsgraphrag)
  - [autogen_ext.tools.graphrag](#autogen_exttoolsgraphrag)
  - [autogen_ext.tools.http](#autogen_exttoolshttp)
  - [autogen_ext.tools.http](#autogen_exttoolshttp)
  - [autogen_ext.tools.langchain](#autogen_exttoolslangchain)
  - [autogen_ext.tools.langchain](#autogen_exttoolslangchain)
  - [autogen_ext.tools.mcp](#autogen_exttoolsmcp)
  - [autogen_ext.tools.mcp](#autogen_exttoolsmcp)
  - [autogen_ext.tools.semantic_kernel](#autogen_exttoolssemantic_kernel)
  - [autogen_ext.tools.semantic_kernel](#autogen_exttoolssemantic_kernel)

## AutoGen AgentChat {autogen-agentchat}

【中文翻译】AutoGen AgentChat 提供了一组工具，用于创建、配置和部署各种类型的Agent，使它们能够互相沟通和协作。

### autogen_agentchat {autogen_agentchat}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html)

```python
EVENT_LOGGER_NAME = 'autogen_agentchat.events'#
```

【中文翻译】事件日志的记录器名称。

```python
TRACE_LOGGER_NAME = 'autogen_agentchat'#
```

【中文翻译】跟踪日志的记录器名称。

【中文翻译】此模块提供了 autogen_agentchat 包的主要入口点。
它包括跟踪和事件日志的记录器名称，并检索包版本。

【中文翻译】上一页

【中文翻译】API 参考

【中文翻译】下一页

【中文翻译】autogen_agentchat.messages

### autogen_agentchat {autogen_agentchat}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html)

```python
EVENT_LOGGER_NAME = 'autogen_agentchat.events'#
```

【中文翻译】事件日志的记录器名称。

```python
TRACE_LOGGER_NAME = 'autogen_agentchat'#
```

【中文翻译】跟踪日志的记录器名称。

【中文翻译】此模块提供了 autogen_agentchat 包的主要入口点。
它包括跟踪和事件日志的记录器名称，并检索包版本。

【中文翻译】上一页

【中文翻译】API 参考

【中文翻译】下一页

【中文翻译】autogen_agentchat.messages

### autogen_agentchat.agents {autogen_agentchatagents}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.agents.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.agents.html)

```python
class AssistantAgent(name: str, model_client: ChatCompletionClient, *, tools: List[BaseTool[Any, Any] | Callable[[...], Any] | Callable[[...], Awaitable[Any]]] | None = None, workbench: Workbench | None = None, handoffs: List[Handoff | str] | None = None, model_context: ChatCompletionContext | None = None, description: str = 'An agent that provides assistance with ability to use tools.', system_message: str | None = 'You are a helpful AI assistant. Solve tasks using your tools. Reply with TERMINATE when the task has been completed.', model_client_stream: bool = False, reflect_on_tool_use: bool | None = None, tool_call_summary_format: str = '{result}', output_content_type: type[BaseModel] | None = None, output_content_type_format: str | None = None, memory: Sequence[Memory] | None = None, metadata: Dict[str, str] | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[AssistantAgentConfig]
一个提供工具使用协助的代理。
`on_messages()` 返回一个 `Response` 对象，
其中 `chat_message` 是最终的响应消息。
`on_messages_stream()` 创建一个异步生成器，
它会按创建顺序生成内部消息，并在关闭生成器之前将 `Response` 对象作为最后一项。
`BaseChatAgent.run()` 方法返回一个 `TaskResult`，
其中包含代理生成的消息。在消息列表 `messages` 中，
最后一条消息是最终的响应消息。
`BaseChatAgent.run_stream()` 方法创建一个异步生成器，
它会按创建顺序生成内部消息，并在关闭生成器之前将 `TaskResult` 对象作为最后一项。

注意
调用者在每次调用 `on_messages()`、`on_messages_stream()`、`BaseChatAgent.run()` 或 `BaseChatAgent.run_stream()` 方法时，只能向代理传递新消息。
代理在这些方法的调用之间维护其状态。
不要在每次调用时都将整个对话历史传递给代理。

警告
助手代理不是线程安全或协程安全的。
它不应在多个任务或协程之间共享，并且不应并发调用其方法。

下图显示了助手代理的工作原理：

结构化输出：
如果设置了 `output_content_type`，代理默认将在最终响应中以 `StructuredMessage` 而不是 `TextMessage` 进行响应。

注意
目前，设置 `output_content_type` 会阻止代理调用 `load_component` 和 `dump_component` 方法以进行可序列化配置。这将在未来很快修复。

工具调用行为：

如果模型未返回工具调用，则响应会立即作为 `TextMessage` 或 `StructuredMessage`（使用结构化输出时）在 `chat_message` 中返回。

当模型返回工具调用时，它们将立即执行：
当 `reflect_on_tool_use` 为 False 时，工具调用结果将作为 `ToolCallSummaryMessage` 在 `chat_message` 中返回。可以使用 `tool_call_summary_format` 自定义工具调用摘要。
当 `reflect_on_tool_use` 为 True 时，将使用工具调用和结果进行另一次模型推理，最终响应将作为 `TextMessage` 或 `StructuredMessage`（使用结构化输出时）在 `chat_message` 中返回。
当设置 `output_content_type` 时，`reflect_on_tool_use` 默认为 True。
当未设置 `output_content_type` 时，`reflect_on_tool_use` 默认为 False。

如果模型返回多个工具调用，它们将并发执行。要禁用并行工具调用，您需要配置模型客户端。例如，为 `OpenAIChatCompletionClient` 和 `AzureOpenAIChatCompletionClient` 设置 `parallel_tool_calls=False`。

提示
默认情况下，当进行工具调用时，工具调用结果将作为响应返回。
因此，建议注意工具返回值的格式，特别是如果另一个代理期望它们采用特定格式。
如果需要，请使用 `tool_call_summary_format` 自定义工具调用摘要。

移交行为：

如果触发了移交，`HandoffMessage` 将在 `chat_message` 中返回。
如果存在工具调用，它们也将在返回移交之前立即执行。
工具调用和结果通过上下文传递给目标代理。

注意
如果检测到多个移交，则仅执行第一个移交。
为避免这种情况，请在模型客户端配置中禁用并行工具调用。

限制发送到模型的上下文大小：
您可以通过将 `model_context` 参数设置为 `BufferedChatCompletionContext` 来限制发送到模型的消息数量。
这将限制发送到模型的最近消息的数量，并且在模型可以处理的令牌数量有限制时非常有用。
另一种选择是使用 `TokenLimitedChatCompletionContext`，它将限制发送到模型的令牌数量。
您还可以通过子类化 `ChatCompletionContext` 来创建自己的模型上下文。

流式模式：
通过设置 `model_client_stream=True`，助手代理可以在流式模式下使用。
在此模式下，`on_messages_stream()` 和 `BaseChatAgent.run_stream()` 方法还将产生 `ModelClientStreamingChunkEvent` 消息，因为模型客户端会生成响应块。
块消息不会包含在最终响应的内部消息中。

参数：

name (str) – 代理的名称。
model_client (ChatCompletionClient) – 用于推理的模型客户端。
tools (List[BaseTool[Any, Any] | Callable[..., Any] | Callable[..., Awaitable[Any]]] | None, 可选) – 要向代理注册的工具。
workbench (Workbench | None, 可选) – 要用于代理的工作台。
设置工作台后不能使用工具，反之亦然。
handoffs (List[HandoffBase | str] | None, 可选) – 代理的移交配置，
允许它通过响应 `HandoffMessage` 来转移到其他代理。
仅当团队处于 Swarm 模式时才执行转移。
如果移交是字符串，则它应表示目标代理的名称。
model_context (ChatCompletionContext | None, 可选) – 用于存储和检索 `LLMMessage` 的模型上下文。它可以预加载初始消息。当代理重置时，初始消息将被清除。
description (str, 可选) – 代理的描述。
system_message (str, 可选) – 模型的系统消息。如果提供，它将在进行推理时附加到模型上下文中的消息之前。设置为 None 以禁用。
model_client_stream (bool, 可选) – 如果为 True，模型客户端将以流式模式使用。
`on_messages_stream()` 和 `BaseChatAgent.run_stream()` 方法还将产生 `ModelClientStreamingChunkEvent` 消息，因为模型客户端会生成响应块。默认为 False。
reflect_on_tool_use (bool, 可选) – 如果为 True，代理将使用工具调用和结果进行另一次模型推理以生成响应。如果为 False，工具调用结果将作为响应返回。默认情况下，如果设置了 `output_content_type`，则此值为 True；如果未设置 `output_content_type`，则此值为 False。
output_content_type (type[BaseModel] | None, 可选) – `StructuredMessage` 响应的输出内容类型，作为 Pydantic 模型。
这将与模型客户端一起使用以生成结构化输出。
如果设置了此项，代理将在最终响应中以 `StructuredMessage` 而不是 `TextMessage` 进行响应，除非 `reflect_on_tool_use` 为 False 并且进行了工具调用。
output_content_type_format (str | None, 可选) – (实验性) 用于 `StructuredMessage` 响应内容的格式字符串。
tool_call_summary_format (str, 可选) – 用于为 `ToolCallSummaryMessage` 响应创建内容的格式字符串。
该格式字符串用于格式化每个工具调用结果的工具调用摘要。
默认为 “{result}”。
当 `reflect_on_tool_use` 为 False 时，所有工具调用摘要的串联（以换行符 ’n’ 分隔）将作为响应返回。
可用变量：{tool_name}、{arguments}、{result}。
例如，“{tool_name}: {result}” 将创建一个类似于 “tool_name: result” 的摘要。
memory (Sequence[Memory] | None, 可选) – 要用于代理的内存存储。默认为 None。
metadata (Dict[str, str] | None, 可选) – 用于跟踪的可选元数据。

引发：

ValueError – 如果工具名称不唯一。
ValueError – 如果移交名称不唯一。
ValueError – 如果移交名称与工具名称不唯一。
ValueError – 如果最大工具迭代次数小于 1。

示例
示例 1：基本代理
以下示例演示了如何使用模型客户端创建助手代理并生成对简单任务的响应。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o",
        # api_key = "your_openai_api_key"
    )
    agent = AssistantAgent(name="assistant", model_client=model_client)

    result = await agent.run(task="Name two cities in North America.")
    print(result)


asyncio.run(main())
```

示例 2：模型客户端令牌流
此示例演示了如何使用模型客户端创建助手代理，并通过设置 `model_client_stream=True` 来生成令牌流。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o",
        # api_key = "your_openai_api_key"
    )
    agent = AssistantAgent(
        name="assistant",
        model_client=model_client,
        model_client_stream=True,
    )

    stream = agent.run_stream(task="Name two cities in North America.")
    async for message in stream:
        print(message)


asyncio.run(main())
```

```
source='user' models_usage=None metadata={} content='Name two cities in North America.' type='TextMessage'
source='assistant' models_usage=None metadata={} content='Two' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' cities' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' in' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' North' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' America' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' are' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' New' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' York' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' City' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' and' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' Toronto' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content='.' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' TERMIN' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content='ATE' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=RequestUsage(prompt_tokens=0, completion_tokens=0) metadata={} content='Two cities in North America are New York City and Toronto. TERMINATE' type='TextMessage'
messages=[TextMessage(source='user', models_usage=None, metadata={}, content='Name two cities in North America.', type='TextMessage'), TextMessage(source='assistant', models_usage=RequestUsage(prompt_tokens=0, completion_tokens=0), metadata={}, content='Two cities in North America are New York City and Toronto. TERMINATE', type='TextMessage')] stop_reason=None
```

示例 3：带工具的代理
以下示例演示了如何使用模型客户端和工具创建助手代理，为任务生成消息流，并使用 Console 将消息打印到控制台。
该工具是一个返回当前时间的简单函数。
在底层，该函数被包装在 `FunctionTool` 中，并与代理的模型客户端一起使用。函数的文档字符串用作工具描述，函数名称用作工具名称，包括类型提示在内的函数签名用作工具参数。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.ui import Console


async def get_current_time() -> str:
    return "The current time is 12:00 PM."


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o",
        # api_key = "your_openai_api_key"
    )
    agent = AssistantAgent(name="assistant", model_client=model_client, tools=[get_current_time])
    await Console(agent.run_stream(task="What is the current time?"))


asyncio.run(main())
```

示例 4：带模型上下文协议 (MCP) 工作台的代理
以下示例演示了如何使用模型客户端和 `McpWorkbench` 创建助手代理，以便与模型上下文协议 (MCP) 服务器交互。
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.ui import Console
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_ext.tools.mcp import StdioServerParams, McpWorkbench


async def main() -> None:
    params = StdioServerParams(
        command="uvx",
        args=["mcp-server-fetch"],
        read_timeout_seconds=60,
    )

    # 您也可以使用 `start()` 和 `stop()` 来管理会话。
    async with McpWorkbench(server_params=params) as workbench:
        model_client = OpenAIChatCompletionClient(model="gpt-4.1-nano")
        assistant = AssistantAgent(
            name="Assistant",
            model_client=model_client,
            workbench=workbench,
            reflect_on_tool_use=True,
        )
        await Console(
            assistant.run_stream(task="Go to https://github.com/microsoft/autogen and tell me what you see.")
        )


asyncio.run(main())
```

示例 5：带结构化输出和工具的代理
以下示例演示了如何创建助手代理，该代理使用配置为使用结构化输出的模型客户端和工具。
请注意，您需要使用 `FunctionTool` 来创建工具，并且 `strict=True` 是结构化输出模式所必需的。
由于模型配置为使用结构化输出，因此输出反射响应将是 JSON 格式的字符串。
```python
import asyncio
from typing import Literal

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.ui import Console
from autogen_core.tools import FunctionTool
from autogen_ext.models.openai import OpenAIChatCompletionClient
from pydantic import BaseModel


# 定义结构化输出格式。
class AgentResponse(BaseModel):
    thoughts: str
    response: Literal["happy", "sad", "neutral"]


# 定义要作为工具调用的函数。
def sentiment_analysis(text: str) -> str:
    """Given a text, return the sentiment."""
    return "happy" if "happy" in text else "sad" if "sad" in text else "neutral"


# 创建一个 `FunctionTool` 实例，其中 `strict=True`，
# 这对于结构化输出模式是必需的。
tool = FunctionTool(sentiment_analysis, description="Sentiment Analysis", strict=True)

# 创建一个支持结构化输出的 `OpenAIChatCompletionClient` 实例。
model_client = OpenAIChatCompletionClient(
    model="gpt-4o-mini",
)

# 创建一个使用该工具和模型客户端的 `AssistantAgent` 实例。
agent = AssistantAgent(
    name="assistant",
    model_client=model_client,
    tools=[tool],
    system_message="Use the tool to analyze sentiment.",
    output_content_type=AgentResponse,
)


async def main() -> None:
    stream = agent.run_stream(task="I am happy today!")
    await Console(stream)


asyncio.run(main())
```

```
---------- assistant ----------
[FunctionCall(id='call_tIZjAVyKEDuijbBwLY6RHV2p', arguments='{"text":"I am happy today!"}', name='sentiment_analysis')]
---------- assistant ----------
[FunctionExecutionResult(content='happy', call_id='call_tIZjAVyKEDuijbBwLY6RHV2p', is_error=False)]
---------- assistant ----------
{"thoughts":"The user expresses a clear positive emotion by stating they are happy today, suggesting an upbeat mood.","response":"happy"}
```

示例 6：带限定模型上下文的代理
以下示例显示了如何使用 `BufferedChatCompletionContext`，它只保留最后 2 条消息（1 条用户消息 + 1 条助手消息）。
当模型可以处理的令牌数量有限制时，限定模型上下文非常有用。
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_core.model_context import BufferedChatCompletionContext
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    # 创建一个模型客户端。
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o-mini",
        # api_key = "your_openai_api_key"
    )

    # 创建一个只保留最后 2 条消息的模型上下文（1 条用户消息 + 1 条助手消息）。
    model_context = BufferedChatCompletionContext(buffer_size=2)

    # 使用模型客户端和上下文创建一个 `AssistantAgent` 实例。
    agent = AssistantAgent(
        name="assistant",
        model_client=model_client,
        model_context=model_context,
        system_message="You are a helpful assistant.",
    )

    result = await agent.run(task="Name two cities in North America.")
    print(result.messages[-1].content)  # type: ignore

    result = await agent.run(task="My favorite color is blue.")
    print(result.messages[-1].content)  # type: ignore

    result = await agent.run(task="Did I ask you any question?")
    print(result.messages[-1].content)  # type: ignore


asyncio.run(main())
```

```
Two cities in North America are New York City and Toronto.
That's great! Blue is often associated with calmness and serenity. Do you have a specific shade of blue that you like, or any particular reason why it's your favorite?
No, you didn't ask a question. I apologize for any misunderstanding. If you have something specific you'd like to discuss or ask, feel free to let me know!
```

示例 7：带内存的代理
以下示例显示了如何将基于列表的内存与助手代理一起使用。
内存预加载了一些初始内容。
在底层，内存在进行推理之前使用 `update_context()` 方法更新模型上下文。
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_core.memory import ListMemory, MemoryContent
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    # 创建一个模型客户端。
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o-mini",
        # api_key = "your_openai_api_key"
    )

    # 创建一个带有一些初始内容的基于列表的内存。
    memory = ListMemory()
    await memory.add(MemoryContent(content="User likes pizza.", mime_type="text/plain"))
    await memory.add(MemoryContent(content="User dislikes cheese.", mime_type="text/plain"))

    # 使用模型客户端和内存创建一个 `AssistantAgent` 实例。
    agent = AssistantAgent(
        name="assistant",
        model_client=model_client,
        memory=[memory],
        system_message="You are a helpful assistant.",
    )

    result = await agent.run(task="What is a good dinner idea?")
    print(result.messages[-1].content)  # type: ignore


asyncio.run(main())
```

```
How about making a delicious pizza without cheese? You can create a flavorful veggie pizza with a variety of toppings. Here's a quick idea:

**Veggie Tomato Sauce Pizza**
- Start with a pizza crust (store-bought or homemade).
- Spread a layer of marinara or tomato sauce evenly over the crust.
- Top with your favorite vegetables like bell peppers, mushrooms, onions, olives, and spinach.
- Add some protein if you’d like, such as grilled chicken or pepperoni (ensure it's cheese-free).
- Sprinkle with herbs like oregano and basil, and maybe a drizzle of olive oil.
- Bake according to the crust instructions until the edges are golden and the veggies are cooked.

Serve it with a side salad or some garlic bread to complete the meal! Enjoy your dinner!
```

示例 8：带 `o1-mini` 的代理
以下示例显示了如何将 o1-mini 模型与助手代理一起使用。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="o1-mini",
        # api_key = "your_openai_api_key"
    )
    # o1 系列模型不支持系统消息。
    agent = AssistantAgent(name="assistant", model_client=model_client, system_message=None)

    result = await agent.run(task="What is the capital of France?")
    print(result.messages[-1].content)  # type: ignore


asyncio.run(main())
```

注意
o1-preview 和 o1-mini 模型不支持系统消息和函数调用。
因此，`system_message` 应设置为 None，并且不应设置工具和移交。
有关更多详细信息，请参阅 o1 beta 限制。

示例 9：使用带自定义模型上下文的推理模型的代理。
以下示例显示了如何将推理模型 (DeepSeek R1) 与助手代理一起使用。
模型上下文用于从助手消息中过滤掉 thought 字段。
```python
import asyncio
from typing import List

from autogen_agentchat.agents import AssistantAgent
from autogen_core.model_context import UnboundedChatCompletionContext
from autogen_core.models import AssistantMessage, LLMMessage, ModelFamily
from autogen_ext.models.ollama import OllamaChatCompletionClient


class ReasoningModelContext(UnboundedChatCompletionContext):
    """A model context for reasoning models."""

    async def get_messages(self) -> List[LLMMessage]:
        messages = await super().get_messages()
        # Filter out thought field from AssistantMessage.
        messages_out: List[LLMMessage] = []
        for message in messages:
            if isinstance(message, AssistantMessage):
                message.thought = None
            messages_out.append(message)
        return messages_out


# 创建一个在 Ollama 上本地托管的 DeepSeek R1 模型客户端实例。
model_client = OllamaChatCompletionClient(
    model="deepseek-r1:8b",
    model_info={
        "vision": False,
        "function_calling": False,
        "json_output": False,
        "family": ModelFamily.R1,
        "structured_output": True,
    },
)

agent = AssistantAgent(
    "reasoning_agent",
    model_client=model_client,
    model_context=ReasoningModelContext(),  # 使用自定义模型上下文。
)


async def run_reasoning_agent() -> None:
    result = await agent.run(task="What is the capital of France?")
    print(result)


asyncio.run(run_reasoning_agent())
```

```python
component_config_schema#
```

【中文翻译】AssistantAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.AssistantAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载助手代理的状态

```python
property model_context: ChatCompletionContext#
```

【中文翻译】代理正在使用的模型上下文。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】使用助手代理处理传入消息，并在事件/响应发生时产生它们。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将助手代理重置为其初始化状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存助手代理的当前状态。

```python
class BaseChatAgent(name: str, description: str)[source]#
```

【中文翻译】基类：ChatAgent, ABC, ComponentBase[BaseModel]
聊天代理的基类。
此抽象类为 `ChatAgent` 提供了基本实现。
要创建新的聊天代理，请子类化此类并实现 `on_messages()`、`on_reset()` 和 `produced_message_types`。
如果需要流式处理，还要实现 `on_messages_stream()` 方法。
代理被认为是状态性的，并在对 `on_messages()` 或 `on_messages_stream()` 方法的调用之间保持其状态。
代理应将其状态存储在代理实例中。代理还应实现 `on_reset()` 方法以将代理重置为其初始化状态。

注意
调用者在每次调用 `on_messages()` 或 `on_messages_stream()` 方法时，只应向代理传递新消息。
不要在每次调用时都将整个对话历史传递给代理。
创建新代理时必须遵循此设计原则。

```python
async close() → None[source]#
```

【中文翻译】释放代理持有的任何资源。在 `BaseChatAgent` 类中，这默认是一个无操作。子类可以覆盖此方法以实现自定义关闭行为。

```python
component_type: ClassVar[ComponentType] = 'agent'#
```

【中文翻译】组件的逻辑类型。

```python
property description: str#
```

【中文翻译】代理的描述。团队使用此描述来决定使用哪些代理。描述应说明代理的功能以及如何与其交互。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】从保存的状态恢复代理。无状态代理的默认实现。

```python
property name: str#
```

【中文翻译】代理的名称。团队使用此名称来唯一标识代理。它在团队中应该是唯一的。

```python
abstract async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回消息流，最终项是响应。`BaseChatAgent` 中的基本实现只是调用 `on_messages()` 并产生响应中的消息。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_pause(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理在其 `on_messages()` 或 `on_messages_stream()` 方法中运行时被暂停时调用。在 `BaseChatAgent` 类中，这默认是一个无操作。子类可以覆盖此方法以实现自定义暂停行为。

```python
abstract async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
async on_resume(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理在其 `on_messages()` 或 `on_messages_stream()` 方法中运行时从暂停中恢复时调用。
在 `BaseChatAgent` 类中，这默认是一个无操作。
子类可以覆盖此方法以实现自定义恢复行为。

```python
abstract property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
async run(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → TaskResult[source]#
```

【中文翻译】使用给定的任务运行代理并返回结果。

```python
async run_stream(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None][source]#
```

【中文翻译】使用给定的任务运行代理，并返回消息流，最终的任务结果作为流中的最后一项。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】导出状态。无状态代理的默认实现。

```python
class CodeExecutorAgent(name: str, code_executor: CodeExecutor, *, model_client: ChatCompletionClient | None = None, model_context: ChatCompletionContext | None = None, model_client_stream: bool = False, max_retries_on_error: int = 0, description: str | None = None, system_message: str | None = DEFAULT_SYSTEM_MESSAGE, sources: Sequence[str] | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[CodeExecutorAgentConfig]
（实验性）一个根据用户指令生成并执行代码片段的代理。

注意
此代理是实验性的，可能会在未来版本中更改。

它通常在团队中使用，与另一个生成要执行的代码片段的代理一起使用，或者单独使用提供的 `model_client`，以便它可以根据用户查询生成代码、执行代码并反思代码结果。
当与 `model_client` 一起使用时，它将使用模型生成代码片段，并使用提供的 `code_executor` 执行它们。模型还将反思代码执行结果。代理将产生模型的最终反思结果作为最终响应。
当不使用 `model_client` 时，它将仅执行在 `TextMessage` 消息中找到的代码块，并返回代码执行的输出。

注意
使用带有 `PythonCodeExecutionTool` 的 `AssistantAgent` 是此代理的替代方案。但是，该代理的模型必须生成正确转义的代码字符串作为工具的参数。

参数：

name (str) – 代理的名称。
code_executor (CodeExecutor) – 负责执行消息中接收到的代码的代码执行器（建议使用 `DockerCommandLineCodeExecutor`。请参见下面的示例）
model_client (ChatCompletionClient, 可选) – 用于推理和生成代码的模型客户端。
如果未提供，代理将仅执行输入消息中找到的代码块。
目前，模型必须支持结构化输出模式，这是自动重试机制工作所必需的。
model_client_stream (bool, 可选) – 如果为 True，模型客户端将以流式模式使用。
`on_messages_stream()` 和 `BaseChatAgent.run_stream()` 方法还将产生 `ModelClientStreamingChunkEvent` 消息，因为模型客户端会生成响应块。默认为 False。
description (str, 可选) – 代理的描述。如果未提供，将使用 `DEFAULT_AGENT_DESCRIPTION`。
system_message (str, 可选) – 模型的系统消息。如果提供，它将在进行推理时附加到模型上下文中的消息之前。设置为 None 以禁用。
默认为 `DEFAULT_SYSTEM_MESSAGE`。仅当提供了 `model_client` 时才使用。
sources (Sequence[str], 可选) – 仅检查来自指定代理的消息以执行代码。
当代理是群聊的一部分并且您希望将代码执行限制为来自特定代理的消息时，这很有用。
如果未提供，将检查所有消息中的代码块。
仅当未提供 `model_client` 时才使用。
max_retries_on_error (int, 可选) – 错误时的最大重试次数。如果代码执行失败，代理将重试最多此次数。
如果代码执行在此次数的重试后失败，代理将产生一个反思结果。

注意
建议 `CodeExecutorAgent` 代理使用 Docker 容器来执行代码。这确保了模型生成的代码在隔离的环境中执行。要使用 Docker，您的环境必须安装并运行 Docker。
请按照 Docker 的安装说明进行操作。

注意
代码执行器仅处理使用三个反引号正确格式化的 Markdown 代码块中的代码。
例如：
```python
print("Hello World")
```

# 或

```sh
echo "Hello World"
```

在此示例中，我们展示了如何设置一个 `CodeExecutorAgent` 代理，该代理使用 `DockerCommandLineCodeExecutor` 在 Docker 容器中执行代码片段。`work_dir` 参数指示所有执行的文件在 Docker 容器中执行之前首先在本地保存的位置。
```python
import asyncio
from autogen_agentchat.agents import CodeExecutorAgent
from autogen_agentchat.messages import TextMessage
from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_core import CancellationToken


async def run_code_executor_agent() -> None:
    # 创建一个使用 Docker 容器执行代码的代码执行器代理。
    code_executor = DockerCommandLineCodeExecutor(work_dir="coding")
    await code_executor.start()
    code_executor_agent = CodeExecutorAgent("code_executor", code_executor=code_executor)

    # 使用给定的代码片段运行代理。
    task = TextMessage(
        content='''Here is some code
```python
print('Hello world')
```
''',
        source="user",
    )
    response = await code_executor_agent.on_messages([task], CancellationToken())
    print(response.chat_message)

    # 停止代码执行器。
    await code_executor.stop()


asyncio.run(run_code_executor_agent())
```

在此示例中，我们展示了如何设置一个 `CodeExecutorAgent` 代理，该代理使用 `DeviceRequest` 将 GPU 暴露给容器以进行 cuda 加速的代码执行。
```python
import asyncio
from autogen_agentchat.agents import CodeExecutorAgent
from autogen_agentchat.messages import TextMessage
from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_core import CancellationToken
from docker.types import DeviceRequest


async def run_code_executor_agent() -> None:
    # 创建一个使用 Docker 容器执行代码的代码执行器代理。
    code_executor = DockerCommandLineCodeExecutor(
        work_dir="coding", device_requests=[DeviceRequest(count=-1, capabilities=[["gpu"]])]
    )
    await code_executor.start()
    code_executor_agent = CodeExecutorAgent("code_executor", code_executor=code_executor)

    # 显示 GPU 信息
    task = TextMessage(
        content='''Here is some code
```bash
nvidia-smi
```
''',
        source="user",
    )
    response = await code_executor_agent.on_messages([task], CancellationToken())
    print(response.chat_message)

    # 停止代码执行器。
    await code_executor.stop()


asyncio.run(run_code_executor_agent())
```

在以下示例中，我们展示了如何在不使用 `model_client` 参数的情况下设置 `CodeExecutorAgent`，以便使用 `DockerCommandLineCodeExecutor` 执行群聊中其他代理生成的代码块。
```python
import asyncio

from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_ext.models.openai import OpenAIChatCompletionClient

from autogen_agentchat.agents import AssistantAgent, CodeExecutorAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.ui import Console

termination_condition = MaxMessageTermination(3)


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    # 定义 Docker CLI 代码执行器
    code_executor = DockerCommandLineCodeExecutor(work_dir="coding")

    # 启动执行容器
    await code_executor.start()

    code_executor_agent = CodeExecutorAgent("code_executor_agent", code_executor=code_executor)
    coder_agent = AssistantAgent("coder_agent", model_client=model_client)

    groupchat = RoundRobinGroupChat(
        participants=[coder_agent, code_executor_agent], termination_condition=termination_condition
    )

    task = "Write python code to print Hello World!"
    await Console(groupchat.run_stream(task=task))

    # 停止执行容器
    await code_executor.stop()


asyncio.run(main())
```

```
---------- user ----------
Write python code to print Hello World!
---------- coder_agent ----------
Certainly! Here's a simple Python code to print "Hello World!":

```python
print("Hello World!")
```

You can run this code in any Python environment to display the message.
---------- code_executor_agent ----------
Hello World!
```

在以下示例中，我们展示了如何使用 `model_client` 设置 `CodeExecutorAgent`，该代理可以在没有任何其他代理帮助的情况下生成自己的代码，并在 `DockerCommandLineCodeExecutor` 中执行它。
```python
import asyncio

from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_ext.models.openai import OpenAIChatCompletionClient

from autogen_agentchat.agents import CodeExecutorAgent
from autogen_agentchat.conditions import TextMessageTermination
from autogen_agentchat.ui import Console

termination_condition = TextMessageTermination("code_executor_agent")


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    # 定义 Docker CLI 代码执行器
    code_executor = DockerCommandLineCodeExecutor(work_dir="coding")

    # 启动执行容器
    await code_executor.start()

    code_executor_agent = CodeExecutorAgent(
        "code_executor_agent", code_executor=code_executor, model_client=model_client
    )

    task = "Write python code to print Hello World!"
    await Console(code_executor_agent.run_stream(task=task))

    # 停止执行容器
    await code_executor.stop()


asyncio.run(main())
```

```
---------- user ----------
Write python code to print Hello World!
---------- code_executor_agent ----------
Certainly! Here is a simple Python code to print "Hello World!" to the console:

```python
print("Hello World!")
```

Let's execute it to confirm the output.
---------- code_executor_agent ----------
Hello World!

---------- code_executor_agent ----------
The code has been executed successfully, and it printed "Hello World!" as expected. If you have any more requests or questions, feel free to ask!
```

```python
DEFAULT_AGENT_DESCRIPTION = 'A Code Execution Agent that generates and executes Python and shell scripts based on user instructions. Python code should be provided in ```python code blocks, and sh shell scripts should be provided in ```sh code blocks for execution. It ensures correctness, efficiency, and minimal errors while gracefully handling edge cases.'#
```

```python
DEFAULT_SYSTEM_MESSAGE = 'You are a Code Execution Agent. Your role is to generate and execute Python code based on user instructions, ensuring correctness, efficiency, and minimal errors. Handle edge cases gracefully.'#
```

```python
DEFAULT_TERMINAL_DESCRIPTION = 'A computer terminal that performs no other action than running Python scripts (provided to it quoted in ```python code blocks), or sh shell scripts (provided to it quoted in ```sh code blocks).'#
```

```python
NO_CODE_BLOCKS_FOUND_MESSAGE = 'No code blocks found in the thread. Please provide at least one markdown-encoded code block to execute (i.e., quoting code in ```python or ```sh code blocks).'#
```

```python
classmethod _from_config(config: CodeExecutorAgentConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → CodeExecutorAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】CodeExecutorAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.CodeExecutorAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async execute_code_block(code_blocks: List[CodeBlock], cancellation_token: CancellationToken) → CodeResult[source]#
```

```python
async extract_code_blocks_from_messages(messages: Sequence[BaseChatMessage]) → List[CodeBlock][source]#
```

```python
property model_context: ChatCompletionContext#
```

【中文翻译】代理正在使用的模型上下文。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】使用助手代理处理传入消息，并在事件/响应发生时产生它们。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】这是一个无操作，因为代码执行器代理没有可变状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代码执行器代理生成的消息类型。

```python
class MessageFilterAgent(name: str, wrapped_agent: BaseChatAgent, filter: MessageFilterConfig)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[MessageFilterAgentConfig]
一个包装代理，在将传入消息传递给内部代理之前对其进行过滤。

警告
这是一项实验性功能，API 将在未来的版本中更改。

这在多代理工作流等场景中非常有用，其中代理只应处理完整消息历史记录的子集——例如，仅处理每个上游代理的最后一条消息，或仅处理特定来源的第一条消息。
使用 `MessageFilterConfig` 配置过滤，它支持：
- 按消息来源过滤（例如，仅来自“用户”或其他代理的消息）
- 从每个来源选择前 N 条或后 N 条消息
- 如果位置为 None，则包括来自该来源的所有消息
此代理与直接消息传递和基于团队的执行（例如 GraphFlow）兼容。

示例
```python
>>> agent_a = MessageFilterAgent(
...     name="A",
...     wrapped_agent=some_other_agent,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="B", position="last", count=2),
...         ]
...     ),
... )
```

使用图表的示例用例：假设您有一个循环的多代理图：A → B → A → B → C。
您希望：
- A 只看到用户消息和来自 B 的最后一条消息
- B 看到用户消息、来自 A 的最后一条消息以及其自身的先前响应（用于反思）
- C 看到用户消息和来自 B 的最后一条消息
像这样包装代理：
```python
>>> agent_a = MessageFilterAgent(
...     name="A",
...     wrapped_agent=agent_a_inner,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="B", position="last", count=1),
...         ]
...     ),
... )
```

```python
>>> agent_b = MessageFilterAgent(
...     name="B",
...     wrapped_agent=agent_b_inner,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="A", position="last", count=1),
...             PerSourceFilter(source="B", position="last", count=10),
...         ]
...     ),
... )
```

```python
>>> agent_c = MessageFilterAgent(
...     name="C",
...     wrapped_agent=agent_c_inner,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="B", position="last", count=1),
...         ]
...     ),
... )
```

然后定义图表：
```python
>>> graph = DiGraph(
...     nodes={
...         "A": DiGraphNode(name="A", edges=[DiGraphEdge(target="B")]),
...         "B": DiGraphNode(
...             name="B",
...             edges=[
...                 DiGraphEdge(target="C", condition="exit"),
...                 DiGraphEdge(target="A", condition="loop"),
...             ],
...         ),
...         "C": DiGraphNode(name="C", edges=[]),
...     },
...     default_start_node="A",
... )
```

这将确保每个代理只看到其决策或操作逻辑所需的内容。

```python
classmethod _from_config(config: MessageFilterAgentConfig) → MessageFilterAgent[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → MessageFilterAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】MessageFilterAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.MessageFilterAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回消息流，最终项是响应。`BaseChatAgent` 中的基本实现只是调用 `on_messages()` 并产生响应中的消息。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
pydantic model MessageFilterConfig[source]#
```

【中文翻译】基类：BaseModel

显示 JSON 架构
```json
{
   "title": "MessageFilterConfig",
   "type": "object",
   "properties": {
      "per_source": {
         "items": {
            "$ref": "#/$defs/PerSourceFilter"
         },
         "title": "Per Source",
         "type": "array"
      }
   },
   "$defs": {
      "PerSourceFilter": {
         "properties": {
            "source": {
               "title": "Source",
               "type": "string"
            },
            "position": {
               "anyOf": [
                  {
                     "enum": [
                        "first",
                        "last"
                     ],
                     "type": "string"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Position"
            },
            "count": {
               "anyOf": [
                  {
                     "type": "integer"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Count"
            }
         },
         "required": [
            "source"
         ],
         "title": "PerSourceFilter",
         "type": "object"
      }
   },
   "required": [
      "per_source"
   ]
}
```

字段：

per_source (List[autogen_agentchat.agents._message_filter_agent.PerSourceFilter])

```python
field per_source: List[PerSourceFilter] [Required]#
```

```python
pydantic model PerSourceFilter[source]#
```

【中文翻译】基类：BaseModel

显示 JSON 架构
```json
{
   "title": "PerSourceFilter",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "position": {
         "anyOf": [
            {
               "enum": [
                  "first",
                  "last"
               ],
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Position"
      },
      "count": {
         "anyOf": [
            {
               "type": "integer"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Count"
      }
   },
   "required": [
      "source"
   ]
}
```

字段：

count (int | None)
position (Literal['first', 'last'] | None)
source (str)

```python
field count: int | None = None#
```

```python
field position: Literal['first', 'last'] | None = None#
```

```python
field source: str [Required]#
```

```python
class SocietyOfMindAgent(name: str, team: Team, model_client: ChatCompletionClient, *, description: str = DEFAULT_DESCRIPTION, instruction: str = DEFAULT_INSTRUCTION, response_prompt: str = DEFAULT_RESPONSE_PROMPT, model_context: ChatCompletionContext | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[SocietyOfMindAgentConfig]
一个使用内部代理团队生成响应的代理。
每次调用代理的 `on_messages()` 或 `on_messages_stream()` 方法时，它会运行内部代理团队，然后使用模型客户端根据内部团队的消息生成响应。
一旦生成响应，代理通过调用 `Team.reset()` 重置内部团队。

限制发送到模型的上下文大小：
您可以通过将 `model_context` 参数设置为 `BufferedChatCompletionContext` 来限制发送到模型的消息数量。
这将限制发送到模型的最近消息的数量，并且在模型可以处理的令牌数量有限制时非常有用。
您还可以通过子类化 `ChatCompletionContext` 来创建自己的模型上下文。

参数：

name (str) – 代理的名称。
team (Team) – 要使用的代理团队。
model_client (ChatCompletionClient) – 用于准备响应的模型客户端。
description (str, 可选) – 代理的描述。
instruction (str, 可选) – 使用内部团队消息生成响应时使用的指令。
默认为 `DEFAULT_INSTRUCTION`。它扮演“系统”角色。
response_prompt (str, 可选) – 使用内部团队消息生成响应时使用的响应提示。
默认为 `DEFAULT_RESPONSE_PROMPT`。它扮演“系统”角色。
model_context (ChatCompletionContext | None, 可选) – 用于存储和检索 `LLMMessage` 的模型上下文。它可以预加载初始消息。当代理重置时，初始消息将被清除。

示例：
```python
import asyncio
from autogen_agentchat.ui import Console
from autogen_agentchat.agents import AssistantAgent, SocietyOfMindAgent
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.conditions import TextMentionTermination


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("assistant1", model_client=model_client, system_message="You are a writer, write well.")
    agent2 = AssistantAgent(
        "assistant2",
        model_client=model_client,
        system_message="You are an editor, provide critical feedback. Respond with 'APPROVE' if the text addresses all feedbacks.",
    )
    inner_termination = TextMentionTermination("APPROVE")
    inner_team = RoundRobinGroupChat([agent1, agent2], termination_condition=inner_termination)

    society_of_mind_agent = SocietyOfMindAgent("society_of_mind", team=inner_team, model_client=model_client)

    agent3 = AssistantAgent(
        "assistant3", model_client=model_client, system_message="Translate the text to Spanish."
    )
    team = RoundRobinGroupChat([society_of_mind_agent, agent3], max_turns=2)

    stream = team.run_stream(task="Write a short story with a surprising ending.")
    await Console(stream)


asyncio.run(main())
```

```python
DEFAULT_DESCRIPTION = 'An agent that uses an inner team of agents to generate responses.'#
```

【中文翻译】SocietyOfMindAgent 的默认描述。

类型：
str

```python
DEFAULT_INSTRUCTION = 'Earlier you were asked to fulfill a request. You and your team worked diligently to address that request. Here is a transcript of that conversation:'#
```

【中文翻译】使用内部团队消息生成响应时使用的默认指令。在生成响应时，该指令将附加到内部团队消息之前。它扮演“系统”角色。

类型：
str

```python
DEFAULT_RESPONSE_PROMPT = 'Output a standalone response to the original request, without mentioning any of the intermediate discussion.'#
```

【中文翻译】使用内部团队消息生成响应时使用的默认响应提示。它扮演“系统”角色。

类型：
str

```python
classmethod _from_config(config: SocietyOfMindAgentConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → SocietyOfMindAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】SocietyOfMindAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.SocietyOfMindAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】从保存的状态恢复代理。无状态代理的默认实现。

```python
property model_context: ChatCompletionContext#
```

【中文翻译】代理正在使用的模型上下文。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回消息流，最终项是响应。`BaseChatAgent` 中的基本实现只是调用 `on_messages()` 并产生响应中的消息。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】导出状态。无状态代理的默认实现。

```python
class UserProxyAgent(name: str, *, description: str = 'A human user', input_func: Callable[[str], str] | Callable[[str, CancellationToken | None], Awaitable[str]] | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[UserProxyAgentConfig]
一个可以通过输入函数代表人类用户的代理。
此代理可用于通过提供自定义输入函数在聊天系统中代表人类用户。

注意
使用 `UserProxyAgent` 会使正在运行的团队进入临时阻塞状态，直到用户响应。因此，如果用户未响应，则超时用户输入函数并使用 `CancellationToken` 取消非常重要。
输入函数还应处理异常并在需要时返回默认响应。
对于涉及缓慢人类响应的典型用例，建议使用诸如 `HandoffTermination` 或 `SourceMatchTermination` 之类的终止条件来停止正在运行的团队并将控制权返回给应用程序。
您可以使用用户输入再次运行团队。这样，当用户响应时，可以保存和恢复团队的状态。
有关更多信息，请参阅 Human-in-the-loop。

参数：

name (str) – 代理的名称。
description (str, 可选) – 代理的描述。
input_func (Optional[Callable[[str], str]], Callable[[str, Optional[CancellationToken]], Awaitable[str]]) – 一个接受提示并返回用户输入字符串的函数。

有关与 Web 和 UI 框架集成的示例，请参阅以下内容：

FastAPI
ChainLit

示例
简单用法案例：
```python
import asyncio
from autogen_core import CancellationToken
from autogen_agentchat.agents import UserProxyAgent
from autogen_agentchat.messages import TextMessage


async def simple_user_agent():
    agent = UserProxyAgent("user_proxy")
    response = await asyncio.create_task(
        agent.on_messages(
            [TextMessage(content="What is your name? ", source="user")],
            cancellation_token=CancellationToken(),
        )
    )
    assert isinstance(response.chat_message, TextMessage)
    print(f"Your name is {response.chat_message.content}")
```

示例
可取消用法案例：
```python
import asyncio
from typing import Any
from autogen_core import CancellationToken
from autogen_agentchat.agents import UserProxyAgent
from autogen_agentchat.messages import TextMessage


token = CancellationToken()
agent = UserProxyAgent("user_proxy")


async def timeout(delay: float):
    await asyncio.sleep(delay)


def cancellation_callback(task: asyncio.Task[Any]):
    token.cancel()


async def cancellable_user_agent():
    try:
        timeout_task = asyncio.create_task(timeout(3))
        timeout_task.add_done_callback(cancellation_callback)
        agent_task = asyncio.create_task(
            agent.on_messages(
                [TextMessage(content="What is your name? ", source="user")],
                cancellation_token=token,
            )
        )
        response = await agent_task
        assert isinstance(response.chat_message, TextMessage)
        print(f"Your name is {response.chat_message.content}")
    except Exception as e:
        print(f"Exception: {e}")
    except BaseException as e:
        print(f"BaseException: {e}")
```

```python
class InputRequestContext[source]#
```

【中文翻译】基类：object

```python
classmethod request_id() → str[source]#
```

```python
classmethod _from_config(config: UserProxyAgentConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → UserProxyAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】UserProxyAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.UserProxyAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_type: ClassVar[ComponentType] = 'agent'#
```

【中文翻译】组件的逻辑类型。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】通过请求用户输入来处理传入消息。

```python
async on_reset(cancellation_token: CancellationToken | None = None) → None[source]#
```

【中文翻译】重置代理状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】此代理可以生成的消息类型。

【中文翻译】此模块初始化包提供的各种预定义代理。
`BaseChatAgent` 是 AgentChat 中所有代理的基类。

【中文翻译】上一页

【中文翻译】autogen_agentchat.messages

【中文翻译】下一页

【中文翻译】autogen_agentchat.tools

### autogen_agentchat.agents {autogen_agentchatagents}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.agents.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.agents.html)

```python
class AssistantAgent(name: str, model_client: ChatCompletionClient, *, tools: List[BaseTool[Any, Any] | Callable[[...], Any] | Callable[[...], Awaitable[Any]]] | None = None, workbench: Workbench | None = None, handoffs: List[Handoff | str] | None = None, model_context: ChatCompletionContext | None = None, description: str = 'An agent that provides assistance with ability to use tools.', system_message: str | None = 'You are a helpful AI assistant. Solve tasks using your tools. Reply with TERMINATE when the task has been completed.', model_client_stream: bool = False, reflect_on_tool_use: bool | None = None, tool_call_summary_format: str = '{result}', output_content_type: type[BaseModel] | None = None, output_content_type_format: str | None = None, memory: Sequence[Memory] | None = None, metadata: Dict[str, str] | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[AssistantAgentConfig]
一个提供工具使用协助的代理。
`on_messages()` 返回一个 `Response` 对象，
其中 `chat_message` 是最终的响应消息。
`on_messages_stream()` 创建一个异步生成器，
它会按创建顺序生成内部消息，并在关闭生成器之前将 `Response` 对象作为最后一项。
`BaseChatAgent.run()` 方法返回一个 `TaskResult`，
其中包含代理生成的消息。在消息列表 `messages` 中，
最后一条消息是最终的响应消息。
`BaseChatAgent.run_stream()` 方法创建一个异步生成器，
它会按创建顺序生成内部消息，并在关闭生成器之前将 `TaskResult` 对象作为最后一项。

注意
调用者在每次调用 `on_messages()`、`on_messages_stream()`、`BaseChatAgent.run()` 或 `BaseChatAgent.run_stream()` 方法时，只能向代理传递新消息。
代理在这些方法的调用之间维护其状态。
不要在每次调用时都将整个对话历史传递给代理。

警告
助手代理不是线程安全或协程安全的。
它不应在多个任务或协程之间共享，并且不应并发调用其方法。

下图显示了助手代理的工作原理：

结构化输出：
如果设置了 `output_content_type`，代理默认将在最终响应中以 `StructuredMessage` 而不是 `TextMessage` 进行响应。

注意
目前，设置 `output_content_type` 会阻止代理调用 `load_component` 和 `dump_component` 方法以进行可序列化配置。这将在未来很快修复。

工具调用行为：

如果模型未返回工具调用，则响应会立即作为 `TextMessage` 或 `StructuredMessage`（使用结构化输出时）在 `chat_message` 中返回。

当模型返回工具调用时，它们将立即执行：
当 `reflect_on_tool_use` 为 False 时，工具调用结果将作为 `ToolCallSummaryMessage` 在 `chat_message` 中返回。可以使用 `tool_call_summary_format` 自定义工具调用摘要。
当 `reflect_on_tool_use` 为 True 时，将使用工具调用和结果进行另一次模型推理，最终响应将作为 `TextMessage` 或 `StructuredMessage`（使用结构化输出时）在 `chat_message` 中返回。
当设置 `output_content_type` 时，`reflect_on_tool_use` 默认为 True。
当未设置 `output_content_type` 时，`reflect_on_tool_use` 默认为 False。

如果模型返回多个工具调用，它们将并发执行。要禁用并行工具调用，您需要配置模型客户端。例如，为 `OpenAIChatCompletionClient` 和 `AzureOpenAIChatCompletionClient` 设置 `parallel_tool_calls=False`。

提示
默认情况下，当进行工具调用时，工具调用结果将作为响应返回。
因此，建议注意工具返回值的格式，特别是如果另一个代理期望它们采用特定格式。
如果需要，请使用 `tool_call_summary_format` 自定义工具调用摘要。

移交行为：

如果触发了移交，`HandoffMessage` 将在 `chat_message` 中返回。
如果存在工具调用，它们也将在返回移交之前立即执行。
工具调用和结果通过上下文传递给目标代理。

注意
如果检测到多个移交，则仅执行第一个移交。
为避免这种情况，请在模型客户端配置中禁用并行工具调用。

限制发送到模型的上下文大小：
您可以通过将 `model_context` 参数设置为 `BufferedChatCompletionContext` 来限制发送到模型的消息数量。
这将限制发送到模型的最近消息的数量，并且在模型可以处理的令牌数量有限制时非常有用。
另一种选择是使用 `TokenLimitedChatCompletionContext`，它将限制发送到模型的令牌数量。
您还可以通过子类化 `ChatCompletionContext` 来创建自己的模型上下文。

流式模式：
通过设置 `model_client_stream=True`，助手代理可以在流式模式下使用。
在此模式下，`on_messages_stream()` 和 `BaseChatAgent.run_stream()` 方法还将产生 `ModelClientStreamingChunkEvent` 消息，因为模型客户端会生成响应块。
块消息不会包含在最终响应的内部消息中。

参数：

name (str) – 代理的名称。
model_client (ChatCompletionClient) – 用于推理的模型客户端。
tools (List[BaseTool[Any, Any] | Callable[..., Any] | Callable[..., Awaitable[Any]]] | None, 可选) – 要向代理注册的工具。
workbench (Workbench | None, 可选) – 要用于代理的工作台。
设置工作台后不能使用工具，反之亦然。
handoffs (List[HandoffBase | str] | None, 可选) – 代理的移交配置，
允许它通过响应 `HandoffMessage` 来转移到其他代理。
仅当团队处于 Swarm 模式时才执行转移。
如果移交是字符串，则它应表示目标代理的名称。
model_context (ChatCompletionContext | None, 可选) – 用于存储和检索 `LLMMessage` 的模型上下文。它可以预加载初始消息。当代理重置时，初始消息将被清除。
description (str, 可选) – 代理的描述。
system_message (str, 可选) – 模型的系统消息。如果提供，它将在进行推理时附加到模型上下文中的消息之前。设置为 None 以禁用。
model_client_stream (bool, 可选) – 如果为 True，模型客户端将以流式模式使用。
`on_messages_stream()` 和 `BaseChatAgent.run_stream()` 方法还将产生 `ModelClientStreamingChunkEvent` 消息，因为模型客户端会生成响应块。默认为 False。
reflect_on_tool_use (bool, 可选) – 如果为 True，代理将使用工具调用和结果进行另一次模型推理以生成响应。如果为 False，工具调用结果将作为响应返回。默认情况下，如果设置了 `output_content_type`，则此值为 True；如果未设置 `output_content_type`，则此值为 False。
output_content_type (type[BaseModel] | None, 可选) – `StructuredMessage` 响应的输出内容类型，作为 Pydantic 模型。
这将与模型客户端一起使用以生成结构化输出。
如果设置了此项，代理将在最终响应中以 `StructuredMessage` 而不是 `TextMessage` 进行响应，除非 `reflect_on_tool_use` 为 False 并且进行了工具调用。
output_content_type_format (str | None, 可选) – (实验性) 用于 `StructuredMessage` 响应内容的格式字符串。
tool_call_summary_format (str, 可选) – 用于为 `ToolCallSummaryMessage` 响应创建内容的格式字符串。
该格式字符串用于格式化每个工具调用结果的工具调用摘要。
默认为 “{result}”。
当 `reflect_on_tool_use` 为 False 时，所有工具调用摘要的串联（以换行符 ’n’ 分隔）将作为响应返回。
可用变量：{tool_name}、{arguments}、{result}。
例如，“{tool_name}: {result}” 将创建一个类似于 “tool_name: result” 的摘要。
memory (Sequence[Memory] | None, 可选) – 要用于代理的内存存储。默认为 None。
metadata (Dict[str, str] | None, 可选) – 用于跟踪的可选元数据。

引发：

ValueError – 如果工具名称不唯一。
ValueError – 如果移交名称不唯一。
ValueError – 如果移交名称与工具名称不唯一。
ValueError – 如果最大工具迭代次数小于 1。

示例
示例 1：基本代理
以下示例演示了如何使用模型客户端创建助手代理并生成对简单任务的响应。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o",
        # api_key = "your_openai_api_key"
    )
    agent = AssistantAgent(name="assistant", model_client=model_client)

    result = await agent.run(task="Name two cities in North America.")
    print(result)


asyncio.run(main())
```

示例 2：模型客户端令牌流
此示例演示了如何使用模型客户端创建助手代理，并通过设置 `model_client_stream=True` 来生成令牌流。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o",
        # api_key = "your_openai_api_key"
    )
    agent = AssistantAgent(
        name="assistant",
        model_client=model_client,
        model_client_stream=True,
    )

    stream = agent.run_stream(task="Name two cities in North America.")
    async for message in stream:
        print(message)


asyncio.run(main())
```

```
source='user' models_usage=None metadata={} content='Name two cities in North America.' type='TextMessage'
source='assistant' models_usage=None metadata={} content='Two' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' cities' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' in' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' North' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' America' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' are' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' New' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' York' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' City' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' and' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' Toronto' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content='.' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content=' TERMIN' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=None metadata={} content='ATE' type='ModelClientStreamingChunkEvent'
source='assistant' models_usage=RequestUsage(prompt_tokens=0, completion_tokens=0) metadata={} content='Two cities in North America are New York City and Toronto. TERMINATE' type='TextMessage'
messages=[TextMessage(source='user', models_usage=None, metadata={}, content='Name two cities in North America.', type='TextMessage'), TextMessage(source='assistant', models_usage=RequestUsage(prompt_tokens=0, completion_tokens=0), metadata={}, content='Two cities in North America are New York City and Toronto. TERMINATE', type='TextMessage')] stop_reason=None
```

示例 3：带工具的代理
以下示例演示了如何使用模型客户端和工具创建助手代理，为任务生成消息流，并使用 Console 将消息打印到控制台。
该工具是一个返回当前时间的简单函数。
在底层，该函数被包装在 `FunctionTool` 中，并与代理的模型客户端一起使用。函数的文档字符串用作工具描述，函数名称用作工具名称，包括类型提示在内的函数签名用作工具参数。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.ui import Console


async def get_current_time() -> str:
    return "The current time is 12:00 PM."


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o",
        # api_key = "your_openai_api_key"
    )
    agent = AssistantAgent(name="assistant", model_client=model_client, tools=[get_current_time])
    await Console(agent.run_stream(task="What is the current time?"))


asyncio.run(main())
```

示例 4：带模型上下文协议 (MCP) 工作台的代理
以下示例演示了如何使用模型客户端和 `McpWorkbench` 创建助手代理，以便与模型上下文协议 (MCP) 服务器交互。
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.ui import Console
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_ext.tools.mcp import StdioServerParams, McpWorkbench


async def main() -> None:
    params = StdioServerParams(
        command="uvx",
        args=["mcp-server-fetch"],
        read_timeout_seconds=60,
    )

    # 您也可以使用 `start()` 和 `stop()` 来管理会话。
    async with McpWorkbench(server_params=params) as workbench:
        model_client = OpenAIChatCompletionClient(model="gpt-4.1-nano")
        assistant = AssistantAgent(
            name="Assistant",
            model_client=model_client,
            workbench=workbench,
            reflect_on_tool_use=True,
        )
        await Console(
            assistant.run_stream(task="Go to https://github.com/microsoft/autogen and tell me what you see.")
        )


asyncio.run(main())
```

示例 5：带结构化输出和工具的代理
以下示例演示了如何创建助手代理，该代理使用配置为使用结构化输出的模型客户端和工具。
请注意，您需要使用 `FunctionTool` 来创建工具，并且 `strict=True` 是结构化输出模式所必需的。
由于模型配置为使用结构化输出，因此输出反射响应将是 JSON 格式的字符串。
```python
import asyncio
from typing import Literal

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.ui import Console
from autogen_core.tools import FunctionTool
from autogen_ext.models.openai import OpenAIChatCompletionClient
from pydantic import BaseModel


# 定义结构化输出格式。
class AgentResponse(BaseModel):
    thoughts: str
    response: Literal["happy", "sad", "neutral"]


# 定义要作为工具调用的函数。
def sentiment_analysis(text: str) -> str:
    """Given a text, return the sentiment."""
    return "happy" if "happy" in text else "sad" if "sad" in text else "neutral"


# 创建一个 `FunctionTool` 实例，其中 `strict=True`，
# 这对于结构化输出模式是必需的。
tool = FunctionTool(sentiment_analysis, description="Sentiment Analysis", strict=True)

# 创建一个支持结构化输出的 `OpenAIChatCompletionClient` 实例。
model_client = OpenAIChatCompletionClient(
    model="gpt-4o-mini",
)

# 创建一个使用该工具和模型客户端的 `AssistantAgent` 实例。
agent = AssistantAgent(
    name="assistant",
    model_client=model_client,
    tools=[tool],
    system_message="Use the tool to analyze sentiment.",
    output_content_type=AgentResponse,
)


async def main() -> None:
    stream = agent.run_stream(task="I am happy today!")
    await Console(stream)


asyncio.run(main())
```

```
---------- assistant ----------
[FunctionCall(id='call_tIZjAVyKEDuijbBwLY6RHV2p', arguments='{"text":"I am happy today!"}', name='sentiment_analysis')]
---------- assistant ----------
[FunctionExecutionResult(content='happy', call_id='call_tIZjAVyKEDuijbBwLY6RHV2p', is_error=False)]
---------- assistant ----------
{"thoughts":"The user expresses a clear positive emotion by stating they are happy today, suggesting an upbeat mood.","response":"happy"}
```

示例 6：带限定模型上下文的代理
以下示例显示了如何使用 `BufferedChatCompletionContext`，它只保留最后 2 条消息（1 条用户消息 + 1 条助手消息）。
当模型可以处理的令牌数量有限制时，限定模型上下文非常有用。
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_core.model_context import BufferedChatCompletionContext
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    # 创建一个模型客户端。
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o-mini",
        # api_key = "your_openai_api_key"
    )

    # 创建一个只保留最后 2 条消息的模型上下文（1 条用户消息 + 1 条助手消息）。
    model_context = BufferedChatCompletionContext(buffer_size=2)

    # 使用模型客户端和上下文创建一个 `AssistantAgent` 实例。
    agent = AssistantAgent(
        name="assistant",
        model_client=model_client,
        model_context=model_context,
        system_message="You are a helpful assistant.",
    )

    result = await agent.run(task="Name two cities in North America.")
    print(result.messages[-1].content)  # type: ignore

    result = await agent.run(task="My favorite color is blue.")
    print(result.messages[-1].content)  # type: ignore

    result = await agent.run(task="Did I ask you any question?")
    print(result.messages[-1].content)  # type: ignore


asyncio.run(main())
```

```
Two cities in North America are New York City and Toronto.
That's great! Blue is often associated with calmness and serenity. Do you have a specific shade of blue that you like, or any particular reason why it's your favorite?
No, you didn't ask a question. I apologize for any misunderstanding. If you have something specific you'd like to discuss or ask, feel free to let me know!
```

示例 7：带内存的代理
以下示例显示了如何将基于列表的内存与助手代理一起使用。
内存预加载了一些初始内容。
在底层，内存在进行推理之前使用 `update_context()` 方法更新模型上下文。
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_core.memory import ListMemory, MemoryContent
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    # 创建一个模型客户端。
    model_client = OpenAIChatCompletionClient(
        model="gpt-4o-mini",
        # api_key = "your_openai_api_key"
    )

    # 创建一个带有一些初始内容的基于列表的内存。
    memory = ListMemory()
    await memory.add(MemoryContent(content="User likes pizza.", mime_type="text/plain"))
    await memory.add(MemoryContent(content="User dislikes cheese.", mime_type="text/plain"))

    # 使用模型客户端和内存创建一个 `AssistantAgent` 实例。
    agent = AssistantAgent(
        name="assistant",
        model_client=model_client,
        memory=[memory],
        system_message="You are a helpful assistant.",
    )

    result = await agent.run(task="What is a good dinner idea?")
    print(result.messages[-1].content)  # type: ignore


asyncio.run(main())
```

```
How about making a delicious pizza without cheese? You can create a flavorful veggie pizza with a variety of toppings. Here's a quick idea:

**Veggie Tomato Sauce Pizza**
- Start with a pizza crust (store-bought or homemade).
- Spread a layer of marinara or tomato sauce evenly over the crust.
- Top with your favorite vegetables like bell peppers, mushrooms, onions, olives, and spinach.
- Add some protein if you’d like, such as grilled chicken or pepperoni (ensure it's cheese-free).
- Sprinkle with herbs like oregano and basil, and maybe a drizzle of olive oil.
- Bake according to the crust instructions until the edges are golden and the veggies are cooked.

Serve it with a side salad or some garlic bread to complete the meal! Enjoy your dinner!
```

示例 8：带 `o1-mini` 的代理
以下示例显示了如何将 o1-mini 模型与助手代理一起使用。
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent


async def main() -> None:
    model_client = OpenAIChatCompletionClient(
        model="o1-mini",
        # api_key = "your_openai_api_key"
    )
    # o1 系列模型不支持系统消息。
    agent = AssistantAgent(name="assistant", model_client=model_client, system_message=None)

    result = await agent.run(task="What is the capital of France?")
    print(result.messages[-1].content)  # type: ignore


asyncio.run(main())
```

注意
o1-preview 和 o1-mini 模型不支持系统消息和函数调用。
因此，`system_message` 应设置为 None，并且不应设置工具和移交。
有关更多详细信息，请参阅 o1 beta 限制。

示例 9：使用带自定义模型上下文的推理模型的代理。
以下示例显示了如何将推理模型 (DeepSeek R1) 与助手代理一起使用。
模型上下文用于从助手消息中过滤掉 thought 字段。
```python
import asyncio
from typing import List

from autogen_agentchat.agents import AssistantAgent
from autogen_core.model_context import UnboundedChatCompletionContext
from autogen_core.models import AssistantMessage, LLMMessage, ModelFamily
from autogen_ext.models.ollama import OllamaChatCompletionClient


class ReasoningModelContext(UnboundedChatCompletionContext):
    """A model context for reasoning models."""

    async def get_messages(self) -> List[LLMMessage]:
        messages = await super().get_messages()
        # Filter out thought field from AssistantMessage.
        messages_out: List[LLMMessage] = []
        for message in messages:
            if isinstance(message, AssistantMessage):
                message.thought = None
            messages_out.append(message)
        return messages_out


# 创建一个在 Ollama 上本地托管的 DeepSeek R1 模型客户端实例。
model_client = OllamaChatCompletionClient(
    model="deepseek-r1:8b",
    model_info={
        "vision": False,
        "function_calling": False,
        "json_output": False,
        "family": ModelFamily.R1,
        "structured_output": True,
    },
)

agent = AssistantAgent(
    "reasoning_agent",
    model_client=model_client,
    model_context=ReasoningModelContext(),  # 使用自定义模型上下文。
)


async def run_reasoning_agent() -> None:
    result = await agent.run(task="What is the capital of France?")
    print(result)


asyncio.run(run_reasoning_agent())
```

```python
component_config_schema#
```

【中文翻译】AssistantAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.AssistantAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载助手代理的状态

```python
property model_context: ChatCompletionContext#
```

【中文翻译】代理正在使用的模型上下文。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】使用助手代理处理传入消息，并在事件/响应发生时产生它们。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将助手代理重置为其初始化状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存助手代理的当前状态。

```python
class BaseChatAgent(name: str, description: str)[source]#
```

【中文翻译】基类：ChatAgent, ABC, ComponentBase[BaseModel]
聊天代理的基类。
此抽象类为 `ChatAgent` 提供了基本实现。
要创建新的聊天代理，请子类化此类并实现 `on_messages()`、`on_reset()` 和 `produced_message_types`。
如果需要流式处理，还要实现 `on_messages_stream()` 方法。
代理被认为是状态性的，并在对 `on_messages()` 或 `on_messages_stream()` 方法的调用之间保持其状态。
代理应将其状态存储在代理实例中。代理还应实现 `on_reset()` 方法以将代理重置为其初始化状态。

注意
调用者在每次调用 `on_messages()` 或 `on_messages_stream()` 方法时，只应向代理传递新消息。
不要在每次调用时都将整个对话历史传递给代理。
创建新代理时必须遵循此设计原则。

```python
async close() → None[source]#
```

【中文翻译】释放代理持有的任何资源。在 `BaseChatAgent` 类中，这默认是一个无操作。子类可以覆盖此方法以实现自定义关闭行为。

```python
component_type: ClassVar[ComponentType] = 'agent'#
```

【中文翻译】组件的逻辑类型。

```python
property description: str#
```

【中文翻译】代理的描述。团队使用此描述来决定使用哪些代理。描述应说明代理的功能以及如何与其交互。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】从保存的状态恢复代理。无状态代理的默认实现。

```python
property name: str#
```

【中文翻译】代理的名称。团队使用此名称来唯一标识代理。它在团队中应该是唯一的。

```python
abstract async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回消息流，最终项是响应。`BaseChatAgent` 中的基本实现只是调用 `on_messages()` 并产生响应中的消息。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_pause(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理在其 `on_messages()` 或 `on_messages_stream()` 方法中运行时被暂停时调用。在 `BaseChatAgent` 类中，这默认是一个无操作。子类可以覆盖此方法以实现自定义暂停行为。

```python
abstract async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
async on_resume(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理在其 `on_messages()` 或 `on_messages_stream()` 方法中运行时从暂停中恢复时调用。
在 `BaseChatAgent` 类中，这默认是一个无操作。
子类可以覆盖此方法以实现自定义恢复行为。

```python
abstract property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
async run(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → TaskResult[source]#
```

【中文翻译】使用给定的任务运行代理并返回结果。

```python
async run_stream(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None][source]#
```

【中文翻译】使用给定的任务运行代理，并返回消息流，最终的任务结果作为流中的最后一项。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】导出状态。无状态代理的默认实现。

```python
class CodeExecutorAgent(name: str, code_executor: CodeExecutor, *, model_client: ChatCompletionClient | None = None, model_context: ChatCompletionContext | None = None, model_client_stream: bool = False, max_retries_on_error: int = 0, description: str | None = None, system_message: str | None = DEFAULT_SYSTEM_MESSAGE, sources: Sequence[str] | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[CodeExecutorAgentConfig]
（实验性）一个根据用户指令生成并执行代码片段的代理。

注意
此代理是实验性的，可能会在未来版本中更改。

它通常在团队中使用，与另一个生成要执行的代码片段的代理一起使用，或者单独使用提供的 `model_client`，以便它可以根据用户查询生成代码、执行代码并反思代码结果。
当与 `model_client` 一起使用时，它将使用模型生成代码片段，并使用提供的 `code_executor` 执行它们。模型还将反思代码执行结果。代理将产生模型的最终反思结果作为最终响应。
当不使用 `model_client` 时，它将仅执行在 `TextMessage` 消息中找到的代码块，并返回代码执行的输出。

注意
使用带有 `PythonCodeExecutionTool` 的 `AssistantAgent` 是此代理的替代方案。但是，该代理的模型必须生成正确转义的代码字符串作为工具的参数。

参数：

name (str) – 代理的名称。
code_executor (CodeExecutor) – 负责执行消息中接收到的代码的代码执行器（建议使用 `DockerCommandLineCodeExecutor`。请参见下面的示例）
model_client (ChatCompletionClient, 可选) – 用于推理和生成代码的模型客户端。
如果未提供，代理将仅执行输入消息中找到的代码块。
目前，模型必须支持结构化输出模式，这是自动重试机制工作所必需的。
model_client_stream (bool, 可选) – 如果为 True，模型客户端将以流式模式使用。
`on_messages_stream()` 和 `BaseChatAgent.run_stream()` 方法还将产生 `ModelClientStreamingChunkEvent` 消息，因为模型客户端会生成响应块。默认为 False。
description (str, 可选) – 代理的描述。如果未提供，将使用 `DEFAULT_AGENT_DESCRIPTION`。
system_message (str, 可选) – 模型的系统消息。如果提供，它将在进行推理时附加到模型上下文中的消息之前。设置为 None 以禁用。
默认为 `DEFAULT_SYSTEM_MESSAGE`。仅当提供了 `model_client` 时才使用。
sources (Sequence[str], 可选) – 仅检查来自指定代理的消息以执行代码。
当代理是群聊的一部分并且您希望将代码执行限制为来自特定代理的消息时，这很有用。
如果未提供，将检查所有消息中的代码块。
仅当未提供 `model_client` 时才使用。
max_retries_on_error (int, 可选) – 错误时的最大重试次数。如果代码执行失败，代理将重试最多此次数。
如果代码执行在此次数的重试后失败，代理将产生一个反思结果。

注意
建议 `CodeExecutorAgent` 代理使用 Docker 容器来执行代码。这确保了模型生成的代码在隔离的环境中执行。要使用 Docker，您的环境必须安装并运行 Docker。
请按照 Docker 的安装说明进行操作。

注意
代码执行器仅处理使用三个反引号正确格式化的 Markdown 代码块中的代码。
例如：
```python
print("Hello World")
```

# 或

```sh
echo "Hello World"
```

在此示例中，我们展示了如何设置一个 `CodeExecutorAgent` 代理，该代理使用 `DockerCommandLineCodeExecutor` 在 Docker 容器中执行代码片段。`work_dir` 参数指示所有执行的文件在 Docker 容器中执行之前首先在本地保存的位置。
```python
import asyncio
from autogen_agentchat.agents import CodeExecutorAgent
from autogen_agentchat.messages import TextMessage
from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_core import CancellationToken


async def run_code_executor_agent() -> None:
    # 创建一个使用 Docker 容器执行代码的代码执行器代理。
    code_executor = DockerCommandLineCodeExecutor(work_dir="coding")
    await code_executor.start()
    code_executor_agent = CodeExecutorAgent("code_executor", code_executor=code_executor)

    # 使用给定的代码片段运行代理。
    task = TextMessage(
        content='''Here is some code
```python
print('Hello world')
```
''',
        source="user",
    )
    response = await code_executor_agent.on_messages([task], CancellationToken())
    print(response.chat_message)

    # 停止代码执行器。
    await code_executor.stop()


asyncio.run(run_code_executor_agent())
```

在此示例中，我们展示了如何设置一个 `CodeExecutorAgent` 代理，该代理使用 `DeviceRequest` 将 GPU 暴露给容器以进行 cuda 加速的代码执行。
```python
import asyncio
from autogen_agentchat.agents import CodeExecutorAgent
from autogen_agentchat.messages import TextMessage
from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_core import CancellationToken
from docker.types import DeviceRequest


async def run_code_executor_agent() -> None:
    # 创建一个使用 Docker 容器执行代码的代码执行器代理。
    code_executor = DockerCommandLineCodeExecutor(
        work_dir="coding", device_requests=[DeviceRequest(count=-1, capabilities=[["gpu"]])]
    )
    await code_executor.start()
    code_executor_agent = CodeExecutorAgent("code_executor", code_executor=code_executor)

    # 显示 GPU 信息
    task = TextMessage(
        content='''Here is some code
```bash
nvidia-smi
```
''',
        source="user",
    )
    response = await code_executor_agent.on_messages([task], CancellationToken())
    print(response.chat_message)

    # 停止代码执行器。
    await code_executor.stop()


asyncio.run(run_code_executor_agent())
```

在以下示例中，我们展示了如何在不使用 `model_client` 参数的情况下设置 `CodeExecutorAgent`，以便使用 `DockerCommandLineCodeExecutor` 执行群聊中其他代理生成的代码块。
```python
import asyncio

from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_ext.models.openai import OpenAIChatCompletionClient

from autogen_agentchat.agents import AssistantAgent, CodeExecutorAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.ui import Console

termination_condition = MaxMessageTermination(3)


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    # 定义 Docker CLI 代码执行器
    code_executor = DockerCommandLineCodeExecutor(work_dir="coding")

    # 启动执行容器
    await code_executor.start()

    code_executor_agent = CodeExecutorAgent("code_executor_agent", code_executor=code_executor)
    coder_agent = AssistantAgent("coder_agent", model_client=model_client)

    groupchat = RoundRobinGroupChat(
        participants=[coder_agent, code_executor_agent], termination_condition=termination_condition
    )

    task = "Write python code to print Hello World!"
    await Console(groupchat.run_stream(task=task))

    # 停止执行容器
    await code_executor.stop()


asyncio.run(main())
```

```
---------- user ----------
Write python code to print Hello World!
---------- coder_agent ----------
Certainly! Here's a simple Python code to print "Hello World!":

```python
print("Hello World!")
```

You can run this code in any Python environment to display the message.
---------- code_executor_agent ----------
Hello World!
```

在以下示例中，我们展示了如何使用 `model_client` 设置 `CodeExecutorAgent`，该代理可以在没有任何其他代理帮助的情况下生成自己的代码，并在 `DockerCommandLineCodeExecutor` 中执行它。
```python
import asyncio

from autogen_ext.code_executors.docker import DockerCommandLineCodeExecutor
from autogen_ext.models.openai import OpenAIChatCompletionClient

from autogen_agentchat.agents import CodeExecutorAgent
from autogen_agentchat.conditions import TextMessageTermination
from autogen_agentchat.ui import Console

termination_condition = TextMessageTermination("code_executor_agent")


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    # 定义 Docker CLI 代码执行器
    code_executor = DockerCommandLineCodeExecutor(work_dir="coding")

    # 启动执行容器
    await code_executor.start()

    code_executor_agent = CodeExecutorAgent(
        "code_executor_agent", code_executor=code_executor, model_client=model_client
    )

    task = "Write python code to print Hello World!"
    await Console(code_executor_agent.run_stream(task=task))

    # 停止执行容器
    await code_executor.stop()


asyncio.run(main())
```

```
---------- user ----------
Write python code to print Hello World!
---------- code_executor_agent ----------
Certainly! Here is a simple Python code to print "Hello World!" to the console:

```python
print("Hello World!")
```

Let's execute it to confirm the output.
---------- code_executor_agent ----------
Hello World!

---------- code_executor_agent ----------
The code has been executed successfully, and it printed "Hello World!" as expected. If you have any more requests or questions, feel free to ask!
```

```python
DEFAULT_AGENT_DESCRIPTION = 'A Code Execution Agent that generates and executes Python and shell scripts based on user instructions. Python code should be provided in ```python code blocks, and sh shell scripts should be provided in ```sh code blocks for execution. It ensures correctness, efficiency, and minimal errors while gracefully handling edge cases.'#
```

```python
DEFAULT_SYSTEM_MESSAGE = 'You are a Code Execution Agent. Your role is to generate and execute Python code based on user instructions, ensuring correctness, efficiency, and minimal errors. Handle edge cases gracefully.'#
```

```python
DEFAULT_TERMINAL_DESCRIPTION = 'A computer terminal that performs no other action than running Python scripts (provided to it quoted in ```python code blocks), or sh shell scripts (provided to it quoted in ```sh code blocks).'#
```

```python
NO_CODE_BLOCKS_FOUND_MESSAGE = 'No code blocks found in the thread. Please provide at least one markdown-encoded code block to execute (i.e., quoting code in ```python or ```sh code blocks).'#
```

```python
classmethod _from_config(config: CodeExecutorAgentConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → CodeExecutorAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】CodeExecutorAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.CodeExecutorAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async execute_code_block(code_blocks: List[CodeBlock], cancellation_token: CancellationToken) → CodeResult[source]#
```

```python
async extract_code_blocks_from_messages(messages: Sequence[BaseChatMessage]) → List[CodeBlock][source]#
```

```python
property model_context: ChatCompletionContext#
```

【中文翻译】代理正在使用的模型上下文。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】使用助手代理处理传入消息，并在事件/响应发生时产生它们。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】这是一个无操作，因为代码执行器代理没有可变状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代码执行器代理生成的消息类型。

```python
class MessageFilterAgent(name: str, wrapped_agent: BaseChatAgent, filter: MessageFilterConfig)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[MessageFilterAgentConfig]
一个包装代理，在将传入消息传递给内部代理之前对其进行过滤。

警告
这是一项实验性功能，API 将在未来的版本中更改。

这在多代理工作流等场景中非常有用，其中代理只应处理完整消息历史记录的子集——例如，仅处理每个上游代理的最后一条消息，或仅处理特定来源的第一条消息。
使用 `MessageFilterConfig` 配置过滤，它支持：
- 按消息来源过滤（例如，仅来自“用户”或其他代理的消息）
- 从每个来源选择前 N 条或后 N 条消息
- 如果位置为 None，则包括来自该来源的所有消息
此代理与直接消息传递和基于团队的执行（例如 GraphFlow）兼容。

示例```python
>>> agent_a = MessageFilterAgent(
...     name="A",
...     wrapped_agent=some_other_agent,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="B", position="last", count=2),
...         ]
...     ),
... )
```

使用图表的示例用例：假设您有一个循环的多代理图：A → B → A → B → C。
您希望：
- A 只看到用户消息和来自 B 的最后一条消息
- B 看到用户消息、来自 A 的最后一条消息以及其自身的先前响应（用于反思）
- C 看到用户消息和来自 B 的最后一条消息
像这样包装代理：
```python
>>> agent_a = MessageFilterAgent(
...     name="A",
...     wrapped_agent=agent_a_inner,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="B", position="last", count=1),
...         ]
...     ),
... )
```

```python
>>> agent_b = MessageFilterAgent(
...     name="B",
...     wrapped_agent=agent_b_inner,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="A", position="last", count=1),
...             PerSourceFilter(source="B", position="last", count=10),
...         ]
...     ),
... )
```

```python
>>> agent_c = MessageFilterAgent(
...     name="C",
...     wrapped_agent=agent_c_inner,
...     filter=MessageFilterConfig(
...         per_source=[
...             PerSourceFilter(source="user", position="first", count=1),
...             PerSourceFilter(source="B", position="last", count=1),
...         ]
...     ),
... )
```

然后定义图表：
```python
>>> graph = DiGraph(
...     nodes={
...         "A": DiGraphNode(name="A", edges=[DiGraphEdge(target="B")]),
...         "B": DiGraphNode(
...             name="B",
...             edges=[
...                 DiGraphEdge(target="C", condition="exit"),
...                 DiGraphEdge(target="A", condition="loop"),
...             ],
...         ),
...         "C": DiGraphNode(name="C", edges=[]),
...     },
...     default_start_node="A",
... )
```

这将确保每个代理只看到其决策或操作逻辑所需的内容。

```python
classmethod _from_config(config: MessageFilterAgentConfig) → MessageFilterAgent[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → MessageFilterAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】MessageFilterAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.MessageFilterAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回消息流，最终项是响应。`BaseChatAgent` 中的基本实现只是调用 `on_messages()` 并产生响应中的消息。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
pydantic model MessageFilterConfig[source]#
```

【中文翻译】基类：BaseModel

显示 JSON 架构
```json
{
   "title": "MessageFilterConfig",
   "type": "object",
   "properties": {
      "per_source": {
         "items": {
            "$ref": "#/$defs/PerSourceFilter"
         },
         "title": "Per Source",
         "type": "array"
      }
   },
   "$defs": {
      "PerSourceFilter": {
         "properties": {
            "source": {
               "title": "Source",
               "type": "string"
            },
            "position": {
               "anyOf": [
                  {
                     "enum": [
                        "first",
                        "last"
                     ],
                     "type": "string"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Position"
            },
            "count": {
               "anyOf": [
                  {
                     "type": "integer"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Count"
            }
         },
         "required": [
            "source"
         ],
         "title": "PerSourceFilter",
         "type": "object"
      }
   },
   "required": [
      "per_source"
   ]
}
```

字段：

per_source (List[autogen_agentchat.agents._message_filter_agent.PerSourceFilter])

```python
field per_source: List[PerSourceFilter] [Required]#
```

```python
pydantic model PerSourceFilter[source]#
```

【中文翻译】基类：BaseModel

显示 JSON 架构
```json
{
   "title": "PerSourceFilter",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "position": {
         "anyOf": [
            {
               "enum": [
                  "first",
                  "last"
               ],
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Position"
      },
      "count": {
         "anyOf": [
            {
               "type": "integer"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Count"
      }
   },
   "required": [
      "source"
   ]
}
```

字段：

count (int | None)
position (Literal['first', 'last'] | None)
source (str)

```python
field count: int | None = None#
```

```python
field position: Literal['first', 'last'] | None = None#
```

```python
field source: str [Required]#
```

```python
class SocietyOfMindAgent(name: str, team: Team, model_client: ChatCompletionClient, *, description: str = DEFAULT_DESCRIPTION, instruction: str = DEFAULT_INSTRUCTION, response_prompt: str = DEFAULT_RESPONSE_PROMPT, model_context: ChatCompletionContext | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[SocietyOfMindAgentConfig]
一个使用内部代理团队生成响应的代理。
每次调用代理的 `on_messages()` 或 `on_messages_stream()` 方法时，它会运行内部代理团队，然后使用模型客户端根据内部团队的消息生成响应。
一旦生成响应，代理通过调用 `Team.reset()` 重置内部团队。

限制发送到模型的上下文大小：
您可以通过将 `model_context` 参数设置为 `BufferedChatCompletionContext` 来限制发送到模型的消息数量。
这将限制发送到模型的最近消息的数量，并且在模型可以处理的令牌数量有限制时非常有用。
您还可以通过子类化 `ChatCompletionContext` 来创建自己的模型上下文。

参数：

name (str) – 代理的名称。
team (Team) – 要使用的代理团队。
model_client (ChatCompletionClient) – 用于准备响应的模型客户端。
description (str, 可选) – 代理的描述。
instruction (str, 可选) – 使用内部团队消息生成响应时使用的指令。
默认为 `DEFAULT_INSTRUCTION`。它扮演“系统”角色。
response_prompt (str, 可选) – 使用内部团队消息生成响应时使用的响应提示。
默认为 `DEFAULT_RESPONSE_PROMPT`。它扮演“系统”角色。
model_context (ChatCompletionContext | None, 可选) – 用于存储和检索 `LLMMessage` 的模型上下文。它可以预加载初始消息。当代理重置时，初始消息将被清除。

示例：
```python
import asyncio
from autogen_agentchat.ui import Console
from autogen_agentchat.agents import AssistantAgent, SocietyOfMindAgent
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.conditions import TextMentionTermination


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("assistant1", model_client=model_client, system_message="You are a writer, write well.")
    agent2 = AssistantAgent(
        "assistant2",
        model_client=model_client,
        system_message="You are an editor, provide critical feedback. Respond with 'APPROVE' if the text addresses all feedbacks.",
    )
    inner_termination = TextMentionTermination("APPROVE")
    inner_team = RoundRobinGroupChat([agent1, agent2], termination_condition=inner_termination)

    society_of_mind_agent = SocietyOfMindAgent("society_of_mind", team=inner_team, model_client=model_client)

    agent3 = AssistantAgent(
        "assistant3", model_client=model_client, system_message="Translate the text to Spanish."
    )
    team = RoundRobinGroupChat([society_of_mind_agent, agent3], max_turns=2)

    stream = team.run_stream(task="Write a short story with a surprising ending.")
    await Console(stream)


asyncio.run(main())
```

```python
DEFAULT_DESCRIPTION = 'An agent that uses an inner team of agents to generate responses.'#
```

【中文翻译】SocietyOfMindAgent 的默认描述。

类型：
str

```python
DEFAULT_INSTRUCTION = 'Earlier you were asked to fulfill a request. You and your team worked diligently to address that request. Here is a transcript of that conversation:'#
```

【中文翻译】使用内部团队消息生成响应时使用的默认指令。在生成响应时，该指令将附加到内部团队消息之前。它扮演“系统”角色。

类型：
str

```python
DEFAULT_RESPONSE_PROMPT = 'Output a standalone response to the original request, without mentioning any of the intermediate discussion.'#
```

【中文翻译】使用内部团队消息生成响应时使用的默认响应提示。它扮演“系统”角色。

类型：
str

```python
classmethod _from_config(config: SocietyOfMindAgentConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → SocietyOfMindAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】SocietyOfMindAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.SocietyOfMindAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】从保存的状态恢复代理。无状态代理的默认实现。

```python
property model_context: ChatCompletionContext#
```

【中文翻译】代理正在使用的模型上下文。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回消息流，最终项是响应。`BaseChatAgent` 中的基本实现只是调用 `on_messages()` 并产生响应中的消息。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】导出状态。无状态代理的默认实现。

```python
class UserProxyAgent(name: str, *, description: str = 'A human user', input_func: Callable[[str], str] | Callable[[str, CancellationToken | None], Awaitable[str]] | None = None)[source]#
```

【中文翻译】基类：BaseChatAgent, Component[UserProxyAgentConfig]
一个可以通过输入函数代表人类用户的代理。
此代理可用于通过提供自定义输入函数在聊天系统中代表人类用户。

注意
使用 `UserProxyAgent` 会使正在运行的团队进入临时阻塞状态，直到用户响应。因此，如果用户未响应，则超时用户输入函数并使用 `CancellationToken` 取消非常重要。
输入函数还应处理异常并在需要时返回默认响应。
对于涉及缓慢人类响应的典型用例，建议使用诸如 `HandoffTermination` 或 `SourceMatchTermination` 之类的终止条件来停止正在运行的团队并将控制权返回给应用程序。
您可以使用用户输入再次运行团队。这样，当用户响应时，可以保存和恢复团队的状态。
有关更多信息，请参阅 Human-in-the-loop。

参数：

name (str) – 代理的名称。
description (str, 可选) – 代理的描述。
input_func (Optional[Callable[[str], str]], Callable[[str, Optional[CancellationToken]], Awaitable[str]]) – 一个接受提示并返回用户输入字符串的函数。

有关与 Web 和 UI 框架集成的示例，请参阅以下内容：

FastAPI
ChainLit

示例
简单用法案例：
```python
import asyncio
from autogen_core import CancellationToken
from autogen_agentchat.agents import UserProxyAgent
from autogen_agentchat.messages import TextMessage


async def simple_user_agent():
    agent = UserProxyAgent("user_proxy")
    response = await asyncio.create_task(
        agent.on_messages(
            [TextMessage(content="What is your name? ", source="user")],
            cancellation_token=CancellationToken(),
        )
    )
    assert isinstance(response.chat_message, TextMessage)
    print(f"Your name is {response.chat_message.content}")
```

示例
可取消用法案例：
```python
import asyncio
from typing import Any
from autogen_core import CancellationToken
from autogen_agentchat.agents import UserProxyAgent
from autogen_agentchat.messages import TextMessage


token = CancellationToken()
agent = UserProxyAgent("user_proxy")


async def timeout(delay: float):
    await asyncio.sleep(delay)


def cancellation_callback(task: asyncio.Task[Any]):
    token.cancel()


async def cancellable_user_agent():
    try:
        timeout_task = asyncio.create_task(timeout(3))
        timeout_task.add_done_callback(cancellation_callback)
        agent_task = asyncio.create_task(
            agent.on_messages(
                [TextMessage(content="What is your name? ", source="user")],
                cancellation_token=token,
            )
        )
        response = await agent_task
        assert isinstance(response.chat_message, TextMessage)
        print(f"Your name is {response.chat_message.content}")
    except Exception as e:
        print(f"Exception: {e}")
    except BaseException as e:
        print(f"BaseException: {e}")
```

```python
class InputRequestContext[source]#
```

【中文翻译】基类：object

```python
classmethod request_id() → str[source]#
```

```python
classmethod _from_config(config: UserProxyAgentConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → UserProxyAgentConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】UserProxyAgentConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.agents.UserProxyAgent'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_type: ClassVar[ComponentType] = 'agent'#
```

【中文翻译】组件的逻辑类型。

```python
async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

注意
代理是有状态的，传递给此方法的消息应该是自上次调用此方法以来的新消息。代理应在对该方法的调用之间保持其状态。例如，如果代理需要记住先前的消息才能响应当前消息，则应将先前的消息存储在代理状态中。

```python
async on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】通过请求用户输入来处理传入消息。

```python
async on_reset(cancellation_token: CancellationToken | None = None) → None[source]#
```

【中文翻译】重置代理状态。

```python
property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】此代理可以生成的消息类型。

【中文翻译】此模块初始化包提供的各种预定义代理。
`BaseChatAgent` 是 AgentChat 中所有代理的基类。

【中文翻译】上一页

【中文翻译】autogen_agentchat.messages

【中文翻译】下一页

【中文翻译】autogen_agentchat.tools

### autogen_agentchat.base {autogen_agentchatbase}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.base.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.base.html)

```python
class AndTerminationCondition(*conditions: TerminationCondition)[source]#
```

【中文翻译】基类：TerminationCondition, Component[AndTerminationConditionConfig]

```python
component_config_schema#
```

【中文翻译】AndTerminationConditionConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.base.AndTerminationCondition'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_type: ClassVar[ComponentType] = 'termination'#
```

【中文翻译】组件的逻辑类型。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class ChatAgent(*args, **kwargs)[source]#
```

【中文翻译】基类：ABC, TaskRunner, ComponentBase[BaseModel]
聊天代理协议。

```python
abstract async close() → None[source]#
```

【中文翻译】释放代理持有的任何资源。

```python
component_type: ClassVar[ComponentType] = 'agent'#
```

【中文翻译】组件的逻辑类型。

```python
abstract property description: str#
```

【中文翻译】代理的描述。团队使用此描述来决定使用哪些代理。描述应说明代理的功能以及如何与其交互。

```python
abstract async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】从保存的状态恢复代理

```python
abstract property name: str#
```

【中文翻译】代理的名称。团队使用此名称来唯一标识代理。它在团队中应该是唯一的。

```python
abstract async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

```python
abstract on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回内部消息流，最终项是响应。

```python
abstract async on_pause(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理暂停时调用。调用此方法时，代理可能正在 `on_messages()` 或 `on_messages_stream()` 中运行。

```python
abstract async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
abstract async on_resume(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理从暂停中恢复时调用。调用此方法时，代理可能正在 `on_messages()` 或 `on_messages_stream()` 中运行。

```python
abstract property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
abstract async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理状态以供以后恢复

```python
pydantic model Handoff[source]#
```

【中文翻译】基类：BaseModel
移交配置。

显示 JSON 架构
```json
{
   "title": "Handoff",
   "description": "Handoff configuration.",
   "type": "object",
   "properties": {
      "target": {
         "title": "Target",
         "type": "string"
      },
      "description": {
         "default": "",
         "title": "Description",
         "type": "string"
      },
      "name": {
         "default": "",
         "title": "Name",
         "type": "string"
      },
      "message": {
         "default": "",
         "title": "Message",
         "type": "string"
      }
   },
   "required": [
      "target"
   ]
}
```

字段：

description (str)
message (str)
name (str)
target (str)

验证者：

set_defaults » 所有字段

```python
field description: str = ''#
```

【中文翻译】移交的描述，例如移交发生的条件以及目标代理的能力。
如果未提供，则从目标代理的名称生成。

验证者：

set_defaults

```python
field message: str = ''#
```

【中文翻译】给目标代理的消息。
默认情况下，它将是移交工具的结果。
如果未提供，则从目标代理的名称生成。

验证者：

set_defaults

```python
field name: str = ''#
```

【中文翻译】此移交配置的名称。如果未提供，则从目标代理的名称生成。

验证者：

set_defaults

```python
field target: str [Required]#
```

【中文翻译】要移交到的目标代理的名称。

验证者：

set_defaults

```python
validator set_defaults » all fields[source]#
```

```python
property handoff_tool: BaseTool[BaseModel, BaseModel]#
```

【中文翻译】从此移交配置创建移交工具。

```python
class OrTerminationCondition(*conditions: TerminationCondition)[source]#
```

【中文翻译】基类：TerminationCondition, Component[OrTerminationConditionConfig]

```python
component_config_schema#
```

【中文翻译】OrTerminationConditionConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.base.OrTerminationCondition'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_type: ClassVar[ComponentType] = 'termination'#
```

【中文翻译】组件的逻辑类型。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class Response(*, chat_message: BaseChatMessage, inner_messages: Sequence[BaseAgentEvent | BaseChatMessage] | None = None)[source]#
```

【中文翻译】基类：object
调用 `ChatAgent.on_messages()` 的响应。

```python
chat_message: BaseChatMessage#
```

【中文翻译】代理作为响应生成的聊天消息。

```python
inner_messages: Sequence[BaseAgentEvent | BaseChatMessage] | None = None#
```

【中文翻译】代理生成的内部消息，它们可以是 `BaseAgentEvent` 或 `BaseChatMessage`。

```python
pydantic model TaskResult[source]#
```

【中文翻译】基类：BaseModel
运行任务的结果。

显示 JSON 架构
```json
{
   "title": "TaskResult",
   "description": "Result of running a task.",
   "type": "object",
   "properties": {
      "messages": {
         "items": {
            "anyOf": [
               {
                  "$ref": "#/$defs/BaseAgentEvent"
               },
               {
                  "$ref": "#/$defs/BaseChatMessage"
               }
            ]
         },
         "title": "Messages",
         "type": "array"
      },
      "stop_reason": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Stop Reason"
      }
   },
   "$defs": {
      "BaseAgentEvent": {
         "description": "Base class for agent events.\n\n.. note::\n\n    If you want to create a new message type for signaling observable events\n    to user and application, inherit from this class.\n\nAgent events are used to signal actions and thoughts produced by agents\nand teams to user and applications. They are not used for agent-to-agent\ncommunication and are not expected to be processed by other agents.\n\nYou should override the :meth:`to_text` method if you want to provide\na custom rendering of the content.",
         "properties": {
            "source": {
               "title": "Source",
               "type": "string"
            },
            "models_usage": {
               "anyOf": [
                  {
                     "$ref": "#/$defs/RequestUsage"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null
            },
            "metadata": {
               "additionalProperties": {
                  "type": "string"
               },
               "default": {},
               "title": "Metadata",
               "type": "object"
            }
         },
         "required": [
            "source"
         ],
         "title": "BaseAgentEvent",
         "type": "object"
      },
      "BaseChatMessage": {
         "description": "Abstract base class for chat messages.\n\n.. note::\n\n    If you want to create a new message type that is used for agent-to-agent\n    communication, inherit from this class, or simply use\n    :class:`StructuredMessage` if your content type is a subclass of\n    Pydantic BaseModel.\n\nThis class is used for messages that are sent between agents in a chat\nconversation. Agents are expected to process the content of the\nmessage using models and return a response as another :class:`BaseChatMessage`.",
         "properties": {
            "source": {
               "title": "Source",
               "type": "string"
            },
            "models_usage": {
               "anyOf": [
                  {
                     "$ref": "#/$defs/RequestUsage"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null
            },
            "metadata": {
               "additionalProperties": {
                  "type": "string"
               },
               "default": {},
               "title": "Metadata",
               "type": "object"
            }
         },
         "required": [
            "source"
         ],
         "title": "BaseChatMessage",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "messages"
   ]
}
```

字段：

messages (Sequence[autogen_agentchat.messages.BaseAgentEvent | autogen_agentchat.messages.BaseChatMessage])
stop_reason (str | None)

```python
field messages: Sequence[BaseAgentEvent | BaseChatMessage] [Required]#
```

【中文翻译】任务生成的消息。

```python
field stop_reason: str | None = None#
```

【中文翻译】任务停止的原因。

```python
class TaskRunner(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol
任务运行器。

```python
async run(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → TaskResult[source]#
```

【中文翻译】运行任务并返回结果。
任务可以是字符串、单个消息或消息序列。
运行器是有状态的，对此方法的后续调用将从上一次调用停止的位置继续。如果未指定任务，运行器将继续当前任务。

```python
run_stream(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None][source]#
```

【中文翻译】运行任务并产生消息流，最终结果 `TaskResult` 作为流中的最后一项。
任务可以是字符串、单个消息或消息序列。
运行器是有状态的，对此方法的后续调用将从上一次调用停止的位置继续。如果未指定任务，运行器将继续当前任务。

```python
class Team(*args, **kwargs)[source]#
```

【中文翻译】基类：ABC, TaskRunner, ComponentBase[BaseModel]

```python
component_type: ClassVar[ComponentType] = 'team'#
```

【中文翻译】组件的逻辑类型。

```python
abstract async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载团队的状态。

```python
abstract async pause() → None[source]#
```

【中文翻译】暂停团队及其所有参与者。这对于并发暂停 `autogen_agentchat.base.TaskRunner.run()` 或 `autogen_agentchat.base.TaskRunner.run_stream()` 方法，同时保持它们活动非常有用。

```python
abstract async reset() → None[source]#
```

【中文翻译】将团队及其所有参与者重置为其初始状态。

```python
abstract async resume() → None[source]#
```

【中文翻译】在调用 `pause()` 后，从暂停中恢复团队及其所有参与者。

```python
abstract async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存团队的当前状态。

```python
exception TerminatedException[source]#
```

【中文翻译】基类：BaseException

```python
class TerminationCondition[source]#
```

【中文翻译】基类：ABC, ComponentBase[BaseModel]
一个有状态的条件，用于确定何时应终止对话。
终止条件是一个可调用对象，它接受自上次调用该条件以来的一系列 `BaseChatMessage` 对象，如果应终止对话，则返回 `StopMessage`，否则返回 None。
一旦达到终止条件，必须在再次使用之前将其重置。
可以使用 AND 和 OR 运算符组合终止条件。

示例
```python
import asyncio
from autogen_agentchat.conditions import MaxMessageTermination, TextMentionTermination


async def main() -> None:
    # 在 10 轮对话后或提及文本 "TERMINATE" 时终止对话。
    cond1 = MaxMessageTermination(10) | TextMentionTermination("TERMINATE")

    # 在 10 轮对话后并且提及文本 "TERMINATE" 时终止对话。
    cond2 = MaxMessageTermination(10) & TextMentionTermination("TERMINATE")

    # ...

    # 重置终止条件。
    await cond1.reset()
    await cond2.reset()


asyncio.run(main())
```

```python
component_type: ClassVar[ComponentType] = 'termination'#
```

【中文翻译】组件的逻辑类型。

```python
abstract async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
abstract property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

【中文翻译】上一页

【中文翻译】autogen_agentchat.teams

【中文翻译】下一页

【中文翻译】autogen_agentchat.conditions

### autogen_agentchat.base {autogen_agentchatbase}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.base.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.base.html)

```python
class AndTerminationCondition(*conditions: TerminationCondition)[source]#
```

【中文翻译】基类：TerminationCondition, Component[AndTerminationConditionConfig]

```python
component_config_schema#
```

【中文翻译】AndTerminationConditionConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.base.AndTerminationCondition'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_type: ClassVar[ComponentType] = 'termination'#
```

【中文翻译】组件的逻辑类型。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class ChatAgent(*args, **kwargs)[source]#
```

【中文翻译】基类：ABC, TaskRunner, ComponentBase[BaseModel]
聊天代理协议。

```python
abstract async close() → None[source]#
```

【中文翻译】释放代理持有的任何资源。

```python
component_type: ClassVar[ComponentType] = 'agent'#
```

【中文翻译】组件的逻辑类型。

```python
abstract property description: str#
```

【中文翻译】代理的描述。团队使用此描述来决定使用哪些代理。描述应说明代理的功能以及如何与其交互。

```python
abstract async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】从保存的状态恢复代理

```python
abstract property name: str#
```

【中文翻译】代理的名称。团队使用此名称来唯一标识代理。它在团队中应该是唯一的。

```python
abstract async on_messages(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → Response[source]#
```

【中文翻译】处理传入消息并返回响应。

```python
abstract on_messages_stream(messages: Sequence[BaseChatMessage], cancellation_token: CancellationToken) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None][source]#
```

【中文翻译】处理传入消息并返回内部消息流，最终项是响应。

```python
abstract async on_pause(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理暂停时调用。调用此方法时，代理可能正在 `on_messages()` 或 `on_messages_stream()` 中运行。

```python
abstract async on_reset(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】将代理重置为其初始化状态。

```python
abstract async on_resume(cancellation_token: CancellationToken) → None[source]#
```

【中文翻译】当代理从暂停中恢复时调用。调用此方法时，代理可能正在 `on_messages()` 或 `on_messages_stream()` 中运行。

```python
abstract property produced_message_types: Sequence[type[BaseChatMessage]]#
```

【中文翻译】代理在 `Response.chat_message` 字段中生成的消息类型。它们必须是 `BaseChatMessage` 类型。

```python
abstract async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理状态以供以后恢复

```python
pydantic model Handoff[source]#
```

【中文翻译】基类：BaseModel
移交配置。

显示 JSON 架构
```json
{
   "title": "Handoff",
   "description": "Handoff configuration.",
   "type": "object",
   "properties": {
      "target": {
         "title": "Target",
         "type": "string"
      },
      "description": {
         "default": "",
         "title": "Description",
         "type": "string"
      },
      "name": {
         "default": "",
         "title": "Name",
         "type": "string"
      },
      "message": {
         "default": "",
         "title": "Message",
         "type": "string"
      }
   },
   "required": [
      "target"
   ]
}
```

字段：

description (str)
message (str)
name (str)
target (str)

验证者：

set_defaults » 所有字段

```python
field description: str = ''#
```

【中文翻译】移交的描述，例如移交发生的条件以及目标代理的能力。
如果未提供，则从目标代理的名称生成。

验证者：

set_defaults

```python
field message: str = ''#
```

【中文翻译】给目标代理的消息。
默认情况下，它将是移交工具的结果。
如果未提供，则从目标代理的名称生成。

验证者：

set_defaults

```python
field name: str = ''#
```

【中文翻译】此移交配置的名称。如果未提供，则从目标代理的名称生成。

验证者：

set_defaults

```python
field target: str [Required]#
```

【中文翻译】要移交到的目标代理的名称。

验证者：

set_defaults

```python
validator set_defaults » all fields[source]#
```

```python
property handoff_tool: BaseTool[BaseModel, BaseModel]#
```

【中文翻译】从此移交配置创建移交工具。

```python
class OrTerminationCondition(*conditions: TerminationCondition)[source]#
```

【中文翻译】基类：TerminationCondition, Component[OrTerminationConditionConfig]

```python
component_config_schema#
```

【中文翻译】OrTerminationConditionConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.base.OrTerminationCondition'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_type: ClassVar[ComponentType] = 'termination'#
```

【中文翻译】组件的逻辑类型。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class Response(*, chat_message: BaseChatMessage, inner_messages: Sequence[BaseAgentEvent | BaseChatMessage] | None = None)[source]#
```

【中文翻译】基类：object
调用 `ChatAgent.on_messages()` 的响应。

```python
chat_message: BaseChatMessage#
```

【中文翻译】代理作为响应生成的聊天消息。

```python
inner_messages: Sequence[BaseAgentEvent | BaseChatMessage] | None = None#
```

【中文翻译】代理生成的内部消息，它们可以是 `BaseAgentEvent` 或 `BaseChatMessage`。

```python
pydantic model TaskResult[source]#
```

【中文翻译】基类：BaseModel
运行任务的结果。

显示 JSON 架构
```json
{
   "title": "TaskResult",
   "description": "Result of running a task.",
   "type": "object",
   "properties": {
      "messages": {
         "items": {
            "anyOf": [
               {
                  "$ref": "#/$defs/BaseAgentEvent"
               },
               {
                  "$ref": "#/$defs/BaseChatMessage"
               }
            ]
         },
         "title": "Messages",
         "type": "array"
      },
      "stop_reason": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Stop Reason"
      }
   },
   "$defs": {
      "BaseAgentEvent": {
         "description": "Base class for agent events.\n\n.. note::\n\n    If you want to create a new message type for signaling observable events\n    to user and application, inherit from this class.\n\nAgent events are used to signal actions and thoughts produced by agents\nand teams to user and applications. They are not used for agent-to-agent\ncommunication and are not expected to be processed by other agents.\n\nYou should override the :meth:`to_text` method if you want to provide\na custom rendering of the content.",
         "properties": {
            "source": {
               "title": "Source",
               "type": "string"
            },
            "models_usage": {
               "anyOf": [
                  {
                     "$ref": "#/$defs/RequestUsage"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null
            },
            "metadata": {
               "additionalProperties": {
                  "type": "string"
               },
               "default": {},
               "title": "Metadata",
               "type": "object"
            }
         },
         "required": [
            "source"
         ],
         "title": "BaseAgentEvent",
         "type": "object"
      },
      "BaseChatMessage": {
         "description": "Abstract base class for chat messages.\n\n.. note::\n\n    If you want to create a new message type that is used for agent-to-agent\n    communication, inherit from this class, or simply use\n    :class:`StructuredMessage` if your content type is a subclass of\n    Pydantic BaseModel.\n\nThis class is used for messages that are sent between agents in a chat\nconversation. Agents are expected to process the content of the\nmessage using models and return a response as another :class:`BaseChatMessage`.",
         "properties": {
            "source": {
               "title": "Source",
               "type": "string"
            },
            "models_usage": {
               "anyOf": [
                  {
                     "$ref": "#/$defs/RequestUsage"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null
            },
            "metadata": {
               "additionalProperties": {
                  "type": "string"
               },
               "default": {},
               "title": "Metadata",
               "type": "object"
            }
         },
         "required": [
            "source"
         ],
         "title": "BaseChatMessage",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "messages"
   ]
}
```

字段：

messages (Sequence[autogen_agentchat.messages.BaseAgentEvent | autogen_agentchat.messages.BaseChatMessage])
stop_reason (str | None)

```python
field messages: Sequence[BaseAgentEvent | BaseChatMessage] [Required]#
```

【中文翻译】任务生成的消息。

```python
field stop_reason: str | None = None#
```

【中文翻译】任务停止的原因。

```python
class TaskRunner(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol
任务运行器。

```python
async run(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → TaskResult[source]#
```

【中文翻译】运行任务并返回结果。
任务可以是字符串、单个消息或消息序列。
运行器是有状态的，对此方法的后续调用将从上一次调用停止的位置继续。如果未指定任务，运行器将继续当前任务。

```python
run_stream(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None][source]#
```

【中文翻译】运行任务并产生消息流，最终结果 `TaskResult` 作为流中的最后一项。
任务可以是字符串、单个消息或消息序列。
运行器是有状态的，对此方法的后续调用将从上一次调用停止的位置继续。如果未指定任务，运行器将继续当前任务。

```python
class Team(*args, **kwargs)[source]#
```

【中文翻译】基类：ABC, TaskRunner, ComponentBase[BaseModel]

```python
component_type: ClassVar[ComponentType] = 'team'#
```

【中文翻译】组件的逻辑类型。

```python
abstract async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载团队的状态。

```python
abstract async pause() → None[source]#
```

【中文翻译】暂停团队及其所有参与者。这对于并发暂停 `autogen_agentchat.base.TaskRunner.run()` 或 `autogen_agentchat.base.TaskRunner.run_stream()` 方法，同时保持它们活动非常有用。

```python
abstract async reset() → None[source]#
```

【中文翻译】将团队及其所有参与者重置为其初始状态。

```python
abstract async resume() → None[source]#
```

【中文翻译】在调用 `pause()` 后，从暂停中恢复团队及其所有参与者。

```python
abstract async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存团队的当前状态。

```python
exception TerminatedException[source]#
```

【中文翻译】基类：BaseException

```python
class TerminationCondition[source]#
```

【中文翻译】基类：ABC, ComponentBase[BaseModel]
一个有状态的条件，用于确定何时应终止对话。
终止条件是一个可调用对象，它接受自上次调用该条件以来的一系列 `BaseChatMessage` 对象，如果应终止对话，则返回 `StopMessage`，否则返回 None。
一旦达到终止条件，必须在再次使用之前将其重置。
可以使用 AND 和 OR 运算符组合终止条件。

示例
```python
import asyncio
from autogen_agentchat.conditions import MaxMessageTermination, TextMentionTermination


async def main() -> None:
    # 在 10 轮对话后或提及文本 "TERMINATE" 时终止对话。
    cond1 = MaxMessageTermination(10) | TextMentionTermination("TERMINATE")

    # 在 10 轮对话后并且提及文本 "TERMINATE" 时终止对话。
    cond2 = MaxMessageTermination(10) & TextMentionTermination("TERMINATE")

    # ...

    # 重置终止条件。
    await cond1.reset()
    await cond2.reset()


asyncio.run(main())
```

```python
component_type: ClassVar[ComponentType] = 'termination'#
```

【中文翻译】组件的逻辑类型。

```python
abstract async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
abstract property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

【中文翻译】上一页

【中文翻译】autogen_agentchat.teams

【中文翻译】下一页

【中文翻译】autogen_agentchat.conditions

### autogen_agentchat.conditions {autogen_agentchatconditions}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.conditions.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.conditions.html)

```python
class ExternalTermination[source]#
```

【中文翻译】基类：TerminationCondition, Component[ExternalTerminationConfig]
一个通过调用 `set()` 方法进行外部控制的终止条件。

示例：
```python
from autogen_agentchat.conditions import ExternalTermination

termination = ExternalTermination()

# 在 asyncio 任务中运行团队。
...

# 外部设置终止条件
termination.set()
```

```python
classmethod _from_config(config: ExternalTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → ExternalTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】ExternalTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.ExternalTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
set() → None[source]#
```

【中文翻译】将终止条件设置为已终止。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class FunctionCallTermination(function_name: str)[source]#
```

【中文翻译】基类：TerminationCondition, Component[FunctionCallTerminationConfig]
如果收到具有特定名称的 `FunctionExecutionResult`，则终止对话。

参数：
function_name (str) – 要在消息中查找的函数名称。

引发：
TerminatedException – 如果已达到终止条件。

```python
classmethod _from_config(config: FunctionCallTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → FunctionCallTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】FunctionCallTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.FunctionCallTermination'#
```

【中文翻译】组件配置的模式。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class FunctionalTermination(func: Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]])[source]#
```

【中文翻译】基类：TerminationCondition
如果满足函数表达式，则终止对话。

参数：
func (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]]) – 一个接受消息序列并返回 True（如果满足终止条件）或 False（否则）的函数。
该函数可以是可调用对象或异步可调用对象。

示例
```python
import asyncio
from typing import Sequence

from autogen_agentchat.conditions import FunctionalTermination
from autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage, StopMessage


def expression(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> bool:
    # 检查最后一条消息是否是停止消息
    return isinstance(messages[-1], StopMessage)


termination = FunctionalTermination(expression)


async def run() -> None:
    messages = [
        StopMessage(source="agent1", content="Stop"),
    ]
    result = await termination(messages)
    print(result)


asyncio.run(run())
```

```
StopMessage(source="FunctionalTermination", content="Functional termination condition met")
```

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class HandoffTermination(target: str)[source]#
```

【中文翻译】基类：TerminationCondition, Component[HandoffTerminationConfig]
如果收到具有给定目标的 `HandoffMessage`，则终止对话。

参数：
target (str) – 移交消息的目标。

```python
classmethod _from_config(config: HandoffTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → HandoffTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】HandoffTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.HandoffTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class MaxMessageTermination(max_messages: int, include_agent_event: bool = False)[source]#
```

【中文翻译】基类：TerminationCondition, Component[MaxMessageTerminationConfig]
在交换了最大数量的消息后终止对话。

参数：

max_messages – 对话中允许的最大消息数。
include_agent_event – 如果为 True，则在消息计数中包含 `BaseAgentEvent`。
否则，仅包含 `BaseChatMessage`。默认为 False。

```python
classmethod _from_config(config: MaxMessageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → MaxMessageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】MaxMessageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.MaxMessageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class SourceMatchTermination(sources: List[str])[source]#
```

【中文翻译】基类：TerminationCondition, Component[SourceMatchTerminationConfig]
在特定来源响应后终止对话。

参数：
sources (List[str]) – 用于终止对话的来源名称列表。

引发：
TerminatedException – 如果已达到终止条件。

```python
classmethod _from_config(config: SourceMatchTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → SourceMatchTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】SourceMatchTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.SourceMatchTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class StopMessageTermination[source]#
```

【中文翻译】基类：TerminationCondition, Component[StopMessageTerminationConfig]
如果收到 `StopMessage`，则终止对话。

```python
classmethod _from_config(config: StopMessageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → StopMessageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】StopMessageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.StopMessageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TextMentionTermination(text: str, sources: Sequence[str] | None = None)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TextMentionTerminationConfig]
如果提及特定文本，则终止对话。

参数：

text – 要在消息中查找的文本。
sources – 仅检查指定代理的消息以查找要查找的文本。

```python
classmethod _from_config(config: TextMentionTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TextMentionTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TextMentionTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMentionTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TextMessageTermination(source: str | None = None)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TextMessageTerminationConfig]
如果收到 `TextMessage`，则终止对话。
此终止条件检查消息序列中的 `TextMessage` 实例。当找到 `TextMessage` 时，
如果满足以下任一条件，它将终止对话：
- 未指定来源（在任何 `TextMessage` 上终止）
- 消息来源与指定的来源匹配

参数：
source (str | None, 可选) – 要与传入消息匹配的来源名称。如果为 None，则匹配任何来源。
默认为 None。

```python
classmethod _from_config(config: TextMessageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TextMessageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TextMessageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMessageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TimeoutTermination(timeout_seconds: float)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TimeoutTerminationConfig]
在指定持续时间过去后终止对话。

参数：
timeout_seconds – 终止对话前的最大持续时间（以秒为单位）。

```python
classmethod _from_config(config: TimeoutTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TimeoutTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TimeoutTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TimeoutTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TokenUsageTermination(max_total_token: int | None = None, max_prompt_token: int | None = None, max_completion_token: int | None = None)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TokenUsageTerminationConfig]
如果达到令牌使用限制，则终止对话。

参数：

max_total_token – 对话中允许的最大总令牌数。
max_prompt_token – 对话中允许的最大提示令牌数。
max_completion_token – 对话中允许的最大完成令牌数。

引发：
ValueError – 如果未提供 `max_total_token`、`max_prompt_token` 或 `max_completion_token` 中的任何一个。

```python
classmethod _from_config(config: TokenUsageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TokenUsageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TokenUsageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TokenUsageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

【中文翻译】此模块提供了各种终止条件，用于控制多代理团队的行为。

【中文翻译】上一页

【中文翻译】autogen_agentchat.base

【中文翻译】下一页

【中文翻译】autogen_agentchat.ui

### autogen_agentchat.conditions {autogen_agentchatconditions}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.conditions.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.conditions.html)

```python
class ExternalTermination[source]#
```

【中文翻译】基类：TerminationCondition, Component[ExternalTerminationConfig]
一个通过调用 `set()` 方法进行外部控制的终止条件。

示例：
```python
from autogen_agentchat.conditions import ExternalTermination

termination = ExternalTermination()

# 在 asyncio 任务中运行团队。
...

# 外部设置终止条件
termination.set()
```

```python
classmethod _from_config(config: ExternalTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → ExternalTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】ExternalTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.ExternalTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
set() → None[source]#
```

【中文翻译】将终止条件设置为已终止。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class FunctionCallTermination(function_name: str)[source]#
```

【中文翻译】基类：TerminationCondition, Component[FunctionCallTerminationConfig]
如果收到具有特定名称的 `FunctionExecutionResult`，则终止对话。

参数：
function_name (str) – 要在消息中查找的函数名称。

引发：
TerminatedException – 如果已达到终止条件。

```python
classmethod _from_config(config: FunctionCallTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → FunctionCallTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】FunctionCallTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.FunctionCallTermination'#
```

【中文翻译】组件配置的模式。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class FunctionalTermination(func: Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]])[source]#
```

【中文翻译】基类：TerminationCondition
如果满足函数表达式，则终止对话。

参数：
func (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]]) – 一个接受消息序列并返回 True（如果满足终止条件）或 False（否则）的函数。
该函数可以是可调用对象或异步可调用对象。

示例
```python
import asyncio
from typing import Sequence

from autogen_agentchat.conditions import FunctionalTermination
from autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage, StopMessage


def expression(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> bool:
    # 检查最后一条消息是否是停止消息
    return isinstance(messages[-1], StopMessage)


termination = FunctionalTermination(expression)


async def run() -> None:
    messages = [
        StopMessage(source="agent1", content="Stop"),
    ]
    result = await termination(messages)
    print(result)


asyncio.run(run())
```

```
StopMessage(source="FunctionalTermination", content="Functional termination condition met")
```

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class HandoffTermination(target: str)[source]#
```

【中文翻译】基类：TerminationCondition, Component[HandoffTerminationConfig]
如果收到具有给定目标的 `HandoffMessage`，则终止对话。

参数：
target (str) – 移交消息的目标。

```python
classmethod _from_config(config: HandoffTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → HandoffTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】HandoffTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.HandoffTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class MaxMessageTermination(max_messages: int, include_agent_event: bool = False)[source]#
```

【中文翻译】基类：TerminationCondition, Component[MaxMessageTerminationConfig]
在交换了最大数量的消息后终止对话。

参数：

max_messages – 对话中允许的最大消息数。
include_agent_event – 如果为 True，则在消息计数中包含 `BaseAgentEvent`。
否则，仅包含 `BaseChatMessage`。默认为 False。

```python
classmethod _from_config(config: MaxMessageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → MaxMessageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】MaxMessageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.MaxMessageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class SourceMatchTermination(sources: List[str])[source]#
```

【中文翻译】基类：TerminationCondition, Component[SourceMatchTerminationConfig]
在特定来源响应后终止对话。

参数：
sources (List[str]) – 用于终止对话的来源名称列表。

引发：
TerminatedException – 如果已达到终止条件。

```python
classmethod _from_config(config: SourceMatchTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → SourceMatchTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】SourceMatchTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.SourceMatchTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class StopMessageTermination[source]#
```

【中文翻译】基类：TerminationCondition, Component[StopMessageTerminationConfig]
如果收到 `StopMessage`，则终止对话。

```python
classmethod _from_config(config: StopMessageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → StopMessageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】StopMessageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.StopMessageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TextMentionTermination(text: str, sources: Sequence[str] | None = None)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TextMentionTerminationConfig]
如果提及特定文本，则终止对话。

参数：

text – 要在消息中查找的文本。
sources – 仅检查指定代理的消息以查找要查找的文本。

```python
classmethod _from_config(config: TextMentionTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TextMentionTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TextMentionTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMentionTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TextMessageTermination(source: str | None = None)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TextMessageTerminationConfig]
如果收到 `TextMessage`，则终止对话。
此终止条件检查消息序列中的 `TextMessage` 实例。当找到 `TextMessage` 时，
如果满足以下任一条件，它将终止对话：
- 未指定来源（在任何 `TextMessage` 上终止）
- 消息来源与指定的来源匹配

参数：
source (str | None, 可选) – 要与传入消息匹配的来源名称。如果为 None，则匹配任何来源。
默认为 None。

```python
classmethod _from_config(config: TextMessageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TextMessageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TextMessageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TextMessageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TimeoutTermination(timeout_seconds: float)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TimeoutTerminationConfig]
在指定持续时间过去后终止对话。

参数：
timeout_seconds – 终止对话前的最大持续时间（以秒为单位）。

```python
classmethod _from_config(config: TimeoutTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TimeoutTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TimeoutTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TimeoutTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

```python
class TokenUsageTermination(max_total_token: int | None = None, max_prompt_token: int | None = None, max_completion_token: int | None = None)[source]#
```

【中文翻译】基类：TerminationCondition, Component[TokenUsageTerminationConfig]
如果达到令牌使用限制，则终止对话。

参数：

max_total_token – 对话中允许的最大总令牌数。
max_prompt_token – 对话中允许的最大提示令牌数。
max_completion_token – 对话中允许的最大完成令牌数。

引发：
ValueError – 如果未提供 `max_total_token`、`max_prompt_token` 或 `max_completion_token` 中的任何一个。

```python
classmethod _from_config(config: TokenUsageTerminationConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TokenUsageTerminationConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TokenUsageTerminationConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.conditions.TokenUsageTermination'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
async reset() → None[source]#
```

【中文翻译】重置终止条件。

```python
property terminated: bool#
```

【中文翻译】检查终止条件是否已达到

【中文翻译】此模块提供了各种终止条件，用于控制多代理团队的行为。

【中文翻译】上一页

【中文翻译】autogen_agentchat.base

【中文翻译】下一页

【中文翻译】autogen_agentchat.ui

### autogen_agentchat.messages {autogen_agentchatmessages}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.messages.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.messages.html)

```python
AgentEvent#
```

【中文翻译】所有 `BaseAgentEvent` 内建具体子类的联合类型。
Annotated[ToolCallRequestEvent | ToolCallExecutionEvent | MemoryQueryEvent | UserInputRequestedEvent | ModelClientStreamingChunkEvent | ThoughtEvent | SelectSpeakerEvent | CodeGenerationEvent | CodeExecutionEvent, FieldInfo(annotation=NoneType, required=True, discriminator=’type’)] 的别名

```python
pydantic model BaseAgentEvent[source]#
```

【中文翻译】基类：BaseMessage, ABC
代理事件的基类。

注意
如果要创建用于向用户和应用程序发出可观察事件信号的新消息类型，请从此类继承。

代理事件用于向用户和应用程序发出代理和团队产生的操作和想法的信号。它们不用于代理之间的通信，也不期望被其他代理处理。
如果要提供内容的自定义呈现，则应覆盖 `to_text()` 方法。

显示 JSON 架构
```json
{
   "title": "BaseAgentEvent",
   "description": "Base class for agent events.\n\n.. note::\n\n    If you want to create a new message type for signaling observable events\n    to user and application, inherit from this class.\n\nAgent events are used to signal actions and thoughts produced by agents\nand teams to user and applications. They are not used for agent-to-agent\ncommunication and are not expected to be processed by other agents.\n\nYou should override the :meth:`to_text` method if you want to provide\na custom rendering of the content.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source"
   ]
}
```

字段：

metadata (Dict[str, str])
models_usage (autogen_core.models._types.RequestUsage | None)
source (str)

```python
field metadata: Dict[str, str] = {}#
```

【中文翻译】有关消息的其他元数据。

```python
field models_usage: RequestUsage | None = None#
```

【中文翻译】生成此消息时产生的模型客户端使用情况。

```python
field source: str [Required]#
```

【中文翻译】发送此消息的代理的名称。

```python
pydantic model BaseChatMessage[source]#
```

【中文翻译】基类：BaseMessage, ABC
聊天消息的抽象基类。

注意
如果要创建用于代理之间通信的新消息类型，请从此类继承，或者如果您的内容类型是 Pydantic BaseModel 的子类，则只需使用 `StructuredMessage`。

此类用于在聊天对话中在代理之间发送的消息。代理应使用模型处理消息内容，并以另一个 `BaseChatMessage` 的形式返回响应。

显示 JSON 架构
```json
{
   "title": "BaseChatMessage",
   "description": "Abstract base class for chat messages.\n\n.. note::\n\n    If you want to create a new message type that is used for agent-to-agent\n    communication, inherit from this class, or simply use\n    :class:`StructuredMessage` if your content type is a subclass of\n    Pydantic BaseModel.\n\nThis class is used for messages that are sent between agents in a chat\nconversation. Agents are expected to process the content of the\nmessage using models and return a response as another :class:`BaseChatMessage`.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source"
   ]
}
```

字段：

metadata (Dict[str, str])
models_usage (autogen_core.models._types.RequestUsage | None)
source (str)

```python
field metadata: Dict[str, str] = {}#
```

【中文翻译】有关消息的其他元数据。

```python
field models_usage: RequestUsage | None = None#
```

【中文翻译】生成此消息时产生的模型客户端使用情况。

```python
field source: str [Required]#
```

【中文翻译】发送此消息的代理的名称。

```python
abstract to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
abstract to_model_text() → str[source]#
```

【中文翻译】将消息内容转换为纯文本表示形式。
这用于为模型创建纯文本内容。
这不用于在控制台中呈现消息。为此，请使用 `to_text()`。
此方法与 `to_model_message()` 的区别在于，此方法用于构造模型客户端消息的各个部分，而 `to_model_message()` 用于为模型客户端创建完整的消息。

```python
pydantic model BaseMessage[source]#
```

【中文翻译】基类：BaseModel, ABC
AgentChat 中所有消息类型的抽象基类。

警告
如果要创建新的消息类型，请不要从此类继承。
相反，请从 `BaseChatMessage` 或 `BaseAgentEvent` 继承以阐明消息类型的用途。

显示 JSON 架构
```json
{
   "title": "BaseMessage",
   "description": "Abstract base class for all message types in AgentChat.\n\n.. warning::\n\n    If you want to create a new message type, do not inherit from this class.\n    Instead, inherit from :class:`BaseChatMessage` or :class:`BaseAgentEvent`\n    to clarify the purpose of the message type.",
   "type": "object",
   "properties": {}
}
```

```python
dump() → Mapping[str, Any][source]#
```

【中文翻译】将消息转换为可 JSON 序列化的字典。
默认实现使用 Pydantic 模型的 `model_dump()` 方法将消息转换为字典。
如果要自定义序列化过程或向输出添加其他字段，请覆盖此方法。

```python
classmethod load(data: Mapping[str, Any]) → Self[source]#
```

【中文翻译】从可 JSON 序列化的数据字典创建消息。
默认实现使用 Pydantic 模型的 `model_validate()` 方法从数据创建消息。
如果要自定义反序列化过程或向输入数据添加其他字段，请覆盖此方法。

```python
abstract to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model BaseTextChatMessage[source]#
```

【中文翻译】基类：BaseChatMessage, ABC
所有纯文本 `BaseChatMessage` 类型的基类。
它具有 `to_text()`、`to_model_text()` 和 `to_model_message()` 方法的实现。
如果您的消息内容类型是字符串，请从此类继承。

显示 JSON 架构
```json
{
   "title": "BaseTextChatMessage",
   "description": "Base class for all text-only :class:`BaseChatMessage` types.\nIt has implementations for :meth:`to_text`, :meth:`to_model_text`,\nand :meth:`to_model_message` methods.\n\nInherit from this class if your message content type is a string.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (str)

```python
field content: str [Required]#
```

【中文翻译】消息的内容。

```python
to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
to_model_text() → str[source]#
```

【中文翻译】将消息内容转换为纯文本表示形式。
这用于为模型创建纯文本内容。
这不用于在控制台中呈现消息。为此，请使用 `to_text()`。
此方法与 `to_model_message()` 的区别在于，此方法用于构造模型客户端消息的各个部分，而 `to_model_message()` 用于为模型客户端创建完整的消息。

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
ChatMessage#
```

【中文翻译】所有 `BaseChatMessage` 内建具体子类的联合类型。
它不包括 `StructuredMessage` 类型。
Annotated[TextMessage | MultiModalMessage | StopMessage | ToolCallSummaryMessage | HandoffMessage, FieldInfo(annotation=NoneType, required=True, discriminator=’type’)] 的别名

```python
pydantic model CodeExecutionEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示代码执行事件的事件。

显示 JSON 架构
```json
{
   "title": "CodeExecutionEvent",
   "description": "An event signaling code execution event.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "retry_attempt": {
         "title": "Retry Attempt",
         "type": "integer"
      },
      "result": {
         "$ref": "#/$defs/CodeResult"
      },
      "type": {
         "const": "CodeExecutionEvent",
         "default": "CodeExecutionEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "CodeResult": {
         "properties": {
            "exit_code": {
               "title": "Exit Code",
               "type": "integer"
            },
            "output": {
               "title": "Output",
               "type": "string"
            }
         },
         "required": [
            "exit_code",
            "output"
         ],
         "title": "CodeResult",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "retry_attempt",
      "result"
   ]
}
```

字段：

result (autogen_core.code_executor._base.CodeResult)
retry_attempt (int)
type (Literal['CodeExecutionEvent'])

```python
field result: CodeResult [Required]#
```

【中文翻译】代码执行结果

```python
field retry_attempt: int [Required]#
```

【中文翻译】重试次数，0 表示首次执行

```python
field type: Literal['CodeExecutionEvent'] = 'CodeExecutionEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model CodeGenerationEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示代码生成事件的事件。

显示 JSON 架构
```json
{
   "title": "CodeGenerationEvent",
   "description": "An event signaling code generation event.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "retry_attempt": {
         "title": "Retry Attempt",
         "type": "integer"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "code_blocks": {
         "items": {
            "$ref": "#/$defs/CodeBlock"
         },
         "title": "Code Blocks",
         "type": "array"
      },
      "type": {
         "const": "CodeGenerationEvent",
         "default": "CodeGenerationEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "CodeBlock": {
         "properties": {
            "code": {
               "title": "Code",
               "type": "string"
            },
            "language": {
               "title": "Language",
               "type": "string"
            }
         },
         "required": [
            "code",
            "language"
         ],
         "title": "CodeBlock",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "retry_attempt",
      "content",
      "code_blocks"
   ]
}
```

字段：

code_blocks (List[autogen_core.code_executor._base.CodeBlock])
content (str)
retry_attempt (int)
type (Literal['CodeGenerationEvent'])

```python
field code_blocks: List[CodeBlock] [Required]#
```

【中文翻译】内容中存在的代码块列表

```python
field content: str [Required]#
```

【中文翻译】作为字符串的完整内容。

```python
field retry_attempt: int [Required]#
```

【中文翻译】重试次数，0 表示首次生成

```python
field type: Literal['CodeGenerationEvent'] = 'CodeGenerationEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model HandoffMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
请求将对话移交给另一个代理的消息。

显示 JSON 架构
```json
{
   "title": "HandoffMessage",
   "description": "A message requesting handoff of a conversation to another agent.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "target": {
         "title": "Target",
         "type": "string"
      },
      "context": {
         "default": [],
         "items": {
            "discriminator": {
               "mapping": {
                  "AssistantMessage": "#/$defs/AssistantMessage",
                  "FunctionExecutionResultMessage": "#/$defs/FunctionExecutionResultMessage",
                  "SystemMessage": "#/$defs/SystemMessage",
                  "UserMessage": "#/$defs/UserMessage"
               },
               "propertyName": "type"
            },
            "oneOf": [
               {
                  "$ref": "#/$defs/SystemMessage"
               },
               {
                  "$ref": "#/$defs/UserMessage"
               },
               {
                  "$ref": "#/$defs/AssistantMessage"
               },
               {
                  "$ref": "#/$defs/FunctionExecutionResultMessage"
               }
            ]
         },
         "title": "Context",
         "type": "array"
      },
      "type": {
         "const": "HandoffMessage",
         "default": "HandoffMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "AssistantMessage": {
         "description": "Assistant message are sampled from the language model.",
         "properties": {
            "content": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "items": {
                        "$ref": "#/$defs/FunctionCall"
                     },
                     "type": "array"
                  }
               ],
               "title": "Content"
            },
            "thought": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Thought"
            },
            "source": {
               "title": "Source",
               "type": "string"
            },
            "type": {
               "const": "AssistantMessage",
               "default": "AssistantMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content",
            "source"
         ],
         "title": "AssistantMessage",
         "type": "object"
      },
      "FunctionCall": {
         "properties": {
            "id": {
               "title": "Id",
               "type": "string"
            },
            "arguments": {
               "title": "Arguments",
               "type": "string"
            },
            "name": {
               "title": "Name",
               "type": "string"
            }
         },
         "required": [
            "id",
            "arguments",
            "name"
         ],
         "title": "FunctionCall",
         "type": "object"
      },
      "FunctionExecutionResult": {
         "description": "Function execution result contains the output of a function call.",
         "properties": {
            "content": {
               "title": "Content",
               "type": "string"
            },
            "name": {
               "title": "Name",
               "type": "string"
            },
            "call_id": {
               "title": "Call Id",
               "type": "string"
            },
            "is_error": {
               "anyOf": [
                  {
                     "type": "boolean"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Is Error"
            }
         },
         "required": [
            "content",
            "name",
            "call_id"
         ],
         "title": "FunctionExecutionResult",
         "type": "object"
      },
      "FunctionExecutionResultMessage": {
         "description": "Function execution result message contains the output of multiple function calls.",
         "properties": {
            "content": {
               "items": {
                  "$ref": "#/$defs/FunctionExecutionResult"
               },
               "title": "Content",
               "type": "array"
            },
            "type": {
               "const": "FunctionExecutionResultMessage",
               "default": "FunctionExecutionResultMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content"
         ],
         "title": "FunctionExecutionResultMessage",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      },
      "SystemMessage": {
         "description": "System message contains instructions for the model coming from the developer.\n\n.. note::\n\n    Open AI is moving away from using 'system' role in favor of 'developer' role.\n    See `Model Spec <https://cdn.openai.com/spec/model-spec-2024-05-08.html#definitions>`_ for more details.\n    However, the 'system' role is still allowed in their API and will be automatically converted to 'developer' role\n    on the server side.\n    So, you can use `SystemMessage` for developer messages.",
         "properties": {
            "content": {
               "title": "Content",
               "type": "string"
            },
            "type": {
               "const": "SystemMessage",
               "default": "SystemMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content"
         ],
         "title": "SystemMessage",
         "type": "object"
      },
      "UserMessage": {
         "description": "User message contains input from end users, or a catch-all for data provided to the model.",
         "properties": {
            "content": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "items": {
                        "anyOf": [
                           {
                              "type": "string"
                           },
                           {}
                        ]
                     },
                     "type": "array"
                  }
               ],
               "title": "Content"
            },
            "source": {
               "title": "Source",
               "type": "string"
            },
            "type": {
               "const": "UserMessage",
               "default": "UserMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content",
            "source"
         ],
         "title": "UserMessage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content",
      "target"
   ]
}
```

字段：

context (List[Annotated[autogen_core.models._types.SystemMessage | autogen_core.models._types.UserMessage | autogen_core.models._types.AssistantMessage | autogen_core.models._types.FunctionExecutionResultMessage, FieldInfo(annotation=NoneType, required=True, discriminator='type')]])
target (str)
type (Literal['HandoffMessage'])

```python
field context: List[Annotated[SystemMessage | UserMessage | AssistantMessage | FunctionExecutionResultMessage, FieldInfo(annotation=NoneType, required=True, discriminator='type')]] = []#
```

【中文翻译】要传递给目标代理的模型上下文。

```python
field target: str [Required]#
```

【中文翻译】要移交到的目标代理的名称。

```python
field type: Literal['HandoffMessage'] = 'HandoffMessage'#
```

```python
pydantic model MemoryQueryEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示内存查询结果的事件。

显示 JSON 架构
```json
{
   "title": "MemoryQueryEvent",
   "description": "An event signaling the results of memory queries.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "$ref": "#/$defs/MemoryContent"
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "MemoryQueryEvent",
         "default": "MemoryQueryEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "MemoryContent": {
         "description": "A memory content item.",
         "properties": {
            "content": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "format": "binary",
                     "type": "string"
                  },
                  {
                     "type": "object"
                  },
                  {}
               ],
               "title": "Content"
            },
            "mime_type": {
               "anyOf": [
                  {
                     "$ref": "#/$defs/MemoryMimeType"
                  },
                  {
                     "type": "string"
                  }
               ],
               "title": "Mime Type"
            },
            "metadata": {
               "anyOf": [
                  {
                     "type": "object"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Metadata"
            }
         },
         "required": [
            "content",
            "mime_type"
         ],
         "title": "MemoryContent",
         "type": "object"
      },
      "MemoryMimeType": {
         "description": "Supported MIME types for memory content.",
         "enum": [
            "text/plain",
            "application/json",
            "text/markdown",
            "image/*",
            "application/octet-stream"
         ],
         "title": "MemoryMimeType",
         "type": "string"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[autogen_core.memory._base_memory.MemoryContent])
type (Literal['MemoryQueryEvent'])

```python
field content: List[MemoryContent] [Required]#
```

【中文翻译】内存查询结果。

```python
field type: Literal['MemoryQueryEvent'] = 'MemoryQueryEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ModelClientStreamingChunkEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示模型客户端在流式模式下输出的文本块的事件。

显示 JSON 架构
```json
{
   "title": "ModelClientStreamingChunkEvent",
   "description": "An event signaling a text output chunk from a model client in streaming mode.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "ModelClientStreamingChunkEvent",
         "default": "ModelClientStreamingChunkEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (str)
type (Literal['ModelClientStreamingChunkEvent'])

```python
field content: str [Required]#
```

【中文翻译】模型客户端的字符串块。

```python
field type: Literal['ModelClientStreamingChunkEvent'] = 'ModelClientStreamingChunkEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model MultiModalMessage[source]#
```

【中文翻译】基类：BaseChatMessage
多模态消息。

显示 JSON 架构
```json
{
   "title": "MultiModalMessage",
   "description": "A multimodal message.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "anyOf": [
               {
                  "type": "string"
               },
               {}
            ]
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "MultiModalMessage",
         "default": "MultiModalMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[str | autogen_core._image.Image])
type (Literal['MultiModalMessage'])

```python
field content: List[str | Image] [Required]#
```

【中文翻译】消息的内容。

```python
field type: Literal['MultiModalMessage'] = 'MultiModalMessage'#
```

```python
to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
to_model_text(image_placeholder: str | None = '[image]') → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式。
如果存在图像，默认情况下它将被图像占位符替换，否则在设置为 None 时它将是 base64 字符串。

```python
to_text(iterm: bool = False) → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model SelectSpeakerEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示对话发言人选择的事件。

显示 JSON 架构
```json
{
   "title": "SelectSpeakerEvent",
   "description": "An event signaling the selection of speakers for a conversation.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "type": "string"
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "SelectSpeakerEvent",
         "default": "SelectSpeakerEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[str])
type (Literal['SelectSpeakerEvent'])

```python
field content: List[str] [Required]#
```

【中文翻译】所选发言人的姓名。

```python
field type: Literal['SelectSpeakerEvent'] = 'SelectSpeakerEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model StopMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
请求停止对话的消息。

显示 JSON 架构
```json
{
   "title": "StopMessage",
   "description": "A message requesting stop of a conversation.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "StopMessage",
         "default": "StopMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

type (Literal['StopMessage'])

```python
field type: Literal['StopMessage'] = 'StopMessage'#
```

```python
class StructuredContentType#
```

【中文翻译】结构化内容类型的类型变量。
TypeVar(‘StructuredContentType’, bound=BaseModel, covariant=True) 的别名

```python
pydantic model StructuredMessage[source]#
```

【中文翻译】基类：BaseChatMessage, Generic[StructuredContentType]
具有未指定内容类型的 `BaseChatMessage` 类型。
要创建新的结构化消息类型，请将内容类型指定为 Pydantic BaseModel 的子类。
```python
from pydantic import BaseModel
from autogen_agentchat.messages import StructuredMessage


class MyMessageContent(BaseModel):
    text: str
    number: int


message = StructuredMessage[MyMessageContent](
    content=MyMessageContent(text="Hello", number=42),
    source="agent1",
)

print(message.to_text())  # {"text": "Hello", "number": 42}
```

```python
from pydantic import BaseModel
from autogen_agentchat.messages import StructuredMessage


class MyMessageContent(BaseModel):
    text: str
    number: int


message = StructuredMessage[MyMessageContent](
    content=MyMessageContent(text="Hello", number=42),
    source="agent",
    format_string="Hello, {text} {number}!",
)

print(message.to_text())  # Hello, agent 42!
```

显示 JSON 架构
```json
{
   "title": "StructuredMessage",
   "description": "A :class:`BaseChatMessage` type with an unspecified content type.\n\nTo create a new structured message type, specify the content type\nas a subclass of `Pydantic BaseModel <https://docs.pydantic.dev/latest/concepts/models/>`_.\n\n.. code-block:: python\n\n    from pydantic import BaseModel\n    from autogen_agentchat.messages import StructuredMessage\n\n\n    class MyMessageContent(BaseModel):\n        text: str\n        number: int\n\n\n    message = StructuredMessage[MyMessageContent](\n        content=MyMessageContent(text=\"Hello\", number=42),\n        source=\"agent1\",\n    )\n\n    print(message.to_text())  # {\"text\": \"Hello\", \"number\": 42}\n\n.. code-block:: python\n\n    from pydantic import BaseModel\n    from autogen_agentchat.messages import StructuredMessage\n\n\n    class MyMessageContent(BaseModel):\n        text: str\n        number: int\n\n\n    message = StructuredMessage[MyMessageContent](\n        content=MyMessageContent(text=\"Hello\", number=42),\n        source=\"agent\",\n        format_string=\"Hello, {text} {number}!\",\n    )\n\n    print(message.to_text())  # Hello, agent 42!",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "$ref": "#/$defs/BaseModel"
      },
      "format_string": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Format String"
      }
   },
   "$defs": {
      "BaseModel": {
         "properties": {},
         "title": "BaseModel",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (autogen_agentchat.messages.StructuredContentType)
format_string (str | None)

```python
field content: StructuredContentType [Required]#
```

【中文翻译】消息的内容。必须是 Pydantic BaseModel 的子类。

```python
field format_string: str | None = None#
```

【中文翻译】（实验性）一个可选的格式字符串，用于将内容呈现为人类可读的格式。
格式字符串可以使用内容模型的字段作为占位符。
例如，如果内容模型有一个字段 `name`，您可以在格式字符串中使用 `{name}` 来包含该字段的值。
格式字符串在 `to_text()` 方法中使用，以创建消息的人类可读表示形式。
此设置是实验性的，将来会更改。

```python
to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
to_model_text() → str[source]#
```

【中文翻译】将消息内容转换为纯文本表示形式。
这用于为模型创建纯文本内容。
这不用于在控制台中呈现消息。为此，请使用 `to_text()`。
此方法与 `to_model_message()` 的区别在于，此方法用于构造模型客户端消息的各个部分，而 `to_model_message()` 用于为模型客户端创建完整的消息。

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
property type: str#
```

```python
pydantic model TextMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
具有纯字符串内容的文本消息。

显示 JSON 架构
```json
{
   "title": "TextMessage",
   "description": "A text message with string-only content.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "TextMessage",
         "default": "TextMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

type (Literal['TextMessage'])

```python
field type: Literal['TextMessage'] = 'TextMessage'#
```

```python
pydantic model ThoughtEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示模型思考过程的事件。
它用于传达推理模型生成的推理令牌，或函数调用生成的额外文本内容。

显示 JSON 架构
```json
{
   "title": "ThoughtEvent",
   "description": "An event signaling the thought process of a model.\nIt is used to communicate the reasoning tokens generated by a reasoning model,\nor the extra text content generated by a function call.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "ThoughtEvent",
         "default": "ThoughtEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (str)
type (Literal['ThoughtEvent'])

```python
field content: str [Required]#
```

【中文翻译】模型的思考过程。

```python
field type: Literal['ThoughtEvent'] = 'ThoughtEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ToolCallExecutionEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示工具调用执行的事件。

显示 JSON 架构
```json
{
   "title": "ToolCallExecutionEvent",
   "description": "An event signaling the execution of tool calls.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "$ref": "#/$defs/FunctionExecutionResult"
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "ToolCallExecutionEvent",
         "default": "ToolCallExecutionEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "FunctionExecutionResult": {
         "description": "Function execution result contains the output of a function call.",
         "properties": {
            "content": {
               "title": "Content",
               "type": "string"
            },
            "name": {
               "title": "Name",
               "type": "string"
            },
            "call_id": {
               "title": "Call Id",
               "type": "string"
            },
            "is_error": {
               "anyOf": [
                  {
                     "type": "boolean"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Is Error"
            }
         },
         "required": [
            "content",
            "name",
            "call_id"
         ],
         "title": "FunctionExecutionResult",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[autogen_core.models._types.FunctionExecutionResult])
type (Literal['ToolCallExecutionEvent'])

```python
field content: List[FunctionExecutionResult] [Required]#
```

【中文翻译】工具调用结果。

```python
field type: Literal['ToolCallExecutionEvent'] = 'ToolCallExecutionEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ToolCallRequestEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示请求使用工具的事件。

显示 JSON 架构
```json
{
   "title": "ToolCallRequestEvent",
   "description": "An event signaling a request to use tools.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "$
			
			```python
field content: List[FunctionCall] [Required]#
```

【中文翻译】工具调用。

```python
field type: Literal['ToolCallRequestEvent'] = 'ToolCallRequestEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ToolCallSummaryMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
一个表示工具调用结果摘要的消息。

显示 JSON 架构
```json
{
   "title": "ToolCallSummaryMessage",
   "description": "A message signaling the summary of tool call results.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "ToolCallSummaryMessage",
         "default": "ToolCallSummaryMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

type (Literal['ToolCallSummaryMessage'])

```python
field type: Literal['ToolCallSummaryMessage'] = 'ToolCallSummaryMessage'#
```

```python
pydantic model UserInputRequestedEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示用户代理已请求用户输入的事件。在调用输入回调之前发布。

显示 JSON 架构
```json
{
   "title": "UserInputRequestedEvent",
   "description": "An event signaling a that the user proxy has requested user input. Published prior to invoking the input callback.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "request_id": {
         "title": "Request Id",
         "type": "string"
      },
      "content": {
         "const": "",
         "default": "",
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "UserInputRequestedEvent",
         "default": "UserInputRequestedEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "request_id"
   ]
}
```

字段：

content (Literal[''])
request_id (str)
type (Literal['UserInputRequestedEvent'])

```python
field content: Literal[''] = ''#
```

【中文翻译】空内容，用于与期望有 content 字段的消费者兼容。

```python
field request_id: str [Required]#
```

【中文翻译】用户输入请求的标识符。

```python
field type: Literal['UserInputRequestedEvent'] = 'UserInputRequestedEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

【中文翻译】此模块定义了用于代理之间通信的各种消息类型。
每种消息类型都从 `BaseChatMessage` 类或 `BaseAgentEvent` 类继承，并包含与所发送消息类型相关的特定字段。

【中文翻译】上一页

【中文翻译】autogen_agentchat

【中文翻译】下一页

【中文翻译】autogen_agentchat.agents

### autogen_agentchat.messages {autogen_agentchatmessages}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.messages.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.messages.html)

```python
AgentEvent#
```

【中文翻译】所有 `BaseAgentEvent` 内建具体子类的联合类型。
Annotated[ToolCallRequestEvent | ToolCallExecutionEvent | MemoryQueryEvent | UserInputRequestedEvent | ModelClientStreamingChunkEvent | ThoughtEvent | SelectSpeakerEvent | CodeGenerationEvent | CodeExecutionEvent, FieldInfo(annotation=NoneType, required=True, discriminator=’type’)] 的别名

```python
pydantic model BaseAgentEvent[source]#
```

【中文翻译】基类：BaseMessage, ABC
代理事件的基类。

注意
如果要创建用于向用户和应用程序发出可观察事件信号的新消息类型，请从此类继承。

代理事件用于向用户和应用程序发出代理和团队产生的操作和想法的信号。它们不用于代理之间的通信，也不期望被其他代理处理。
如果要提供内容的自定义呈现，则应覆盖 `to_text()` 方法。

显示 JSON 架构
```json
{
   "title": "BaseAgentEvent",
   "description": "Base class for agent events.\n\n.. note::\n\n    If you want to create a new message type for signaling observable events\n    to user and application, inherit from this class.\n\nAgent events are used to signal actions and thoughts produced by agents\nand teams to user and applications. They are not used for agent-to-agent\ncommunication and are not expected to be processed by other agents.\n\nYou should override the :meth:`to_text` method if you want to provide\na custom rendering of the content.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source"
   ]
}
```

字段：

metadata (Dict[str, str])
models_usage (autogen_core.models._types.RequestUsage | None)
source (str)

```python
field metadata: Dict[str, str] = {}#
```

【中文翻译】有关消息的其他元数据。

```python
field models_usage: RequestUsage | None = None#
```

【中文翻译】生成此消息时产生的模型客户端使用情况。

```python
field source: str [Required]#
```

【中文翻译】发送此消息的代理的名称。

```python
pydantic model BaseChatMessage[source]#
```

【中文翻译】基类：BaseMessage, ABC
聊天消息的抽象基类。

注意
如果要创建用于代理之间通信的新消息类型，请从此类继承，或者如果您的内容类型是 Pydantic BaseModel 的子类，则只需使用 `StructuredMessage`。

此类用于在聊天对话中在代理之间发送的消息。代理应使用模型处理消息内容，并以另一个 `BaseChatMessage` 的形式返回响应。

显示 JSON 架构
```json
{
   "title": "BaseChatMessage",
   "description": "Abstract base class for chat messages.\n\n.. note::\n\n    If you want to create a new message type that is used for agent-to-agent\n    communication, inherit from this class, or simply use\n    :class:`StructuredMessage` if your content type is a subclass of\n    Pydantic BaseModel.\n\nThis class is used for messages that are sent between agents in a chat\nconversation. Agents are expected to process the content of the\nmessage using models and return a response as another :class:`BaseChatMessage`.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source"
   ]
}
```

字段：

metadata (Dict[str, str])
models_usage (autogen_core.models._types.RequestUsage | None)
source (str)

```python
field metadata: Dict[str, str] = {}#
```

【中文翻译】有关消息的其他元数据。

```python
field models_usage: RequestUsage | None = None#
```

【中文翻译】生成此消息时产生的模型客户端使用情况。

```python
field source: str [Required]#
```

【中文翻译】发送此消息的代理的名称。

```python
abstract to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
abstract to_model_text() → str[source]#
```

【中文翻译】将消息内容转换为纯文本表示形式。
这用于为模型创建纯文本内容。
这不用于在控制台中呈现消息。为此，请使用 `to_text()`。
此方法与 `to_model_message()` 的区别在于，此方法用于构造模型客户端消息的各个部分，而 `to_model_message()` 用于为模型客户端创建完整的消息。

```python
pydantic model BaseMessage[source]#
```

【中文翻译】基类：BaseModel, ABC
AgentChat 中所有消息类型的抽象基类。

警告
如果要创建新的消息类型，请不要从此类继承。
相反，请从 `BaseChatMessage` 或 `BaseAgentEvent` 继承以阐明消息类型的用途。

显示 JSON 架构
```json
{
   "title": "BaseMessage",
   "description": "Abstract base class for all message types in AgentChat.\n\n.. warning::\n\n    If you want to create a new message type, do not inherit from this class.\n    Instead, inherit from :class:`BaseChatMessage` or :class:`BaseAgentEvent`\n    to clarify the purpose of the message type.",
   "type": "object",
   "properties": {}
}
```

```python
dump() → Mapping[str, Any][source]#
```

【中文翻译】将消息转换为可 JSON 序列化的字典。
默认实现使用 Pydantic 模型的 `model_dump()` 方法将消息转换为字典。
如果要自定义序列化过程或向输出添加其他字段，请覆盖此方法。

```python
classmethod load(data: Mapping[str, Any]) → Self[source]#
```

【中文翻译】从可 JSON 序列化的数据字典创建消息。
默认实现使用 Pydantic 模型的 `model_validate()` 方法从数据创建消息。
如果要自定义反序列化过程或向输入数据添加其他字段，请覆盖此方法。

```python
abstract to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model BaseTextChatMessage[source]#
```

【中文翻译】基类：BaseChatMessage, ABC
所有纯文本 `BaseChatMessage` 类型的基类。
它具有 `to_text()`、`to_model_text()` 和 `to_model_message()` 方法的实现。
如果您的消息内容类型是字符串，请从此类继承。

显示 JSON 架构
```json
{
   "title": "BaseTextChatMessage",
   "description": "Base class for all text-only :class:`BaseChatMessage` types.\nIt has implementations for :meth:`to_text`, :meth:`to_model_text`,\nand :meth:`to_model_message` methods.\n\nInherit from this class if your message content type is a string.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (str)

```python
field content: str [Required]#
```

【中文翻译】消息的内容。

```python
to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
to_model_text() → str[source]#
```

【中文翻译】将消息内容转换为纯文本表示形式。
这用于为模型创建纯文本内容。
这不用于在控制台中呈现消息。为此，请使用 `to_text()`。
此方法与 `to_model_message()` 的区别在于，此方法用于构造模型客户端消息的各个部分，而 `to_model_message()` 用于为模型客户端创建完整的消息。

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
ChatMessage#
```

【中文翻译】所有 `BaseChatMessage` 内建具体子类的联合类型。
它不包括 `StructuredMessage` 类型。
Annotated[TextMessage | MultiModalMessage | StopMessage | ToolCallSummaryMessage | HandoffMessage, FieldInfo(annotation=NoneType, required=True, discriminator=’type’)] 的别名

```python
pydantic model CodeExecutionEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示代码执行事件的事件。

显示 JSON 架构
```json
{
   "title": "CodeExecutionEvent",
   "description": "An event signaling code execution event.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "retry_attempt": {
         "title": "Retry Attempt",
         "type": "integer"
      },
      "result": {
         "$ref": "#/$defs/CodeResult"
      },
      "type": {
         "const": "CodeExecutionEvent",
         "default": "CodeExecutionEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "CodeResult": {
         "properties": {
            "exit_code": {
               "title": "Exit Code",
               "type": "integer"
            },
            "output": {
               "title": "Output",
               "type": "string"
            }
         },
         "required": [
            "exit_code",
            "output"
         ],
         "title": "CodeResult",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "retry_attempt",
      "result"
   ]
}
```

字段：

result (autogen_core.code_executor._base.CodeResult)
retry_attempt (int)
type (Literal['CodeExecutionEvent'])

```python
field result: CodeResult [Required]#
```

【中文翻译】代码执行结果

```python
field retry_attempt: int [Required]#
```

【中文翻译】重试次数，0 表示首次执行

```python
field type: Literal['CodeExecutionEvent'] = 'CodeExecutionEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model CodeGenerationEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示代码生成事件的事件。

显示 JSON 架构
```json
{
   "title": "CodeGenerationEvent",
   "description": "An event signaling code generation event.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "retry_attempt": {
         "title": "Retry Attempt",
         "type": "integer"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "code_blocks": {
         "items": {
            "$ref": "#/$defs/CodeBlock"
         },
         "title": "Code Blocks",
         "type": "array"
      },
      "type": {
         "const": "CodeGenerationEvent",
         "default": "CodeGenerationEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "CodeBlock": {
         "properties": {
            "code": {
               "title": "Code",
               "type": "string"
            },
            "language": {
               "title": "Language",
               "type": "string"
            }
         },
         "required": [
            "code",
            "language"
         ],
         "title": "CodeBlock",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "retry_attempt",
      "content",
      "code_blocks"
   ]
}
```

字段：

code_blocks (List[autogen_core.code_executor._base.CodeBlock])
content (str)
retry_attempt (int)
type (Literal['CodeGenerationEvent'])

```python
field code_blocks: List[CodeBlock] [Required]#
```

【中文翻译】内容中存在的代码块列表

```python
field content: str [Required]#
```

【中文翻译】作为字符串的完整内容。

```python
field retry_attempt: int [Required]#
```

【中文翻译】重试次数，0 表示首次生成

```python
field type: Literal['CodeGenerationEvent'] = 'CodeGenerationEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model HandoffMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
请求将对话移交给另一个代理的消息。

显示 JSON 架构
```json
{
   "title": "HandoffMessage",
   "description": "A message requesting handoff of a conversation to another agent.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "target": {
         "title": "Target",
         "type": "string"
      },
      "context": {
         "default": [],
         "items": {
            "discriminator": {
               "mapping": {
                  "AssistantMessage": "#/$defs/AssistantMessage",
                  "FunctionExecutionResultMessage": "#/$defs/FunctionExecutionResultMessage",
                  "SystemMessage": "#/$defs/SystemMessage",
                  "UserMessage": "#/$defs/UserMessage"
               },
               "propertyName": "type"
            },
            "oneOf": [
               {
                  "$ref": "#/$defs/SystemMessage"
               },
               {
                  "$ref": "#/$defs/UserMessage"
               },
               {
                  "$ref": "#/$defs/AssistantMessage"
               },
               {
                  "$ref": "#/$defs/FunctionExecutionResultMessage"
               }
            ]
         },
         "title": "Context",
         "type": "array"
      },
      "type": {
         "const": "HandoffMessage",
         "default": "HandoffMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "AssistantMessage": {
         "description": "Assistant message are sampled from the language model.",
         "properties": {
            "content": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "items": {
                        "$ref": "#/$defs/FunctionCall"
                     },
                     "type": "array"
                  }
               ],
               "title": "Content"
            },
            "thought": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Thought"
            },
            "source": {
               "title": "Source",
               "type": "string"
            },
            "type": {
               "const": "AssistantMessage",
               "default": "AssistantMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content",
            "source"
         ],
         "title": "AssistantMessage",
         "type": "object"
      },
      "FunctionCall": {
         "properties": {
            "id": {
               "title": "Id",
               "type": "string"
            },
            "arguments": {
               "title": "Arguments",
               "type": "string"
            },
            "name": {
               "title": "Name",
               "type": "string"
            }
         },
         "required": [
            "id",
            "arguments",
            "name"
         ],
         "title": "FunctionCall",
         "type": "object"
      },
      "FunctionExecutionResult": {
         "description": "Function execution result contains the output of a function call.",
         "properties": {
            "content": {
               "title": "Content",
               "type": "string"
            },
            "name": {
               "title": "Name",
               "type": "string"
            },
            "call_id": {
               "title": "Call Id",
               "type": "string"
            },
            "is_error": {
               "anyOf": [
                  {
                     "type": "boolean"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Is Error"
            }
         },
         "required": [
            "content",
            "name",
            "call_id"
         ],
         "title": "FunctionExecutionResult",
         "type": "object"
      },
      "FunctionExecutionResultMessage": {
         "description": "Function execution result message contains the output of multiple function calls.",
         "properties": {
            "content": {
               "items": {
                  "$ref": "#/$defs/FunctionExecutionResult"
               },
               "title": "Content",
               "type": "array"
            },
            "type": {
               "const": "FunctionExecutionResultMessage",
               "default": "FunctionExecutionResultMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content"
         ],
         "title": "FunctionExecutionResultMessage",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      },
      "SystemMessage": {
         "description": "System message contains instructions for the model coming from the developer.\n\n.. note::\n\n    Open AI is moving away from using 'system' role in favor of 'developer' role.\n    See `Model Spec <https://cdn.openai.com/spec/model-spec-2024-05-08.html#definitions>`_ for more details.\n    However, the 'system' role is still allowed in their API and will be automatically converted to 'developer' role\n    on the server side.\n    So, you can use `SystemMessage` for developer messages.",
         "properties": {
            "content": {
               "title": "Content",
               "type": "string"
            },
            "type": {
               "const": "SystemMessage",
               "default": "SystemMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content"
         ],
         "title": "SystemMessage",
         "type": "object"
      },
      "UserMessage": {
         "description": "User message contains input from end users, or a catch-all for data provided to the model.",
         "properties": {
            "content": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "items": {
                        "anyOf": [
                           {
                              "type": "string"
                           },
                           {}
                        ]
                     },
                     "type": "array"
                  }
               ],
               "title": "Content"
            },
            "source": {
               "title": "Source",
               "type": "string"
            },
            "type": {
               "const": "UserMessage",
               "default": "UserMessage",
               "title": "Type",
               "type": "string"
            }
         },
         "required": [
            "content",
            "source"
         ],
         "title": "UserMessage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content",
      "target"
   ]
}
```

字段：

context (List[Annotated[autogen_core.models._types.SystemMessage | autogen_core.models._types.UserMessage | autogen_core.models._types.AssistantMessage | autogen_core.models._types.FunctionExecutionResultMessage, FieldInfo(annotation=NoneType, required=True, discriminator='type')]])
target (str)
type (Literal['HandoffMessage'])

```python
field context: List[Annotated[SystemMessage | UserMessage | AssistantMessage | FunctionExecutionResultMessage, FieldInfo(annotation=NoneType, required=True, discriminator='type')]] = []#
```

【中文翻译】要传递给目标代理的模型上下文。

```python
field target: str [Required]#
```

【中文翻译】要移交到的目标代理的名称。

```python
field type: Literal['HandoffMessage'] = 'HandoffMessage'#
```

```python
pydantic model MemoryQueryEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示内存查询结果的事件。

显示 JSON 架构
```json
{
   "title": "MemoryQueryEvent",
   "description": "An event signaling the results of memory queries.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "$ref": "#/$defs/MemoryContent"
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "MemoryQueryEvent",
         "default": "MemoryQueryEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "MemoryContent": {
         "description": "A memory content item.",
         "properties": {
            "content": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "format": "binary",
                     "type": "string"
                  },
                  {
                     "type": "object"
                  },
                  {}
               ],
               "title": "Content"
            },
            "mime_type": {
               "anyOf": [
                  {
                     "$ref": "#/$defs/MemoryMimeType"
                  },
                  {
                     "type": "string"
                  }
               ],
               "title": "Mime Type"
            },
            "metadata": {
               "anyOf": [
                  {
                     "type": "object"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Metadata"
            }
         },
         "required": [
            "content",
            "mime_type"
         ],
         "title": "MemoryContent",
         "type": "object"
      },
      "MemoryMimeType": {
         "description": "Supported MIME types for memory content.",
         "enum": [
            "text/plain",
            "application/json",
            "text/markdown",
            "image/*",
            "application/octet-stream"
         ],
         "title": "MemoryMimeType",
         "type": "string"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[autogen_core.memory._base_memory.MemoryContent])
type (Literal['MemoryQueryEvent'])

```python
field content: List[MemoryContent] [Required]#
```

【中文翻译】内存查询结果。

```python
field type: Literal['MemoryQueryEvent'] = 'MemoryQueryEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ModelClientStreamingChunkEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示模型客户端在流式模式下输出的文本块的事件。

显示 JSON 架构
```json
{
   "title": "ModelClientStreamingChunkEvent",
   "description": "An event signaling a text output chunk from a model client in streaming mode.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "ModelClientStreamingChunkEvent",
         "default": "ModelClientStreamingChunkEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (str)
type (Literal['ModelClientStreamingChunkEvent'])

```python
field content: str [Required]#
```

【中文翻译】模型客户端的字符串块。

```python
field type: Literal['ModelClientStreamingChunkEvent'] = 'ModelClientStreamingChunkEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model MultiModalMessage[source]#
```

【中文翻译】基类：BaseChatMessage
多模态消息。

显示 JSON 架构
```json
{
   "title": "MultiModalMessage",
   "description": "A multimodal message.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "anyOf": [
               {
                  "type": "string"
               },
               {}
            ]
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "MultiModalMessage",
         "default": "MultiModalMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[str | autogen_core._image.Image])
type (Literal['MultiModalMessage'])

```python
field content: List[str | Image] [Required]#
```

【中文翻译】消息的内容。

```python
field type: Literal['MultiModalMessage'] = 'MultiModalMessage'#
```

```python
to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
to_model_text(image_placeholder: str | None = '[image]') → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式。
如果存在图像，默认情况下它将被图像占位符替换，否则在设置为 None 时它将是 base64 字符串。

```python
to_text(iterm: bool = False) → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model SelectSpeakerEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示对话发言人选择的事件。

显示 JSON 架构
```json
{
   "title": "SelectSpeakerEvent",
   "description": "An event signaling the selection of speakers for a conversation.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "type": "string"
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "SelectSpeakerEvent",
         "default": "SelectSpeakerEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[str])
type (Literal['SelectSpeakerEvent'])

```python
field content: List[str] [Required]#
```

【中文翻译】所选发言人的姓名。

```python
field type: Literal['SelectSpeakerEvent'] = 'SelectSpeakerEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model StopMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
请求停止对话的消息。

显示 JSON 架构
```json
{
   "title": "StopMessage",
   "description": "A message requesting stop of a conversation.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "StopMessage",
         "default": "StopMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

type (Literal['StopMessage'])

```python
field type: Literal['StopMessage'] = 'StopMessage'#
```

```python
class StructuredContentType#
```

【中文翻译】结构化内容类型的类型变量。
TypeVar(‘StructuredContentType’, bound=BaseModel, covariant=True) 的别名

```python
pydantic model StructuredMessage[source]#
```

【中文翻译】基类：BaseChatMessage, Generic[StructuredContentType]
具有未指定内容类型的 `BaseChatMessage` 类型。
要创建新的结构化消息类型，请将内容类型指定为 Pydantic BaseModel 的子类。
```python
from pydantic import BaseModel
from autogen_agentchat.messages import StructuredMessage


class MyMessageContent(BaseModel):
    text: str
    number: int


message = StructuredMessage[MyMessageContent](
    content=MyMessageContent(text="Hello", number=42),
    source="agent1",
)

print(message.to_text())  # {"text": "Hello", "number": 42}
```

```python
from pydantic import BaseModel
from autogen_agentchat.messages import StructuredMessage


class MyMessageContent(BaseModel):
    text: str
    number: int


message = StructuredMessage[MyMessageContent](
    content=MyMessageContent(text="Hello", number=42),
    source="agent",
    format_string="Hello, {text} {number}!",
)

print(message.to_text())  # Hello, agent 42!
```

显示 JSON 架构
```json
{
   "title": "StructuredMessage",
   "description": "A :class:`BaseChatMessage` type with an unspecified content type.\n\nTo create a new structured message type, specify the content type\nas a subclass of `Pydantic BaseModel <https://docs.pydantic.dev/latest/concepts/models/>`_.\n\n.. code-block:: python\n\n    from pydantic import BaseModel\n    from autogen_agentchat.messages import StructuredMessage\n\n\n    class MyMessageContent(BaseModel):\n        text: str\n        number: int\n\n\n    message = StructuredMessage[MyMessageContent](\n        content=MyMessageContent(text=\"Hello\", number=42),\n        source=\"agent1\",\n    )\n\n    print(message.to_text())  # {\"text\": \"Hello\", \"number\": 42}\n\n.. code-block:: python\n\n    from pydantic import BaseModel\n    from autogen_agentchat.messages import StructuredMessage\n\n\n    class MyMessageContent(BaseModel):\n        text: str\n        number: int\n\n\n    message = StructuredMessage[MyMessageContent](\n        content=MyMessageContent(text=\"Hello\", number=42),\n        source=\"agent\",\n        format_string=\"Hello, {text} {number}!\",\n    )\n\n    print(message.to_text())  # Hello, agent 42!",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "$ref": "#/$defs/BaseModel"
      },
      "format_string": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Format String"
      }
   },
   "$defs": {
      "BaseModel": {
         "properties": {},
         "title": "BaseModel",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (autogen_agentchat.messages.StructuredContentType)
format_string (str | None)

```python
field content: StructuredContentType [Required]#
```

【中文翻译】消息的内容。必须是 Pydantic BaseModel 的子类。

```python
field format_string: str | None = None#
```

【中文翻译】（实验性）一个可选的格式字符串，用于将内容呈现为人类可读的格式。
格式字符串可以使用内容模型的字段作为占位符。
例如，如果内容模型有一个字段 `name`，您可以在格式字符串中使用 `{name}` 来包含该字段的值。
格式字符串在 `to_text()` 方法中使用，以创建消息的人类可读表示形式。
此设置是实验性的，将来会更改。

```python
to_model_message() → UserMessage[source]#
```

【中文翻译】将消息内容转换为 `UserMessage` 以供模型客户端（例如 `ChatCompletionClient`）使用。

```python
to_model_text() → str[source]#
```

【中文翻译】将消息内容转换为纯文本表示形式。
这用于为模型创建纯文本内容。
这不用于在控制台中呈现消息。为此，请使用 `to_text()`。
此方法与 `to_model_message()` 的区别在于，此方法用于构造模型客户端消息的各个部分，而 `to_model_message()` 用于为模型客户端创建完整的消息。

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
property type: str#
```

```python
pydantic model TextMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
具有纯字符串内容的文本消息。

显示 JSON 架构
```json
{
   "title": "TextMessage",
   "description": "A text message with string-only content.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "TextMessage",
         "default": "TextMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

type (Literal['TextMessage'])

```python
field type: Literal['TextMessage'] = 'TextMessage'#
```

```python
pydantic model ThoughtEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示模型思考过程的事件。
它用于传达推理模型生成的推理令牌，或函数调用生成的额外文本内容。

显示 JSON 架构
```json
{
   "title": "ThoughtEvent",
   "description": "An event signaling the thought process of a model.\nIt is used to communicate the reasoning tokens generated by a reasoning model,\nor the extra text content generated by a function call.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "ThoughtEvent",
         "default": "ThoughtEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (str)
type (Literal['ThoughtEvent'])

```python
field content: str [Required]#
```

【中文翻译】模型的思考过程。

```python
field type: Literal['ThoughtEvent'] = 'ThoughtEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ToolCallExecutionEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示工具调用执行的事件。

显示 JSON 架构
```json
{
   "title": "ToolCallExecutionEvent",
   "description": "An event signaling the execution of tool calls.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "$ref": "#/$defs/FunctionExecutionResult"
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "ToolCallExecutionEvent",
         "default": "ToolCallExecutionEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "FunctionExecutionResult": {
         "description": "Function execution result contains the output of a function call.",
         "properties": {
            "content": {
               "title": "Content",
               "type": "string"
            },
            "name": {
               "title": "Name",
               "type": "string"
            },
            "call_id": {
               "title": "Call Id",
               "type": "string"
            },
            "is_error": {
               "anyOf": [
                  {
                     "type": "boolean"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Is Error"
            }
         },
         "required": [
            "content",
            "name",
            "call_id"
         ],
         "title": "FunctionExecutionResult",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[autogen_core.models._types.FunctionExecutionResult])
type (Literal['ToolCallExecutionEvent'])

```python
field content: List[FunctionExecutionResult] [Required]#
```

【中文翻译】工具调用结果。

```python
field type: Literal['ToolCallExecutionEvent'] = 'ToolCallExecutionEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ToolCallRequestEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示请求使用工具的事件。

显示 JSON 架构
```json
{
   "title": "ToolCallRequestEvent",
   "description": "An event signaling a request to use tools.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "items": {
            "$ref": "#/$defs/FunctionCall"
         },
         "title": "Content",
         "type": "array"
      },
      "type": {
         "const": "ToolCallRequestEvent",
         "default": "ToolCallRequestEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "FunctionCall": {
         "properties": {
            "id": {
               "title": "Id",
               "type": "string"
            },
            "arguments": {
               "title": "Arguments",
               "type": "string"
            },
            "name": {
               "title": "Name",
               "type": "string"
            }
         },
         "required": [
            "id",
            "arguments",
            "name"
         ],
         "title": "FunctionCall",
         "type": "object"
      },
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

content (List[autogen_core._types.FunctionCall])
type (Literal['ToolCallRequestEvent'])

```python
field content: List[FunctionCall] [Required]#
```

【中文翻译】工具调用。

```python
field type: Literal['ToolCallRequestEvent'] = 'ToolCallRequestEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

```python
pydantic model ToolCallSummaryMessage[source]#
```

【中文翻译】基类：BaseTextChatMessage
一个表示工具调用结果摘要的消息。

显示 JSON 架构
```json
{
   "title": "ToolCallSummaryMessage",
   "description": "A message signaling the summary of tool call results.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "content": {
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "ToolCallSummaryMessage",
         "default": "ToolCallSummaryMessage",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "content"
   ]
}
```

字段：

type (Literal['ToolCallSummaryMessage'])

```python
field type: Literal['ToolCallSummaryMessage'] = 'ToolCallSummaryMessage'#
```

```python
pydantic model UserInputRequestedEvent[source]#
```

【中文翻译】基类：BaseAgentEvent
一个表示用户代理已请求用户输入的事件。在调用输入回调之前发布。

显示 JSON 架构
```json
{
   "title": "UserInputRequestedEvent",
   "description": "An event signaling a that the user proxy has requested user input. Published prior to invoking the input callback.",
   "type": "object",
   "properties": {
      "source": {
         "title": "Source",
         "type": "string"
      },
      "models_usage": {
         "anyOf": [
            {
               "$ref": "#/$defs/RequestUsage"
            },
            {
               "type": "null"
            }
         ],
         "default": null
      },
      "metadata": {
         "additionalProperties": {
            "type": "string"
         },
         "default": {},
         "title": "Metadata",
         "type": "object"
      },
      "request_id": {
         "title": "Request Id",
         "type": "string"
      },
      "content": {
         "const": "",
         "default": "",
         "title": "Content",
         "type": "string"
      },
      "type": {
         "const": "UserInputRequestedEvent",
         "default": "UserInputRequestedEvent",
         "title": "Type",
         "type": "string"
      }
   },
   "$defs": {
      "RequestUsage": {
         "properties": {
            "prompt_tokens": {
               "title": "Prompt Tokens",
               "type": "integer"
            },
            "completion_tokens": {
               "title": "Completion Tokens",
               "type": "integer"
            }
         },
         "required": [
            "prompt_tokens",
            "completion_tokens"
         ],
         "title": "RequestUsage",
         "type": "object"
      }
   },
   "required": [
      "source",
      "request_id"
   ]
}
```

字段：

content (Literal[''])
request_id (str)
type (Literal['UserInputRequestedEvent'])

```python
field content: Literal[''] = ''#
```

【中文翻译】空内容，用于与期望有 content 字段的消费者兼容。

```python
field request_id: str [Required]#
```

【中文翻译】用户输入请求的标识符。

```python
field type: Literal['UserInputRequestedEvent'] = 'UserInputRequestedEvent'#
```

```python
to_text() → str[source]#
```

【中文翻译】将消息内容转换为纯字符串表示形式，以便在控制台中呈现并供用户或条件检查。
这不用于为模型创建纯文本内容。
对于 `BaseChatMessage` 类型，请改用 `to_model_text()`。

【中文翻译】此模块定义了用于代理之间通信的各种消息类型。
每种消息类型都从 `BaseChatMessage` 类或 `BaseAgentEvent` 类继承，并包含与所发送消息类型相关的特定字段。

【中文翻译】上一页

【中文翻译】autogen_agentchat

【中文翻译】下一页

【中文翻译】autogen_agentchat.agents

### autogen_agentchat.state {autogen_agentchatstate}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.state.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.state.html)

```python
pydantic model AssistantAgentState[source]#
```

【中文翻译】基类：BaseState
助手代理的状态。

显示 JSON 架构
```json
{
   "title": "AssistantAgentState",
   "description": "State for an assistant agent.",
   "type": "object",
   "properties": {
      "type": {
         "default": "AssistantAgentState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "llm_context": {
         "title": "Llm Context",
         "type": "object"
      }
   }
}
```

字段：

llm_context (Mapping[str, Any])
type (str)

```python
field llm_context: Mapping[str, Any] [Optional]#
```

```python
field type: str = 'AssistantAgentState'#
```

```python
pydantic model BaseGroupChatManagerState[source]#
```

【中文翻译】基类：BaseState
所有群聊管理器的基本状态。

显示 JSON 架构
```json
{
   "title": "BaseGroupChatManagerState",
   "description": "Base state for all group chat managers.",
   "type": "object",
   "properties": {
      "type": {
         "default": "BaseGroupChatManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      }
   }
}
```

字段：

current_turn (int)
message_thread (List[Mapping[str, Any]])
type (str)

```python
field current_turn: int = 0#
```

```python
field message_thread: List[Mapping[str, Any]] [Optional]#
```

```python
field type: str = 'BaseGroupChatManagerState'#
```

```python
pydantic model BaseState[source]#
```

【中文翻译】基类：BaseModel
所有可保存状态的基类

显示 JSON 架构
```json
{
   "title": "BaseState",
   "description": "Base class for all saveable state",
   "type": "object",
   "properties": {
      "type": {
         "default": "BaseState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      }
   }
}
```

字段：

type (str)
version (str)

```python
field type: str = 'BaseState'#
```

```python
field version: str = '1.0.0'#
```

```python
pydantic model ChatAgentContainerState[source]#
```

【中文翻译】基类：BaseState
聊天代理容器的状态。

显示 JSON 架构
```json
{
   "title": "ChatAgentContainerState",
   "description": "State for a container of chat agents.",
   "type": "object",
   "properties": {
      "type": {
         "default": "ChatAgentContainerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "agent_state": {
         "title": "Agent State",
         "type": "object"
      },
      "message_buffer": {
         "items": {
            "type": "object"
         },
         "title": "Message Buffer",
         "type": "array"
      }
   }
}
```

字段：

agent_state (Mapping[str, Any])
message_buffer (List[Mapping[str, Any]])
type (str)

```python
field agent_state: Mapping[str, Any] [Optional]#
```

```python
field message_buffer: List[Mapping[str, Any]] [Optional]#
```

```python
field type: str = 'ChatAgentContainerState'#
```

```python
pydantic model MagenticOneOrchestratorState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
MagenticOneGroupChat 编排器的状态。

显示 JSON 架构
```json
{
   "title": "MagenticOneOrchestratorState",
   "description": "State for :class:`~autogen_agentchat.teams.MagneticOneGroupChat` orchestrator.",
   "type": "object",
   "properties": {
      "type": {
         "default": "MagenticOneOrchestratorState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "task": {
         "default": "",
         "title": "Task",
         "type": "string"
      },
      "facts": {
         "default": "",
         "title": "Facts",
         "type": "string"
      },
      "plan": {
         "default": "",
         "title": "Plan",
         "type": "string"
      },
      "n_rounds": {
         "default": 0,
         "title": "N Rounds",
         "type": "integer"
      },
      "n_stalls": {
         "default": 0,
         "title": "N Stalls",
         "type": "integer"
      }
   }
}
```

字段：

facts (str)
n_rounds (int)
n_stalls (int)
plan (str)
task (str)
type (str)

```python
field facts: str = ''#
```

```python
field n_rounds: int = 0#
```

```python
field n_stalls: int = 0#
```

```python
field plan: str = ''#
```

```python
field task: str = ''#
```

```python
field type: str = 'MagenticOneOrchestratorState'#
```

```python
pydantic model RoundRobinManagerState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
RoundRobinGroupChat 管理器的状态。

显示 JSON 架构
```json
{
   "title": "RoundRobinManagerState",
   "description": "State for :class:`~autogen_agentchat.teams.RoundRobinGroupChat` manager.",
   "type": "object",
   "properties": {
      "type": {
         "default": "RoundRobinManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "next_speaker_index": {
         "default": 0,
         "title": "Next Speaker Index",
         "type": "integer"
      }
   }
}
```

字段：

next_speaker_index (int)
type (str)

```python
field next_speaker_index: int = 0#
```

```python
field type: str = 'RoundRobinManagerState'#
```

```python
pydantic model SelectorManagerState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
SelectorGroupChat 管理器的状态。

显示 JSON 架构
```json
{
   "title": "SelectorManagerState",
   "description": "State for :class:`~autogen_agentchat.teams.SelectorGroupChat` manager.",
   "type": "object",
   "properties": {
      "type": {
         "default": "SelectorManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "previous_speaker": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Previous Speaker"
      }
   }
}
```

字段：

previous_speaker (str | None)
type (str)

```python
field previous_speaker: str | None = None#
```

```python
field type: str = 'SelectorManagerState'#
```

```python
pydantic model SocietyOfMindAgentState[source]#
```

【中文翻译】基类：BaseState
心智社会代理的状态。

显示 JSON 架构
```json
{
   "title": "SocietyOfMindAgentState",
   "description": "State for a Society of Mind agent.",
   "type": "object",
   "properties": {
      "type": {
         "default": "SocietyOfMindAgentState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "inner_team_state": {
         "title": "Inner Team State",
         "type": "object"
      }
   }
}
```

字段：

inner_team_state (Mapping[str, Any])
type (str)

```python
field inner_team_state: Mapping[str, Any] [Optional]#
```

```python
field type: str = 'SocietyOfMindAgentState'#
```

```python
pydantic model SwarmManagerState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
Swarm 管理器的状态。

显示 JSON 架构
```json
{
   "title": "SwarmManagerState",
   "description": "State for :class:`~autogen_agentchat.teams.Swarm` manager.",
   "type": "object",
   "properties": {
      "type": {
         "default": "SwarmManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "current_speaker": {
         "default": "",
         "title": "Current Speaker",
         "type": "string"
      }
   }
}
```

字段：

current_speaker (str)
type (str)

```python
field current_speaker: str = ''#
```

```python
field type: str = 'SwarmManagerState'#
```

```python
pydantic model TeamState[source]#
```

【中文翻译】基类：BaseState
代理团队的状态。

显示 JSON 架构
```json
{
   "title": "TeamState",
   "description": "State for a team of agents.",
   "type": "object",
   "properties": {
      "type": {
         "default": "TeamState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "agent_states": {
         "title": "Agent States",
         "type": "object"
      }
   }
}
```

字段：

agent_states (Mapping[str, Any])
type (str)

```python
field agent_states: Mapping[str, Any] [Optional]#
```

```python
field type: str = 'TeamState'#
```

【中文翻译】代理、团队和终止条件的状态管理。

【中文翻译】上一页

【中文翻译】autogen_agentchat.ui

【中文翻译】下一页

【中文翻译】autogen_core

### autogen_agentchat.state {autogen_agentchatstate}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.state.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.state.html)

```python
pydantic model AssistantAgentState[source]#
```

【中文翻译】基类：BaseState
助手代理的状态。

显示 JSON 架构
```json
{
   "title": "AssistantAgentState",
   "description": "State for an assistant agent.",
   "type": "object",
   "properties": {
      "type": {
         "default": "AssistantAgentState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "llm_context": {
         "title": "Llm Context",
         "type": "object"
      }
   }
}
```

字段：

llm_context (Mapping[str, Any])
type (str)

```python
field llm_context: Mapping[str, Any] [Optional]#
```

```python
field type: str = 'AssistantAgentState'#
```

```python
pydantic model BaseGroupChatManagerState[source]#
```

【中文翻译】基类：BaseState
所有群聊管理器的基本状态。

显示 JSON 架构
```json
{
   "title": "BaseGroupChatManagerState",
   "description": "Base state for all group chat managers.",
   "type": "object",
   "properties": {
      "type": {
         "default": "BaseGroupChatManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      }
   }
}
```

字段：

current_turn (int)
message_thread (List[Mapping[str, Any]])
type (str)

```python
field current_turn: int = 0#
```

```python
field message_thread: List[Mapping[str, Any]] [Optional]#
```

```python
field type: str = 'BaseGroupChatManagerState'#
```

```python
pydantic model BaseState[source]#
```

【中文翻译】基类：BaseModel
所有可保存状态的基类

显示 JSON 架构
```json
{
   "title": "BaseState",
   "description": "Base class for all saveable state",
   "type": "object",
   "properties": {
      "type": {
         "default": "BaseState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      }
   }
}
```

字段：

type (str)
version (str)

```python
field type: str = 'BaseState'#
```

```python
field version: str = '1.0.0'#
```

```python
pydantic model ChatAgentContainerState[source]#
```

【中文翻译】基类：BaseState
聊天代理容器的状态。

显示 JSON 架构
```json
{
   "title": "ChatAgentContainerState",
   "description": "State for a container of chat agents.",
   "type": "object",
   "properties": {
      "type": {
         "default": "ChatAgentContainerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "agent_state": {
         "title": "Agent State",
         "type": "object"
      },
      "message_buffer": {
         "items": {
            "type": "object"
         },
         "title": "Message Buffer",
         "type": "array"
      }
   }
}
```

字段：

agent_state (Mapping[str, Any])
message_buffer (List[Mapping[str, Any]])
type (str)

```python
field agent_state: Mapping[str, Any] [Optional]#
```

```python
field message_buffer: List[Mapping[str, Any]] [Optional]#
```

```python
field type: str = 'ChatAgentContainerState'#
```

```python
pydantic model MagenticOneOrchestratorState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
MagenticOneGroupChat 编排器的状态。

显示 JSON 架构
```json
{
   "title": "MagenticOneOrchestratorState",
   "description": "State for :class:`~autogen_agentchat.teams.MagneticOneGroupChat` orchestrator.",
   "type": "object",
   "properties": {
      "type": {
         "default": "MagenticOneOrchestratorState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "task": {
         "default": "",
         "title": "Task",
         "type": "string"
      },
      "facts": {
         "default": "",
         "title": "Facts",
         "type": "string"
      },
      "plan": {
         "default": "",
         "title": "Plan",
         "type": "string"
      },
      "n_rounds": {
         "default": 0,
         "title": "N Rounds",
         "type": "integer"
      },
      "n_stalls": {
         "default": 0,
         "title": "N Stalls",
         "type": "integer"
      }
   }
}
```

字段：

facts (str)
n_rounds (int)
n_stalls (int)
plan (str)
task (str)
type (str)

```python
field facts: str = ''#
```

```python
field n_rounds: int = 0#
```

```python
field n_stalls: int = 0#
```

```python
field plan: str = ''#
```

```python
field task: str = ''#
```

```python
field type: str = 'MagenticOneOrchestratorState'#
```

```python
pydantic model RoundRobinManagerState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
RoundRobinGroupChat 管理器的状态。

显示 JSON 架构
```json
{
   "title": "RoundRobinManagerState",
   "description": "State for :class:`~autogen_agentchat.teams.RoundRobinGroupChat` manager.",
   "type": "object",
   "properties": {
      "type": {
         "default": "RoundRobinManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "next_speaker_index": {
         "default": 0,
         "title": "Next Speaker Index",
         "type": "integer"
      }
   }
}
```

字段：

next_speaker_index (int)
type (str)

```python
field next_speaker_index: int = 0#
```

```python
field type: str = 'RoundRobinManagerState'#
```

```python
pydantic model SelectorManagerState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
SelectorGroupChat 管理器的状态。

显示 JSON 架构
```json
{
   "title": "SelectorManagerState",
   "description": "State for :class:`~autogen_agentchat.teams.SelectorGroupChat` manager.",
   "type": "object",
   "properties": {
      "type": {
         "default": "SelectorManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "previous_speaker": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Previous Speaker"
      }
   }
}
```

字段：

previous_speaker (str | None)
type (str)

```python
field previous_speaker: str | None = None#
```

```python
field type: str = 'SelectorManagerState'#
```

```python
pydantic model SocietyOfMindAgentState[source]#
```

【中文翻译】基类：BaseState
心智社会代理的状态。

显示 JSON 架构
```json
{
   "title": "SocietyOfMindAgentState",
   "description": "State for a Society of Mind agent.",
   "type": "object",
   "properties": {
      "type": {
         "default": "SocietyOfMindAgentState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "inner_team_state": {
         "title": "Inner Team State",
         "type": "object"
      }
   }
}
```

字段：

inner_team_state (Mapping[str, Any])
type (str)

```python
field inner_team_state: Mapping[str, Any] [Optional]#
```

```python
field type: str = 'SocietyOfMindAgentState'#
```

```python
pydantic model SwarmManagerState[source]#
```

【中文翻译】基类：BaseGroupChatManagerState
Swarm 管理器的状态。

显示 JSON 架构
```json
{
   "title": "SwarmManagerState",
   "description": "State for :class:`~autogen_agentchat.teams.Swarm` manager.",
   "type": "object",
   "properties": {
      "type": {
         "default": "SwarmManagerState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "message_thread": {
         "items": {
            "type": "object"
         },
         "title": "Message Thread",
         "type": "array"
      },
      "current_turn": {
         "default": 0,
         "title": "Current Turn",
         "type": "integer"
      },
      "current_speaker": {
         "default": "",
         "title": "Current Speaker",
         "type": "string"
      }
   }
}
```

字段：

current_speaker (str)
type (str)

```python
field current_speaker: str = ''#
```

```python
field type: str = 'SwarmManagerState'#
```

```python
pydantic model TeamState[source]#
```

【中文翻译】基类：BaseState
代理团队的状态。

显示 JSON 架构
```json
{
   "title": "TeamState",
   "description": "State for a team of agents.",
   "type": "object",
   "properties": {
      "type": {
         "default": "TeamState",
         "title": "Type",
         "type": "string"
      },
      "version": {
         "default": "1.0.0",
         "title": "Version",
         "type": "string"
      },
      "agent_states": {
         "title": "Agent States",
         "type": "object"
      }
   }
}
```

字段：

agent_states (Mapping[str, Any])
type (str)

```python
field agent_states: Mapping[str, Any] [Optional]#
```

```python
field type: str = 'TeamState'#
```

【中文翻译】代理、团队和终止条件的状态管理。

【中文翻译】上一页

【中文翻译】autogen_agentchat.ui

【中文翻译】下一页

【中文翻译】autogen_core

### autogen_agentchat.teams {autogen_agentchatteams}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.teams.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.teams.html)

```python
class BaseGroupChat(participants: List[ChatAgent], group_chat_manager_name: str, group_chat_manager_class: type[SequentialRoutedAgent], termination_condition: TerminationCondition | None = None, max_turns: int | None = None, runtime: AgentRuntime | None = None, custom_message_types: List[type[BaseAgentEvent | BaseChatMessage]] | None = None, emit_team_events: bool = False)[source]#
```

【中文翻译】基类：Team, ABC, ComponentBase[BaseModel]
群聊团队的基类。
要实现群聊团队，首先创建 `BaseGroupChatManager` 的子类，然后创建使用该群聊管理器的 `BaseGroupChat` 的子类。

```python
component_type: ClassVar[ComponentType] = 'team'#
```

【中文翻译】组件的逻辑类型。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载外部状态并覆盖群聊团队的当前状态。
通过在每个参与者和群聊管理器上使用其内部代理 ID 调用 `agent_load_state()` 方法来加载状态。
有关状态的预期格式，请参阅 `save_state()`。

```python
async pause() → None[source]#
```

【中文翻译】当团队运行时，通过直接 RPC 调用其 `on_pause()` 方法来暂停其参与者。

注意
这是 v0.4.9 中引入的实验性功能，将来可能会更改或删除。

团队必须初始化才能暂停。
与终止不同，暂停团队不会导致 `run()` 或 `run_stream()` 方法返回。它会在每个参与者上调用 `on_pause()` 方法，如果参与者未实现该方法，则它将是无操作。

注意
代理类负责处理暂停并确保代理稍后可以恢复。
确保在代理类中实现 `on_pause()` 方法以实现自定义暂停行为。
默认情况下，调用时代理不会执行任何操作。

引发：
RuntimeError – 如果团队尚未初始化。在调用其 `on_pause` 实现时，来自参与者的异常会传播到此方法并引发。

```python
async reset() → None[source]#
```

【中文翻译】将团队及其参与者重置为其初始状态。
团队必须停止才能重置。

引发：
RuntimeError – 如果团队尚未初始化或当前正在运行。

使用 RoundRobinGroupChat 团队的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)
    stream = team.run_stream(task="Count from 1 to 10, respond one at a time.")
    async for message in stream:
        print(message)

    # 重置团队。
    await team.reset()
    stream = team.run_stream(task="Count from 1 to 10, respond one at a time.")
    async for message in stream:
        print(message)


asyncio.run(main())
```

```python
async resume() → None[source]#
```

【中文翻译】当团队正在运行并暂停时，通过直接 RPC 调用其 `on_resume()` 方法来恢复其参与者。

注意
这是 v0.4.9 中引入的实验性功能，将来可能会更改或删除。

团队必须初始化才能恢复。
与使用新任务终止和重新启动不同，恢复团队不会导致 `run()` 或 `run_stream()` 方法返回。
它会在每个参与者上调用 `on_resume()` 方法，如果参与者未实现该方法，则它将是无操作。

注意
代理类负责处理恢复并确保代理从暂停的位置继续。
确保在代理类中实现 `on_resume()` 方法以实现自定义恢复行为。

引发：
RuntimeError – 如果团队尚未初始化。在调用其 `on_resume` 方法实现时，来自参与者的异常会传播到此方法并引发。

```python
async run(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → TaskResult[source]#
```

【中文翻译】运行团队并返回结果。基本实现使用 `run_stream()` 运行团队，然后返回最终结果。
一旦团队停止，终止条件就会重置。

参数：

task (str | BaseChatMessage | Sequence[BaseChatMessage] | None) – 用于运行团队的任务。可以是字符串、单个 `BaseChatMessage` 或 `BaseChatMessage` 列表。
cancellation_token (CancellationToken | None) – 用于立即终止任务的取消令牌。
设置取消令牌可能会使团队处于不一致状态，并且可能不会重置终止条件。
要正常停止团队，请改用 `ExternalTermination`。

返回：
result – 作为 `TaskResult` 的任务结果。结果包含团队生成的消息和停止原因。

使用 RoundRobinGroupChat 团队的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    result = await team.run(task="Count from 1 to 10, respond one at a time.")
    print(result)

    # 再次运行团队，不带任务以继续上一个任务。
    result = await team.run()
    print(result)


asyncio.run(main())
```

使用 CancellationToken 取消任务的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_core import CancellationToken
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    cancellation_token = CancellationToken()

    # 创建一个任务以在后台运行团队。
    run_task = asyncio.create_task(
        team.run(
            task="Count from 1 to 10, respond one at a time.",
            cancellation_token=cancellation_token,
        )
    )

    # 等待 1 秒，然后取消任务。
    await asyncio.sleep(1)
    cancellation_token.cancel()

    # 这将引发一个取消错误。
    await run_task


asyncio.run(main())
```

```python
async run_stream(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None][source]#
```

【中文翻译】运行团队并产生消息流，最终结果类型为 `TaskResult`，作为流中的最后一项。一旦团队停止，终止条件就会重置。

注意
如果代理产生 `ModelClientStreamingChunkEvent`，则该消息将在流中产生，但不会包含在消息中。

参数：

task (str | BaseChatMessage | Sequence[BaseChatMessage] | None) – 用于运行团队的任务。可以是字符串、单个 `BaseChatMessage` 或 `BaseChatMessage` 列表。
cancellation_token (CancellationToken | None) – 用于立即终止任务的取消令牌。
设置取消令牌可能会使团队处于不一致状态，并且可能不会重置终止条件。
要正常停止团队，请改用 `ExternalTermination`。

返回：
stream – 一个 `AsyncGenerator`，它产生 `BaseAgentEvent`、`BaseChatMessage`，以及作为流中最后一项的最终结果 `TaskResult`。

使用 RoundRobinGroupChat 团队的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    stream = team.run_stream(task="Count from 1 to 10, respond one at a time.")
    async for message in stream:
        print(message)

    # 再次运行团队，不带任务以继续上一个任务。
    stream = team.run_stream()
    async for message in stream:
        print(message)


asyncio.run(main())
```

使用 CancellationToken 取消任务的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.ui import Console
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_core import CancellationToken
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    cancellation_token = CancellationToken()

    # 创建一个任务以在后台运行团队。
    run_task = asyncio.create_task(
        Console(
            team.run_stream(
                task="Count from 1 to 10, respond one at a time.",
                cancellation_token=cancellation_token,
            )
        )
    )

    # 等待 1 秒，然后取消任务。
    await asyncio.sleep(1)
    cancellation_token.cancel()

    # 这将引发一个取消错误。
    await run_task


asyncio.run(main())
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存群聊团队的状态。
通过在每个参与者和群聊管理器上使用其内部代理 ID 调用 `agent_save_state()` 方法来保存状态。
状态以嵌套字典的形式返回：一个键为 `agent_states` 的字典，其值为一个字典，其中代理名称为键，状态为值。
```json
{
    "agent_states": {
        "agent1": ...,
        "agent2": ...,
        "RoundRobinGroupChatManager": ...
    }
}
```

注意
从 v0.4.9 开始，状态使用代理名称作为键而不是代理 ID，并且从状态中删除了 `team_id` 字段。这是为了允许状态在不同的团队和运行时之间可移植。使用旧格式保存的状态将来可能与新格式不兼容。

警告
在团队运行时调用 `save_state()` 时，状态可能不一致，并可能导致意外状态。
建议在团队未运行或停止后调用此方法。

```python
component_type: ClassVar[ComponentType] = 'team'#
```

【中文翻译】组件的逻辑类型。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载外部状态并覆盖群聊团队的当前状态。
通过在每个参与者和群聊管理器上使用其内部代理 ID 调用 `agent_load_state()` 方法来加载状态。
有关状态的预期格式，请参阅 `save_state()`。

```python
async pause() → None[source]#
```

【中文翻译】当团队运行时，通过直接 RPC 调用其 `on_pause()` 方法来暂停其参与者。

注意
这是 v0.4.9 中引入的实验性功能，将来可能会更改或删除。

团队必须初始化才能暂停。
与终止不同，暂停团队不会导致 `run()` 或 `run_stream()` 方法返回。它会在每个参与者上调用 `on_pause()` 方法，如果参与者未实现该方法，则它将是无操作。

注意
代理类负责处理暂停并确保代理稍后可以恢复。
确保在代理类中实现 `on_pause()` 方法以实现自定义暂停行为。
默认情况下，调用时代理不会执行任何操作。

引发：
RuntimeError – 如果团队尚未初始化。在调用其 `on_pause` 实现时，来自参与者的异常会传播到此方法并引发。

```python
async reset() → None[source]#
```

【中文翻译】将团队及其参与者重置为其初始状态。
团队必须停止才能重置。

引发：
RuntimeError – 如果团队尚未初始化或当前正在运行。

使用 RoundRobinGroupChat 团队的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)
    stream = team.run_stream(task="Count from 1 to 10, respond one at a time.")
    async for message in stream:
        print(message)

    # 重置团队。
    await team.reset()
    stream = team.run_stream(task="Count from 1 to 10, respond one at a time.")
    async for message in stream:
        print(message)


asyncio.run(main())
```

```python
async resume() → None[source]#
```

【中文翻译】当团队正在运行并暂停时，通过直接 RPC 调用其 `on_resume()` 方法来恢复其参与者。

注意
这是 v0.4.9 中引入的实验性功能，将来可能会更改或删除。

团队必须初始化才能恢复。
与使用新任务终止和重新启动不同，恢复团队不会导致 `run()` 或 `run_stream()` 方法返回。
它会在每个参与者上调用 `on_resume()` 方法，如果参与者未实现该方法，则它将是无操作。

注意
代理类负责处理恢复并确保代理从暂停的位置继续。
确保在代理类中实现 `on_resume()` 方法以实现自定义恢复行为。

引发：
RuntimeError – 如果团队尚未初始化。在调用其 `on_resume` 方法实现时，来自参与者的异常会传播到此方法并引发。

```python
async run(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → TaskResult[source]#
```

【中文翻译】运行团队并返回结果。基本实现使用 `run_stream()` 运行团队，然后返回最终结果。
一旦团队停止，终止条件就会重置。

参数：

task (str | BaseChatMessage | Sequence[BaseChatMessage] | None) – 用于运行团队的任务。可以是字符串、单个 `BaseChatMessage` 或 `BaseChatMessage` 列表。
cancellation_token (CancellationToken | None) – 用于立即终止任务的取消令牌。
设置取消令牌可能会使团队处于不一致状态，并且可能不会重置终止条件。
要正常停止团队，请改用 `ExternalTermination`。

返回：
result – 作为 `TaskResult` 的任务结果。结果包含团队生成的消息和停止原因。

使用 RoundRobinGroupChat 团队的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    result = await team.run(task="Count from 1 to 10, respond one at a time.")
    print(result)

    # 再次运行团队，不带任务以继续上一个任务。
    result = await team.run()
    print(result)


asyncio.run(main())
```

使用 CancellationToken 取消任务的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_core import CancellationToken
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    cancellation_token = CancellationToken()

    # 创建一个任务以在后台运行团队。
    run_task = asyncio.create_task(
        team.run(
            task="Count from 1 to 10, respond one at a time.",
            cancellation_token=cancellation_token,
        )
    )

    # 等待 1 秒，然后取消任务。
    await asyncio.sleep(1)
    cancellation_token.cancel()

    # 这将引发一个取消错误。
    await run_task


asyncio.run(main())
```

```python
async run_stream(*, task: str | BaseChatMessage | Sequence[BaseChatMessage] | None = None, cancellation_token: CancellationToken | None = None) → AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None][source]#
```

【中文翻译】运行团队并产生消息流，最终结果类型为 `TaskResult`，作为流中的最后一项。一旦团队停止，终止条件就会重置。

注意
如果代理产生 `ModelClientStreamingChunkEvent`，则该消息将在流中产生，但不会包含在消息中。

参数：

task (str | BaseChatMessage | Sequence[BaseChatMessage] | None) – 用于运行团队的任务。可以是字符串、单个 `BaseChatMessage` 或 `BaseChatMessage` 列表。
cancellation_token (CancellationToken | None) – 用于立即终止任务的取消令牌。
设置取消令牌可能会使团队处于不一致状态，并且可能不会重置终止条件。
要正常停止团队，请改用 `ExternalTermination`。

返回：
stream – 一个 `AsyncGenerator`，它产生 `BaseAgentEvent`、`BaseChatMessage`，以及作为流中最后一项的最终结果 `TaskResult`。

使用 RoundRobinGroupChat 团队的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    stream = team.run_stream(task="Count from 1 to 10, respond one at a time.")
    async for message in stream:
        print(message)

    # 再次运行团队，不带任务以继续上一个任务。
    stream = team.run_stream()
    async for message in stream:
        print(message)


asyncio.run(main())
```

使用 CancellationToken 取消任务的示例：
```python
import asyncio
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.ui import Console
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_core import CancellationToken
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = MaxMessageTermination(3)
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)

    cancellation_token = CancellationToken()

    # 创建一个任务以在后台运行团队。
    run_task = asyncio.create_task(
        Console(
            team.run_stream(
                task="Count from 1 to 10, respond one at a time.",
                cancellation_token=cancellation_token,
            )
        )
    )

    # 等待 1 秒，然后取消任务。
    await asyncio.sleep(1)
    cancellation_token.cancel()

    # 这将引发一个取消错误。
    await run_task


asyncio.run(main())
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存群聊团队的状态。
通过在每个参与者和群聊管理器上使用其内部代理 ID 调用 `agent_save_state()` 方法来保存状态。
状态以嵌套字典的形式返回：一个键为 `agent_states` 的字典，其值为一个字典，其中代理名称为键，状态为值。
```json
{
    "agent_states": {
        "agent1": ...,
        "agent2": ...,
        "RoundRobinGroupChatManager": ...
    }
}
```

注意
从 v0.4.9 开始，状态使用代理名称作为键而不是代理 ID，并且从状态中删除了 `team_id` 字段。这是为了允许状态在不同的团队和运行时之间可移植。使用旧格式保存的状态将来可能与新格式不兼容。

警告
在团队运行时调用 `save_state()` 时，状态可能不一致，并可能导致意外状态。
建议在团队未运行或停止后调用此方法。

```python
pydantic model DiGraph[source]#
```

【中文翻译】基类：BaseModel
定义具有节点和边的有向图结构。
`GraphFlow` 使用它来确定执行顺序和条件。

警告
这是一项实验性功能，API 将在未来的版本中更改。

显示 JSON 架构
```json
{
   "title": "DiGraph",
   "description": "Defines a directed graph structure with nodes and edges.\n:class:`GraphFlow` uses this to determine execution order and conditions.\n\n.. warning::\n\n    This is an experimental feature, and the API will change in the future releases.",
   "type": "object",
   "properties": {
      "nodes": {
         "additionalProperties": {
            "$ref": "#/$defs/DiGraphNode"
         },
         "title": "Nodes",
         "type": "object"
      },
      "default_start_node": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Default Start Node"
      }
   },
   "$defs": {
      "DiGraphEdge": {
         "description": "Represents a directed edge in a :class:`DiGraph`, with an optional execution condition.\n\n.. warning::\n\n    This is an experimental feature, and the API will change in the future releases.",
         "properties": {
            "target": {
               "title": "Target",
               "type": "string"
            },
            "condition": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Condition"
            }
         },
         "required": [
            "target"
         ],
         "title": "DiGraphEdge",
         "type": "object"
      },
      "DiGraphNode": {
         "description": "Represents a node (agent) in a :class:`DiGraph`, with its outgoing edges and activation type.\n\n.. warning::\n\n    This is an experimental feature, and the API will change in the future releases.",
         "properties": {
            "name": {
               "title": "Name",
               "type": "string"
            },
            "edges": {
               "default": [],
               "items": {
                  "$ref": "#/$defs/DiGraphEdge"
               },
               "title": "Edges",
               "type": "array"
            },
            "activation": {
               "default": "all",
               "enum": [
                  "all",
                  "any"
               ],
               "title": "Activation",
               "type": "string"
            }
         },
         "required": [
            "name"
         ],
         "title": "DiGraphNode",
         "type": "object"
      }
   },
   "required": [
      "nodes"
   ]
}
```

字段：

default_start_node (str | None)
nodes (Dict[str, autogen_agentchat.teams._group_chat._graph._digraph_group_chat.DiGraphNode])

```python
field default_start_node: str | None = None#
```

```python
field nodes: Dict[str, DiGraphNode] [Required]#
```

```python
get_has_cycles() → bool[source]#
```

【中文翻译】指示图是否至少有一个循环（具有有效的退出条件）。

```python
get_leaf_nodes() → Set[str][source]#
```

【中文翻译】返回没有传出边的节点（最终输出节点）。

```python
get_parents() → Dict[str, List[str]][source]#
```

【中文翻译】计算每个节点到其父节点的映射。

```python
get_start_nodes() → Set[str][source]#
```

【中文翻译】返回没有传入边的节点（入口点）。

```python
graph_validate() → None[source]#
```

【中文翻译】验证图结构和执行规则。

```python
has_cycles_with_exit() → bool[source]#
```

【中文翻译】检查图是否具有任何循环，并验证每个循环是否至少具有一个条件边。

返回：
bool – 如果至少有一个循环并且所有循环都具有退出条件，则为 True。
如果没有循环，则为 False。

引发：
ValueError – 如果存在没有条件边的循环。

```python
model_post_init(context: Any, /) → None#
```

【中文翻译】此函数旨在像 BaseModel 方法一样初始化私有属性。
它接受 context 作为参数，因为这是 pydantic-core 在调用它时传递的内容。

参数：

self – BaseModel 实例。
context – 上下文。

```python
class DiGraphBuilder[source]#
```

【中文翻译】基类：object
一个用于构造 `GraphFlow` 中使用的 `DiGraph` 执行图的流畅构建器。

警告
这是一项实验性功能，API 将在未来的版本中更改。

此实用程序提供了一种以编程方式构建代理交互图的便捷方法，
包括复杂的执行流，例如：

顺序链
并行扇出
条件分支
具有安全出口的循环

图中的每个节点代表一个代理。边定义代理之间的执行路径，
并且可以选择性地以消息内容为条件。
构建器与 Graph 运行器兼容，并支持标准代理和过滤代理。

- `add_node(agent, activation)`
  向图中添加一个代理节点。

- `add_edge(source, target, condition)`
  （可选）使用条件连接两个节点。

- `add_conditional_edges(source, condition_to_target)`
  从源添加多个条件边。

- `set_entry_point(agent)`
  定义默认起始节点（可选）。

- `build()`
  生成经过验证的 `DiGraph`。

- `get_participants()`
  返回已添加代理的列表。

示例 — 顺序流 A → B → C：```python
>>> builder = GraphBuilder()
>>> builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
>>> builder.add_edge(agent_a, agent_b).add_edge(agent_b, agent_c)
>>> team = Graph(
...     participants=builder.get_participants(),
...     graph=builder.build(),
...     termination_condition=MaxMessageTermination(5),
... )
```

示例 — 并行扇出 A → (B, C)：```python
>>> builder = GraphBuilder()
>>> builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
>>> builder.add_edge(agent_a, agent_b).add_edge(agent_a, agent_c)
```

示例 — 条件分支 A → B (“yes”), A → C (“no”)：
```python
>>> builder = GraphBuilder()
>>> builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
>>> builder.add_conditional_edges(agent_a, {"yes": agent_b, "no": agent_c})
```

示例 — 循环：A → B → A (“loop”), B → C (“exit”)：
```python
>>> builder = GraphBuilder()
>>> builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
>>> builder.add_edge(agent_a, agent_b)
>>> builder.add_conditional_edges(agent_b, {"loop": agent_a, "exit": agent_c})
```

```python
add_conditional_edges(source: str | ChatAgent, condition_to_target: Dict[str, str | ChatAgent]) → DiGraphBuilder[source]#
```

【中文翻译】根据条件字符串从源节点添加多个条件边。

```python
add_edge(source: str | ChatAgent, target: str | ChatAgent, condition: str | None = None) → DiGraphBuilder[source]#
```

【中文翻译】从源到目标添加有向边，可选带条件。

```python
add_node(agent: ChatAgent, activation: Literal['all', 'any'] = 'all') → DiGraphBuilder[source]#
```

【中文翻译】向图中添加一个节点并注册其代理。

```python
build() → DiGraph[source]#
```

【中文翻译】构建并验证 DiGraph。

```python
get_participants() → list[ChatAgent][source]#
```

【中文翻译】按插入顺序返回构建器中的代理列表。

```python
set_entry_point(name: str | ChatAgent) → DiGraphBuilder[source]#
```

【中文翻译】设置图的默认起始节点。

```python
pydantic model DiGraphEdge[source]#
```

【中文翻译】基类：BaseModel
表示 `DiGraph` 中的有向边，带有可选的执行条件。

警告
这是一项实验性功能，API 将在未来的版本中更改。

显示 JSON 架构
```json
{
   "title": "DiGraphEdge",
   "description": "Represents a directed edge in a :class:`DiGraph`, with an optional execution condition.\n\n.. warning::\n\n    This is an experimental feature, and the API will change in the future releases.",
   "type": "object",
   "properties": {
      "target": {
         "title": "Target",
         "type": "string"
      },
      "condition": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Condition"
      }
   },
   "required": [
      "target"
   ]
}
```

字段：

condition (str | None)
target (str)

```python
field condition: str | None = None#
```

【中文翻译】（实验性）执行此边的条件。
如果为 None，则该边是无条件的。如果为字符串，则该边取决于最后一条代理聊天消息中是否存在该字符串。
注意：这是一项实验性功能，将来会更改，以允许更好地指定分支条件，类似于 `TerminationCondition` 类。

```python
field target: str [Required]#
```

```python
pydantic model DiGraphNode[source]#
```

【中文翻译】基类：BaseModel
表示 `DiGraph` 中的节点（代理），及其传出边和激活类型。

警告
这是一项实验性功能，API 将在未来的版本中更改。

显示 JSON 架构
```json
{
   "title": "DiGraphNode",
   "description": "Represents a node (agent) in a :class:`DiGraph`, with its outgoing edges and activation type.\n\n.. warning::\n\n    This is an experimental feature, and the API will change in the future releases.",
   "type": "object",
   "properties": {
      "name": {
         "title": "Name",
         "type": "string"
      },
      "edges": {
         "default": [],
         "items": {
            "$ref": "#/$defs/DiGraphEdge"
         },
         "title": "Edges",
         "type": "array"
      },
      "activation": {
         "default": "all",
         "enum": [
            "all",
            "any"
         ],
         "title": "Activation",
         "type": "string"
      }
   },
   "$defs": {
      "DiGraphEdge": {
         "description": "Represents a directed edge in a :class:`DiGraph`, with an optional execution condition.\n\n.. warning::\n\n    This is an experimental feature, and the API will change in the future releases.",
         "properties": {
            "target": {
               "title": "Target",
               "type": "string"
            },
            "condition": {
               "anyOf": [
                  {
                     "type": "string"
                  },
                  {
                     "type": "null"
                  }
               ],
               "default": null,
               "title": "Condition"
            }
         },
         "required": [
            "target"
         ],
         "title": "DiGraphEdge",
         "type": "object"
      }
   },
   "required": [
      "name"
   ]
}
```

字段：

activation (Literal['all', 'any'])
edges (List[autogen_agentchat.teams._group_chat._graph._digraph_group_chat.DiGraphEdge])
name (str)

```python
field activation: Literal['all', 'any'] = 'all'#
```

```python
field edges: List[DiGraphEdge] = []#
```

```python
field name: str [Required]#
```

```python
class GraphFlow(participants: List[ChatAgent], graph: DiGraph, termination_condition: TerminationCondition | None = None, max_turns: int | None = None, runtime: AgentRuntime | None = None, custom_message_types: List[type[BaseAgentEvent | BaseChatMessage]] | None = None)[source]#
```

【中文翻译】基类：BaseGroupChat, Component[GraphFlowConfig]
一个按照有向图执行模式运行群聊的团队。

警告
这是一项实验性功能，API 将在未来的版本中更改。

此群聊根据有向图 (DiGraph) 结构执行代理，
允许复杂的工作流，例如顺序执行、并行扇出、
条件分支、连接模式和具有显式退出条件的循环。
执行顺序由 DiGraph 中定义的边确定。图中的每个节点
对应一个代理，边定义代理之间的消息流。
可以配置节点在以下情况下激活：

所有父节点都已完成 (activation=”all”) → 默认
任何父节点完成 (activation=”any”)

使用边条件支持条件分支，其中根据聊天历史记录中的内容选择下一个代理。只要存在最终退出循环的条件，就允许循环。

注意
使用 `DiGraphBuilder` 类可以轻松创建 DiGraph。它提供了一个流畅的 API，用于添加节点和边、设置入口点以及验证图结构。
有关更多详细信息，请参阅 `DiGraphBuilder` 文档。
`GraphFlow` 类旨在与 `DiGraphBuilder` 一起使用以创建复杂的工作流。

参数：

participants (List[ChatAgent]) – 群聊的参与者。
termination_condition (TerminationCondition, 可选) – 聊天的终止条件。
max_turns (int, 可选) – 强制终止前的最大轮次数。
graph (DiGraph) – 定义节点流和条件的有向执行图。

引发：
ValueError – 如果参与者名称不唯一，或者图验证失败（例如，没有出口的循环）。

示例
顺序流：A → B → C
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import DiGraphBuilder, GraphFlow
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main():
    # 使用 OpenAI 模型客户端初始化代理。
    model_client = OpenAIChatCompletionClient(model="gpt-4.1-nano")
    agent_a = AssistantAgent("A", model_client=model_client, system_message="You are a helpful assistant.")
    agent_b = AssistantAgent("B", model_client=model_client, system_message="Translate input to Chinese.")
    agent_c = AssistantAgent("C", model_client=model_client, system_message="Translate input to English.")

    # 创建一个具有顺序流 A -> B -> C 的有向图。
    builder = DiGraphBuilder()
    builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
    builder.add_edge(agent_a, agent_b).add_edge(agent_b, agent_c)
    graph = builder.build()

    # 使用有向图创建一个 GraphFlow 团队。
    team = GraphFlow(
        participants=[agent_a, agent_b, agent_c],
        graph=graph,
        termination_condition=MaxMessageTermination(5),
    )

    # 运行团队并打印事件。
    async for event in team.run_stream(task="Write a short story about a cat."):
        print(event)


asyncio.run(main())
```

并行扇出：A → (B, C)
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import DiGraphBuilder, GraphFlow
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main():
    # 使用 OpenAI 模型客户端初始化代理。
    model_client = OpenAIChatCompletionClient(model="gpt-4.1-nano")
    agent_a = AssistantAgent("A", model_client=model_client, system_message="You are a helpful assistant.")
    agent_b = AssistantAgent("B", model_client=model_client, system_message="Translate input to Chinese.")
    agent_c = AssistantAgent("C", model_client=model_client, system_message="Translate input to Japanese.")

    # 创建一个具有扇出流 A -> (B, C) 的有向图。
    builder = DiGraphBuilder()
    builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
    builder.add_edge(agent_a, agent_b).add_edge(agent_a, agent_c)
    graph = builder.build()

    # 使用有向图创建一个 GraphFlow 团队。
    team = GraphFlow(
        participants=[agent_a, agent_b, agent_c],
        graph=graph,
        termination_condition=MaxMessageTermination(5),
    )

    # 运行团队并打印事件。
    async for event in team.run_stream(task="Write a short story about a cat."):
        print(event)


asyncio.run(main())
```

条件分支：A → B (如果 ‘yes’) 或 C (如果 ‘no’)
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import DiGraphBuilder, GraphFlow
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main():
    # 使用 OpenAI 模型客户端初始化代理。
    model_client = OpenAIChatCompletionClient(model="gpt-4.1-nano")
    agent_a = AssistantAgent(
        "A",
        model_client=model_client,
        system_message="Detect if the input is in Chinese. If it is, say 'yes', else say 'no', and nothing else.",
    )
    agent_b = AssistantAgent("B", model_client=model_client, system_message="Translate input to English.")
    agent_c = AssistantAgent("C", model_client=model_client, system_message="Translate input to Chinese.")

    # 创建一个具有条件分支流 A -> B ("yes"), A -> C ("no") 的有向图。
    builder = DiGraphBuilder()
    builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
    builder.add_edge(agent_a, agent_b, condition="yes")
    builder.add_edge(agent_a, agent_c, condition="no")
    graph = builder.build()

    # 使用有向图创建一个 GraphFlow 团队。
    team = GraphFlow(
        participants=[agent_a, agent_b, agent_c],
        graph=graph,
        termination_condition=MaxMessageTermination(5),
    )

    # 运行团队并打印事件。
    async for event in team.run_stream(task="AutoGen is a framework for building AI agents."):
        print(event)


asyncio.run(main())
```

带退出条件的循环：A → B → C (如果 ‘APPROVE’) 或 A (如果 ‘REJECT’)
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_agentchat.teams import DiGraphBuilder, GraphFlow
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main():
    # 使用 OpenAI 模型客户端初始化代理。
    model_client = OpenAIChatCompletionClient(model="gpt-4.1")
    agent_a = AssistantAgent(
        "A",
        model_client=model_client,
        system_message="You are a helpful assistant.",
    )
    agent_b = AssistantAgent(
        "B",
        model_client=model_client,
        system_message="Provide feedback on the input, if your feedback has been addressed, "
        "say 'APPROVE', else say 'REJECT' and provide a reason.",
    )
    agent_c = AssistantAgent(
        "C", model_client=model_client, system_message="Translate the final product to Korean."
    )

    # 创建一个带条件退出的循环图：A -> B -> C ("APPROVE"), B -> A ("REJECT")。
    builder = DiGraphBuilder()
    builder.add_node(agent_a).add_node(agent_b).add_node(agent_c)
    builder.add_edge(agent_a, agent_b)
    builder.add_conditional_edges(agent_b, {"APPROVE": agent_c, "REJECT": agent_a})
    builder.set_entry_point(agent_a)
    graph = builder.build()

    # 使用有向图创建一个 GraphFlow 团队。
    team = GraphFlow(
        participants=[agent_a, agent_b, agent_c],
        graph=graph,
        termination_condition=MaxMessageTermination(20),  # 最多 20 条消息以避免无限循环。
    )

    # 运行团队并打印事件。
    async for event in team.run_stream(task="Write a short poem about AI Agents."):
        print(event)


asyncio.run(main())
```

```python
component_config_schema#
```

【中文翻译】GraphFlowConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.teams.GraphFlow'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
class MagenticOneGroupChat(participants: List[ChatAgent], model_client: ChatCompletionClient, *, termination_condition: TerminationCondition | None = None, max_turns: int | None = 20, runtime: AgentRuntime | None = None, max_stalls: int = 3, final_answer_prompt: str = ORCHESTRATOR_FINAL_ANSWER_PROMPT, custom_message_types: List[type[BaseAgentEvent | BaseChatMessage]] | None = None, emit_team_events: bool = False)[source]#
```

【中文翻译】基类：BaseGroupChat, Component[MagenticOneGroupChatConfig]
一个由 `MagenticOneOrchestrator` 管理参与者的群聊团队。
编排器处理对话流，通过管理参与者的交互来确保任务高效完成。
编排器基于 Magentic-One 架构，这是一个用于解决复杂任务的通用多代理系统（请参阅下面的参考资料）。

参数：

participants (List[ChatAgent]) – 群聊的参与者。
model_client (ChatCompletionClient) – 用于生成响应的模型客户端。
termination_condition (TerminationCondition, 可选) – 群聊的终止条件。默认为 None。
如果没有终止条件，群聊将根据编排器逻辑运行或直到达到最大轮次数。
max_turns (int, 可选) – 群聊在停止前的最大轮次数。默认为 20。
max_stalls (int, 可选) – 重新规划前允许的最大停顿次数。默认为 3。
final_answer_prompt (str, 可选) – 用于从团队脚本生成最终答案或响应的 LLM 提示。提供了一个默认值（适用于 GPT-4o 类模型）。
custom_message_types (List[type[BaseAgentEvent | BaseChatMessage]], 可选) – 将在群聊中使用的自定义消息类型列表。
如果您正在使用自定义消息类型或您的代理产生自定义消息类型，则需要在此处指定它们。
确保您的自定义消息类型是 `BaseAgentEvent` 或 `BaseChatMessage` 的子类。
emit_team_events (bool, 可选) – 是否通过 `BaseGroupChat.run_stream()` 发出团队事件。默认为 False。

引发：
ValueError – 如果进度分类帐缺少必需的键或下一个发言人无效，则在编排逻辑中。

示例：
带有一个助手代理的 MagenticOneGroupChat：
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import MagenticOneGroupChat
from autogen_agentchat.ui import Console


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    assistant = AssistantAgent(
        "Assistant",
        model_client=model_client,
    )
    team = MagenticOneGroupChat([assistant], model_client=model_client)
    await Console(team.run_stream(task="Provide a different proof to Fermat last theorem"))


asyncio.run(main())
```

参考文献
如果您在工作中使用 MagenticOneGroupChat，请引用以下论文：
```
@article{fourney2024magentic,
    title={Magentic-one: A generalist multi-agent system for solving complex tasks},
    author={Fourney, Adam and Bansal, Gagan and Mozannar, Hussein and Tan, Cheng and Salinas, Eduardo and Niedtner, Friederike and Proebsting, Grace and Bassman, Griffin and Gerrits, Jack and Alber, Jacob and others},
    journal={arXiv preprint arXiv:2411.04468},
    year={2024}
}
```

```python
classmethod _from_config(config: MagenticOneGroupChatConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → MagenticOneGroupChatConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】MagenticOneGroupChatConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.teams.MagenticOneGroupChat'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
class RoundRobinGroupChat(participants: List[ChatAgent], termination_condition: TerminationCondition | None = None, max_turns: int | None = None, runtime: AgentRuntime | None = None, custom_message_types: List[type[BaseAgentEvent | BaseChatMessage]] | None = None, emit_team_events: bool = False)[source]#
```

【中文翻译】基类：BaseGroupChat, Component[RoundRobinGroupChatConfig]
一个团队，以轮询方式让参与者轮流向所有人发布消息来运行群聊。
如果团队中只有一个参与者，则该参与者将是唯一的发言人。

参数：

participants (List[BaseChatAgent]) – 群聊的参与者。
termination_condition (TerminationCondition, 可选) – 群聊的终止条件。默认为 None。
如果没有终止条件，群聊将无限期运行。
max_turns (int, 可选) – 群聊在停止前的最大轮次数。默认为 None，表示没有限制。
custom_message_types (List[type[BaseAgentEvent | BaseChatMessage]], 可选) – 将在群聊中使用的自定义消息类型列表。
如果您正在使用自定义消息类型或您的代理产生自定义消息类型，则需要在此处指定它们。
确保您的自定义消息类型是 `BaseAgentEvent` 或 `BaseChatMessage` 的子类。
emit_team_events (bool, 可选) – 是否通过 `BaseGroupChat.run_stream()` 发出团队事件。默认为 False。

引发：
ValueError – 如果未提供参与者或参与者名称不唯一。

示例：
带工具的单个参与者团队：
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.conditions import TextMentionTermination
from autogen_agentchat.ui import Console


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    async def get_weather(location: str) -> str:
        return f"The weather in {location} is sunny."

    assistant = AssistantAgent(
        "Assistant",
        model_client=model_client,
        tools=[get_weather],
    )
    termination = TextMentionTermination("TERMINATE")
    team = RoundRobinGroupChat([assistant], termination_condition=termination)
    await Console(team.run_stream(task="What's the weather in New York?"))


asyncio.run(main())
```

具有多个参与者的团队：
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.conditions import TextMentionTermination
from autogen_agentchat.ui import Console


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent("Assistant1", model_client=model_client)
    agent2 = AssistantAgent("Assistant2", model_client=model_client)
    termination = TextMentionTermination("TERMINATE")
    team = RoundRobinGroupChat([agent1, agent2], termination_condition=termination)
    await Console(team.run_stream(task="Tell me some jokes."))


asyncio.run(main())
```

```python
classmethod _from_config(config: RoundRobinGroupChatConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → RoundRobinGroupChatConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】RoundRobinGroupChatConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.teams.RoundRobinGroupChat'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
class SelectorGroupChat(participants: List[ChatAgent], model_client: ChatCompletionClient, *, termination_condition: TerminationCondition | None = None, max_turns: int | None = None, runtime: AgentRuntime | None = None, selector_prompt: str = 'You are in a role play game. The following roles are available:\n{roles}.\nRead the following conversation. Then select the next role from {participants} to play. Only return the role.\n\n{history}\n\nRead the above conversation. Then select the next role from {participants} to play. Only return the role.\n', allow_repeated_speaker: bool = False, max_selector_attempts: int = 3, selector_func: Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], str | None] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[str | None]] | None = None, candidate_func: Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], List[str]] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[List[str]]] | None = None, custom_message_types: List[type[BaseAgentEvent | BaseChatMessage]] | None = None, emit_team_events: bool = False, model_client_streaming: bool = False)[source]#
```

【中文翻译】基类：BaseGroupChat, Component[SelectorGroupChatConfig]
一个群聊团队，其参与者轮流向所有人发布消息，并在每条消息后使用 `ChatCompletion` 模型选择下一个发言人。

参数：

participants (List[ChatAgent]) – 群聊的参与者，
必须具有唯一的名称并且至少有两名参与者。
model_client (ChatCompletionClient) – 用于选择下一个发言人的 `ChatCompletion` 模型客户端。
termination_condition (TerminationCondition, 可选) – 群聊的终止条件。默认为 None。
如果没有终止条件，群聊将无限期运行。
max_turns (int, 可选) – 群聊在停止前的最大轮次数。默认为 None，表示没有限制。
selector_prompt (str, 可选) – 用于选择下一个发言人的提示模板。
可用字段：‘{roles}’、‘{participants}’ 和 ‘{history}’。
{participants} 是供选择的候选人姓名。格式为 [“<name1>”, “<name2>”, …]。
{roles} 是候选代理的名称和描述的换行分隔列表。每行的格式为：“<name> : <description>”。
{history} 是对话历史记录，格式为名称和消息内容的双换行分隔。每条消息的格式为：“<name> : <message content>”。
allow_repeated_speaker (bool, 可选) – 是否在下一轮选择的候选人列表中包含先前的发言人。
默认为 False。模型仍可能选择先前的发言人——如果发生这种情况，将记录一条警告。
max_selector_attempts (int, 可选) – 使用模型选择发言人的最大尝试次数。默认为 3。
如果模型在最大尝试次数后未能选择发言人，则将使用先前的发言人（如果可用），
否则将使用第一个参与者。
selector_func (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], str | None], Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[str | None]], 可选) – 一个自定义选择器函数，它接受对话历史记录并返回下一个发言人的姓名。
如果提供，此函数将用于覆盖模型以选择下一个发言人。
如果函数返回 None，则将使用模型选择下一个发言人。
candidate_func (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], List[str]], Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[List[str]]], 可选) – 一个自定义函数，它接受对话历史记录并返回使用模型进行下一次发言人选择的候选人过滤列表。如果函数返回空列表或 None，`SelectorGroupChat` 将引发 ValueError。
仅当未设置 `selector_func` 时才使用此函数。如果设置了 `allow_repeated_speaker`，它将被忽略。
custom_message_types (List[type[BaseAgentEvent | BaseChatMessage]], 可选) – 将在群聊中使用的自定义消息类型列表。
如果您正在使用自定义消息类型或您的代理产生自定义消息类型，则需要在此处指定它们。
确保您的自定义消息类型是 `BaseAgentEvent` 或 `BaseChatMessage` 的子类。
emit_team_events (bool, 可选) – 是否通过 `BaseGroupChat.run_stream()` 发出团队事件。默认为 False。
model_client_streaming (bool, 可选) – 是否对模型客户端使用流式处理。（这对于像 QwQ 这样的推理模型很有用）。默认为 False。

引发：
ValueError – 如果参与者数量少于两个或选择器提示无效。

示例：
具有多个参与者的团队：
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import SelectorGroupChat
from autogen_agentchat.conditions import TextMentionTermination
from autogen_agentchat.ui import Console


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    async def lookup_hotel(location: str) -> str:
        return f"Here are some hotels in {location}: hotel1, hotel2, hotel3."

    async def lookup_flight(origin: str, destination: str) -> str:
        return f"Here are some flights from {origin} to {destination}: flight1, flight2, flight3."

    async def book_trip() -> str:
        return "Your trip is booked!"

    travel_advisor = AssistantAgent(
        "Travel_Advisor",
        model_client,
        tools=[book_trip],
        description="Helps with travel planning.",
    )
    hotel_agent = AssistantAgent(
        "Hotel_Agent",
        model_client,
        tools=[lookup_hotel],
        description="Helps with hotel booking.",
    )
    flight_agent = AssistantAgent(
        "Flight_Agent",
        model_client,
        tools=[lookup_flight],
        description="Helps with flight booking.",
    )
    termination = TextMentionTermination("TERMINATE")
    team = SelectorGroupChat(
        [travel_advisor, hotel_agent, flight_agent],
        model_client=model_client,
        termination_condition=termination,
    )
    await Console(team.run_stream(task="Book a 3-day trip to new york."))


asyncio.run(main())
```

具有自定义选择器函数的团队：
```python
import asyncio
from typing import Sequence
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import SelectorGroupChat
from autogen_agentchat.conditions import TextMentionTermination
from autogen_agentchat.ui import Console
from autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    def check_calculation(x: int, y: int, answer: int) -> str:
        if x + y == answer:
            return "Correct!"
        else:
            return "Incorrect!"

    agent1 = AssistantAgent(
        "Agent1",
        model_client,
        description="For calculation",
        system_message="Calculate the sum of two numbers",
    )
    agent2 = AssistantAgent(
        "Agent2",
        model_client,
        tools=[check_calculation],
        description="For checking calculation",
        system_message="Check the answer and respond with 'Correct!' or 'Incorrect!'",
    )

    def selector_func(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> str | None:
        if len(messages) == 1 or messages[-1].to_text() == "Incorrect!":
            return "Agent1"
        if messages[-1].source == "Agent1":
            return "Agent2"
        return None

    termination = TextMentionTermination("Correct!")
    team = SelectorGroupChat(
        [agent1, agent2],
        model_client=model_client,
        selector_func=selector_func,
        termination_condition=termination,
    )

    await Console(team.run_stream(task="What is 1 + 1?"))


asyncio.run(main())
```

```python
classmethod _from_config(config: SelectorGroupChatConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → SelectorGroupChatConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】SelectorGroupChatConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.teams.SelectorGroupChat'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
class Swarm(participants: List[ChatAgent], termination_condition: TerminationCondition | None = None, max_turns: int | None = None, runtime: AgentRuntime | None = None, custom_message_types: List[type[BaseAgentEvent | BaseChatMessage]] | None = None, emit_team_events: bool = False)[source]#
```

【中文翻译】基类：BaseGroupChat, Component[SwarmConfig]
一个群聊团队，仅根据移交消息选择下一个发言人。
参与者列表中的第一个参与者是初始发言人。
下一个发言人根据当前发言人发送的 `HandoffMessage` 消息选择。如果没有发送移交消息，则当前发言人继续发言。

参数：

participants (List[ChatAgent]) – 参与群聊的代理。列表中的第一个代理是初始发言人。
termination_condition (TerminationCondition, 可选) – 群聊的终止条件。默认为 None。
如果没有终止条件，群聊将无限期运行。
max_turns (int, 可选) – 群聊在停止前的最大轮次数。默认为 None，表示没有限制。
custom_message_types (List[type[BaseAgentEvent | BaseChatMessage]], 可选) – 将在群聊中使用的自定义消息类型列表。
如果您正在使用自定义消息类型或您的代理产生自定义消息类型，则需要在此处指定它们。
确保您的自定义消息类型是 `BaseAgentEvent` 或 `BaseChatMessage` 的子类。
emit_team_events (bool, 可选) – 是否通过 `BaseGroupChat.run_stream()` 发出团队事件。默认为 False。

基本示例：
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import Swarm
from autogen_agentchat.conditions import MaxMessageTermination


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent1 = AssistantAgent(
        "Alice",
        model_client=model_client,
        handoffs=["Bob"],
        system_message="You are Alice and you only answer questions about yourself.",
    )
    agent2 = AssistantAgent(
        "Bob", model_client=model_client, system_message="You are Bob and your birthday is on 1st January."
    )

    termination = MaxMessageTermination(3)
    team = Swarm([agent1, agent2], termination_condition=termination)

    stream = team.run_stream(task="What is bob's birthday?")
    async for message in stream:
        print(message)


asyncio.run(main())
```

使用 `HandoffTermination` 进行人机协作移交：
```python
import asyncio
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import Swarm
from autogen_agentchat.conditions import HandoffTermination, MaxMessageTermination
from autogen_agentchat.ui import Console
from autogen_agentchat.messages import HandoffMessage


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4o")

    agent = AssistantAgent(
        "Alice",
        model_client=model_client,
        handoffs=["user"],
        system_message="You are Alice and you only answer questions about yourself, ask the user for help if needed.",
    )
    termination = HandoffTermination(target="user") | MaxMessageTermination(3)
    team = Swarm([agent], termination_condition=termination)

    # 开始对话。
    await Console(team.run_stream(task="What is bob's birthday?"))

    # 使用用户反馈恢复。
    await Console(
        team.run_stream(
            task=HandoffMessage(source="user", target="Alice", content="Bob's birthday is on 1st January.")
        )
    )


asyncio.run(main())
```

```python
classmethod _from_config(config: SwarmConfig) → Swarm[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → SwarmConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】SwarmConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.teams.Swarm'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

【中文翻译】此模块提供了各种预定义多代理团队的实现。
每个团队都从 `BaseGroupChat` 类继承。

【中文翻译】上一页

【中文翻译】autogen_agentchat.tools

【中文翻译】下一页

【中文翻译】autogen_agentchat.base

### autogen_agentchat.tools {autogen_agentchattools}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.tools.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.tools.html)

```python
class AgentTool(agent: BaseChatAgent)[source]#
```

【中文翻译】基类：TaskRunnerTool, Component[AgentToolConfig]
可用于使用代理运行任务的工具。
该工具将任务执行的结果作为 `TaskResult` 对象返回。

参数：
agent (BaseChatAgent) – 用于运行任务的代理。

示例
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.tools import AgentTool
from autogen_agentchat.ui import Console
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4")
    writer = AssistantAgent(
        name="writer",
        description="A writer agent for generating text.",
        model_client=model_client,
        system_message="Write well.",
    )
    writer_tool = AgentTool(agent=writer)
    assistant = AssistantAgent(
        name="assistant",
        model_client=model_client,
        tools=[writer_tool],
        system_message="You are a helpful assistant.",
    )
    await Console(assistant.run_stream(task="Write a poem about the sea."))


asyncio.run(main())
```

```python
classmethod _from_config(config: AgentToolConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → AgentToolConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】AgentToolConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.tools.AgentTool'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
class TeamTool(team: BaseGroupChat, name: str, description: str)[source]#
```

【中文翻译】基类：TaskRunnerTool, Component[TeamToolConfig]
可用于运行任务的工具。
该工具将任务执行的结果作为 `TaskResult` 对象返回。

参数：

team (BaseGroupChat) – 用于运行任务的团队。
name (str) – 工具的名称。
description (str) – 工具的描述。

```python
classmethod _from_config(config: TeamToolConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TeamToolConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TeamToolConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.tools.TeamTool'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

【中文翻译】上一页

【中文翻译】autogen_agentchat.agents

【中文翻译】下一页

【中文翻译】autogen_agentchat.teams

### autogen_agentchat.tools {autogen_agentchattools}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.tools.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.tools.html)

```python
class AgentTool(agent: BaseChatAgent)[source]#
```

【中文翻译】基类：TaskRunnerTool, Component[AgentToolConfig]
可用于使用代理运行任务的工具。
该工具将任务执行的结果作为 `TaskResult` 对象返回。

参数：
agent (BaseChatAgent) – 用于运行任务的代理。

示例
```python
import asyncio

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.tools import AgentTool
from autogen_agentchat.ui import Console
from autogen_ext.models.openai import OpenAIChatCompletionClient


async def main() -> None:
    model_client = OpenAIChatCompletionClient(model="gpt-4")
    writer = AssistantAgent(
        name="writer",
        description="A writer agent for generating text.",
        model_client=model_client,
        system_message="Write well.",
    )
    writer_tool = AgentTool(agent=writer)
    assistant = AssistantAgent(
        name="assistant",
        model_client=model_client,
        tools=[writer_tool],
        system_message="You are a helpful assistant.",
    )
    await Console(assistant.run_stream(task="Write a poem about the sea."))


asyncio.run(main())
```

```python
classmethod _from_config(config: AgentToolConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → AgentToolConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】AgentToolConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_agentchat.tools.AgentTool'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
class TeamTool(team: BaseGroupChat, name: str, description: str)[source]#
```

【中文翻译】基类：TaskRunnerTool, Component[TeamToolConfig]
可用于运行任务的工具。
该工具将任务执行的结果作为 `TaskResult` 对象返回。

参数：

team (BaseGroupChat) – 用于运行任务的团队。
name (str) – 工具的名称。
description (str) – 工具的描述。

```python
classmethod _from_config(config: TeamToolConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
_to_config() → TeamToolConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
component_config_schema#
```

【中文翻译】TeamToolConfig 的别名

```python
component_provider_override: ClassVar[str | None] = 'autogen_ext.tools.TeamTool'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

【中文翻译】上一页

【中文翻译】autogen_agentchat.agents

【中文翻译】下一页

【中文翻译】autogen_agentchat.teams

### autogen_agentchat.ui {autogen_agentchatui}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.ui.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.ui.html)

```python
async Console(stream: AsyncGenerator[BaseAgentEvent | BaseChatMessage | T, None], *, no_inline_images: bool = False, output_stats: bool = False, user_input_manager: UserInputManager | None = None) → T[source]#
```

【中文翻译】使用来自 `run_stream()` 或 `on_messages_stream()` 的消息流，并将消息呈现到控制台。
返回最后处理的 `TaskResult` 或 `Response`。

注意
`output_stats` 是实验性的，统计数据可能不准确。
它将在未来的版本中得到改进。

参数：

stream (AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None] | AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None]) – 要呈现的消息流。
这可以来自 `run_stream()` 或 `on_messages_stream()`。
no_inline_images (bool, 可选) – 如果终端是 iTerm2，则将内联呈现图像。使用此选项可禁用此行为。默认为 False。
output_stats (bool, 可选) – （实验性）如果为 True，将输出消息摘要和内联令牌使用信息。默认为 False。

返回：
last_processed – 如果流来自 `run_stream()`，则为 `TaskResult`；如果流来自 `on_messages_stream()`，则为 `Response`。

```python
class UserInputManager(callback: Callable[[str], str] | Callable[[str, CancellationToken | None], Awaitable[str]])[source]#
```

【中文翻译】基类：object

```python
get_wrapped_callback() → Callable[[str, CancellationToken | None], Awaitable[str]][source]#
```

```python
notify_event_received(request_id: str) → None[source]#
```

【中文翻译】此模块实现了用于格式化/打印代理消息的实用程序类。

【中文翻译】上一页

【中文翻译】autogen_agentchat.conditions

【中文翻译】下一页

【中文翻译】autogen_agentchat.state

### autogen_agentchat.ui {autogen_agentchatui}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.ui.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.ui.html)

```python
async Console(stream: AsyncGenerator[BaseAgentEvent | BaseChatMessage | T, None], *, no_inline_images: bool = False, output_stats: bool = False, user_input_manager: UserInputManager | None = None) → T[source]#
```

【中文翻译】使用来自 `run_stream()` 或 `on_messages_stream()` 的消息流，并将消息呈现到控制台。
返回最后处理的 `TaskResult` 或 `Response`。

注意
`output_stats` 是实验性的，统计数据可能不准确。
它将在未来的版本中得到改进。

参数：

stream (AsyncGenerator[BaseAgentEvent | BaseChatMessage | TaskResult, None] | AsyncGenerator[BaseAgentEvent | BaseChatMessage | Response, None]) – 要呈现的消息流。
这可以来自 `run_stream()` 或 `on_messages_stream()`。
no_inline_images (bool, 可选) – 如果终端是 iTerm2，则将内联呈现图像。使用此选项可禁用此行为。默认为 False。
output_stats (bool, 可选) – （实验性）如果为 True，将输出消息摘要和内联令牌使用信息。默认为 False。

返回：
last_processed – 如果流来自 `run_stream()`，则为 `TaskResult`；如果流来自 `on_messages_stream()`，则为 `Response`。

```python
class UserInputManager(callback: Callable[[str], str] | Callable[[str, CancellationToken | None], Awaitable[str]])[source]#
```

【中文翻译】基类：object

```python
get_wrapped_callback() → Callable[[str, CancellationToken | None], Awaitable[str]][source]#
```

```python
notify_event_received(request_id: str) → None[source]#
```

【中文翻译】此模块实现了用于格式化/打印代理消息的实用程序类。

【中文翻译】上一页

【中文翻译】autogen_agentchat.conditions

【中文翻译】下一页

【中文翻译】autogen_agentchat.state

### next
autogen_agentchat {next-autogen_agentchat}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_agentchat.html)

```python
EVENT_LOGGER_NAME = 'autogen_agentchat.events'#
```

【中文翻译】事件日志的记录器名称。

```python
TRACE_LOGGER_NAME = 'autogen_agentchat'#
```

【中文翻译】跟踪日志的记录器名称。

【中文翻译】此模块提供了 autogen_agentchat 包的主要入口点。
它包括跟踪和事件日志的记录器名称，并检索包版本。

【中文翻译】上一页

【中文翻译】API 参考

【中文翻译】下一页

【中文翻译】autogen_agentchat.messages

## 其他 API 参考 {other-api-references}

【中文翻译】其他 API 参考模块。

### autogen_core {autogen_core}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html)

```python
class Agent(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol

```python
property metadata: AgentMetadata#
```

【中文翻译】代理的元数据。

```python
property id: AgentId#
```

【中文翻译】代理的 ID。

```python
async on_message(message: Any, ctx: MessageContext) → Any[source]#
```

【中文翻译】代理的消息处理程序。此方法只能由运行时调用，不能由其他代理调用。

参数：

message (Any) – 收到的消息。类型是订阅中的类型之一。
ctx (MessageContext) – 消息的上下文。

返回：
Any – 对消息的响应。可以为 None。

引发：

CancelledError – 如果消息已取消。
CantHandleException – 如果代理无法处理消息。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理的状态。结果必须是可 JSON 序列化的。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载从 `save_state` 获取的代理状态。

参数：
state (Mapping[str, Any]) – 代理的状态。必须是可 JSON 序列化的。

```python
async close() → None[source]#
```

【中文翻译】当运行时关闭时调用

```python
class AgentId(type: str | AgentType, key: str)[source]#
```

【中文翻译】基类：object
Agent ID 在代理运行时（包括分布式运行时）中唯一标识代理实例。它是代理实例接收消息的“地址”。
有关更多信息，请参阅此处：代理身份和生命周期

```python
classmethod from_str(agent_id: str) → Self[source]#
```

【中文翻译】将格式为 `type/key` 的字符串转换为 `AgentId`

```python
property type: str#
```

【中文翻译】将代理与特定工厂函数关联的标识符。
字符串只能由字母数字字符 (a-z) 和 (0-9) 或下划线 (_) 组成。

```python
property key: str#
```

【中文翻译】代理实例标识符。
字符串只能由字母数字字符 (a-z) 和 (0-9) 或下划线 (_) 组成。

```python
class AgentProxy(agent: AgentId, runtime: AgentRuntime)[source]#
```

【中文翻译】基类：object
一个帮助程序类，允许您使用 `AgentId` 代替其关联的代理

```python
property id: AgentId#
```

【中文翻译】此代理的目标代理

```python
property metadata: Awaitable[AgentMetadata]#
```

【中文翻译】代理的元数据。

```python
async send_message(message: Any, *, sender: AgentId, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理的状态。结果必须是可 JSON 序列化的。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载从 `save_state` 获取的代理状态。

参数：
state (Mapping[str, Any]) – 代理的状态。必须是可 JSON 序列化的。

```python
class AgentMetadata[source]#
```

【中文翻译】基类：TypedDict

```python
type: str#
```

```python
key: str#
```

```python
description: str#
```

```python
class AgentRuntime(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol

```python
async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

【中文翻译】向代理发送消息并获取响应。

参数：

message (Any) – 要发送的消息。
recipient (AgentId) – 要向其发送消息的代理。
sender (AgentId | None, 可选) – 发送消息的代理。如果此消息不是从任何代理发送的（例如直接从外部发送到运行时），则只能为 None。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。

引发：

CantHandleException – 如果接收方无法处理消息。
UndeliverableException – 如果消息无法传递。
Other – 接收方引发的任何其他异常。

返回：
Any – 来自代理的响应。

```python
async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]#
```

【中文翻译】向给定命名空间中的所有代理发布消息，如果未提供命名空间，则向发送方的命名空间发布消息。
发布预计不会有响应。

参数：

message (Any) – 要发布的消息。
topic_id (TopicId) – 要向其发布消息的主题。
sender (AgentId | None, 可选) – 发送消息的代理。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。
message_id (str | None, 可选) – 消息 ID。如果为 None，将生成新的消息 ID。默认为 None。此消息 ID 必须唯一，并且建议使用 UUID。

引发：
UndeliverableException – 如果消息无法传递。

```python
async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]#
```

【中文翻译】向与特定类型关联的运行时注册代理工厂。类型必须唯一。此 API 不添加任何订阅。

注意
这是一个低级 API，通常应改用代理类的 `register` 方法，因为这也会自动处理订阅。

示例：
```python
from dataclasses import dataclass

from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event
from autogen_core.models import UserMessage


@dataclass
class MyMessage:
    content: str


class MyAgent(RoutedAgent):
    def __init__(self) -> None:
        super().__init__("My core agent")

    @event
    async def handler(self, message: UserMessage, context: MessageContext) -> None:
        print("Event received: ", message.content)


async def my_agent_factory():
    return MyAgent()


async def main() -> None:
    runtime: AgentRuntime = ...  # type: ignore
    await runtime.register_factory("my_agent", lambda: MyAgent())


import asyncio

asyncio.run(main())
```

参数：

type (str) – 此工厂创建的代理类型。它与代理类名不同。类型参数用于区分不同的工厂函数而不是代理类。
agent_factory (Callable[[], T]) – 创建代理的工厂，其中 T 是具体的代理类型。在工厂内部，使用 `autogen_core.AgentInstantiationContext` 访问诸如当前运行时和代理 ID 之类的变量。
expected_class (type[T] | None, 可选) – 代理的预期类，用于工厂的运行时验证。默认为 None。如果为 None，则不执行验证。

```python
async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]#
```

【中文翻译】尝试按名称和命名空间获取基础代理实例。通常不鼓励这样做（因此名称很长），但在某些情况下可能很有用。
如果基础代理不可访问，则会引发异常。

参数：

id (AgentId) – 代理 ID。
type (Type[T], 可选) – 代理的预期类型。默认为 Agent。

返回：
T – 具体的代理实例。

引发：

LookupError – 如果未找到代理。
NotAccessibleError – 如果代理不可访问，例如它位于远程位置。
TypeError – 如果代理不是预期类型。

```python
async get(id: AgentId, /, *, lazy: bool = True) → AgentId[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存整个运行时的状态，包括所有托管代理。恢复状态的唯一方法是将其传递给 `load_state()`。
状态的结构由实现定义，可以是任何可 JSON 序列化的对象。

返回：
Mapping[str, Any] – 保存的状态。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载整个运行时的状态，包括所有托管代理。状态应与 `save_state()` 返回的状态相同。

参数：
state (Mapping[str, Any]) – 保存的状态。

```python
async agent_metadata(agent: AgentId) → AgentMetadata[source]#
```

【中文翻译】获取代理的元数据。

参数：
agent (AgentId) – 代理 ID。

返回：
AgentMetadata – 代理元数据。

```python
async agent_save_state(agent: AgentId) → Mapping[str, Any][source]#
```

【中文翻译】保存单个代理的状态。
状态的结构由实现定义，可以是任何可 JSON 序列化的对象。

参数：
agent (AgentId) – 代理 ID。

返回：
Mapping[str, Any] – 保存的状态。

```python
async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载单个代理的状态。

参数：

agent (AgentId) – 代理 ID。
state (Mapping[str, Any]) – 保存的状态。

```python
async add_subscription(subscription: Subscription) → None[source]#
```

【中文翻译】添加一个新的订阅，运行时在处理已发布消息时应满足该订阅

参数：
subscription (Subscription) – 要添加的订阅

```python
async remove_subscription(id: str) → None[source]#
```

【中文翻译】从运行时中删除订阅

参数：
id (str) – 要删除的订阅的 ID

引发：
LookupError – 如果订阅不存在

```python
add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]#
```

【中文翻译】向运行时添加新的消息序列化序列化器
注意：这将根据 `type_name` 和 `data_content_type` 属性对序列化器进行重复数据删除

参数：
serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – 要添加的序列化器

```python
class BaseAgent(description: str)[source]#
```

【中文翻译】基类：ABC, Agent

```python
property metadata: AgentMetadata#
```

【中文翻译】代理的元数据。

```python
property type: str#
```

```python
property id: AgentId#
```

【中文翻译】代理的 ID。

```python
property runtime: AgentRuntime#
```

```python
final async on_message(message: Any, ctx: MessageContext) → Any[source]#
```

【中文翻译】代理的消息处理程序。此方法只能由运行时调用，不能由其他代理调用。

参数：

message (Any) – 收到的消息。类型是订阅中的类型之一。
ctx (MessageContext) – 消息的上下文。

返回：
Any – 对消息的响应。可以为 None。

引发：

CancelledError – 如果消息已取消。
CantHandleException – 如果代理无法处理消息。

```python
abstract async on_message_impl(message: Any, ctx: MessageContext) → Any[source]#
```

```python
async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

【中文翻译】有关更多信息，请参阅 `autogen_core.AgentRuntime.send_message()`。

```python
async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理的状态。结果必须是可 JSON 序列化的。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载从 `save_state` 获取的代理状态。

参数：
state (Mapping[str, Any]) – 代理的状态。必须是可 JSON 序列化的。

```python
async close() → None[source]#
```

【中文翻译】当运行时关闭时调用

```python
async classmethod register(runtime: AgentRuntime, type: str, factory: Callable[[], Self | Awaitable[Self]], *, skip_class_subscriptions: bool = False, skip_direct_message_subscription: bool = False) → AgentType[source]#
```

【中文翻译】注册 ABC 的虚拟子类。
返回子类，以允许用作类装饰器。

```python
class CacheStore[source]#
```

【中文翻译】基类：ABC, Generic[T], ComponentBase[BaseModel]
此协议定义了存储/缓存操作的基本接口。
子类应处理基础存储的生命周期。

```python
component_type: ClassVar[ComponentType] = 'cache_store'#
```

【中文翻译】组件的逻辑类型。

```python
abstract get(key: str, default: T | None = None) → T | None[source]#
```

【中文翻译】从存储中检索项目。

参数：

key – 存储中标识项目的键。
default (可选) – 如果未找到键，则返回的默认值。
默认为 None。

返回：
如果找到，则为与键关联的值，否则为默认值。

```python
abstract set(key: str, value: T) → None[source]#
```

【中文翻译】在存储中设置项目。

参数：

key – 要存储项目的键。
value – 要存储在存储中的值。

```python
class InMemoryStore[source]#
```

【中文翻译】基类：CacheStore[T], Component[InMemoryStoreConfig]

```python
component_provider_override: ClassVar[str | None] = 'autogen_core.InMemoryStore'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_config_schema#
```

【中文翻译】InMemoryStoreConfig 的别名

```python
get(key: str, default: T | None = None) → T | None[source]#
```

【中文翻译】从存储中检索项目。

参数：

key – 存储中标识项目的键。
default (可选) – 如果未找到键，则返回的默认值。
默认为 None。

返回：
如果找到，则为与键关联的值，否则为默认值。

```python
set(key: str, value: T) → None[source]#
```

【中文翻译】在存储中设置项目。

参数：

key – 要存储项目的键。
value – 要存储在存储中的值。

```python
_to_config() → InMemoryStoreConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
classmethod _from_config(config: InMemoryStoreConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
class CancellationToken[source]#
```

【中文翻译】基类：object
用于取消挂起异步调用的令牌

```python
cancel() → None[source]#
```

【中文翻译】取消链接到此取消令牌的挂起异步调用。

```python
is_cancelled() → bool[source]#
```

【中文翻译】检查是否已使用 CancellationToken

```python
add_callback(callback: Callable[[], None]) → None[source]#
```

【中文翻译】附加一个在调用 cancel 时将调用的回调

```python
link_future(future: Future[Any]) → Future[Any][source]#
```

【中文翻译】将挂起的异步调用链接到令牌以允许其取消

```python
class AgentInstantiationContext[source]#
```

【中文翻译】基类：object
一个提供代理实例化上下文的静态类。
此静态类可用于在代理实例化期间（在工厂函数或代理的类构造函数内部）访问当前运行时和代理 ID。

示例
在工厂函数和代理的构造函数内部获取当前运行时和代理 ID：
```python
import asyncio
from dataclasses import dataclass

from autogen_core import (
    AgentId,
    AgentInstantiationContext,
    MessageContext,
    RoutedAgent,
    SingleThreadedAgentRuntime,
    message_handler,
)


@dataclass
class TestMessage:
    content: str


class TestAgent(RoutedAgent):
    def __init__(self, description: str):
        super().__init__(description)
        # 获取当前运行时——我们在这里不使用它，但它是可用的。
        _ = AgentInstantiationContext.current_runtime()
        # 获取当前代理 ID。
        agent_id = AgentInstantiationContext.current_agent_id()
        print(f"Current AgentID from constructor: {agent_id}")

    @message_handler
    async def handle_test_message(self, message: TestMessage, ctx: MessageContext) -> None:
        print(f"Received message: {message.content}")


def test_agent_factory() -> TestAgent:
    # 获取当前运行时——我们在这里不使用它，但它是可用的。
    _ = AgentInstantiationContext.current_runtime()
    # 获取当前代理 ID。
    agent_id = AgentInstantiationContext.current_agent_id()
    print(f"Current AgentID from factory: {agent_id}")
    return TestAgent(description="Test agent")


async def main() -> None:
    # 创建一个 SingleThreadedAgentRuntime 实例。
    runtime = SingleThreadedAgentRuntime()

    # 启动运行时。
    runtime.start()

    # 使用工厂函数注册代理类型。
    await runtime.register_factory("test_agent", test_agent_factory)

    # 向代理发送消息。运行时将实例化代理并调用消息处理程序。
    await runtime.send_message(TestMessage(content="Hello, world!"), AgentId("test_agent", "default"))

    # 停止运行时。
    await runtime.stop()


asyncio.run(main())
```

```python
classmethod current_runtime() → AgentRuntime[source]#
```

```python
classmethod current_agent_id() → AgentId[source]#
```

```python
class TopicId(type: str, source: str)[source]#
```

【中文翻译】基类：object
TopicId 定义广播消息的范围。本质上，代理运行时通过其广播 API 实现发布-订阅模型：发布消息时，必须指定主题。
有关更多信息，请参阅此处：主题

```python
type: str#
```

【中文翻译】此 topic_id 包含的事件类型。遵守云事件规范。
必须匹配模式：^[w-.:=]+Z
在此处了解更多信息：cloudevents/spec

```python
source: str#
```

【中文翻译】标识事件发生的上下文。遵守云事件规范。
在此处了解更多信息：cloudevents/spec

```python
classmethod from_str(topic_id: str) → Self[source]#
```

【中文翻译】将格式为 `type/source` 的字符串转换为 `TopicId`

```python
class Subscription(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol
订阅定义代理感兴趣的主题。

```python
property id: str#
```

【中文翻译】获取订阅的 ID。
实现应返回订阅的唯一 ID。通常这是一个 UUID。

返回：
str – 订阅的 ID。

```python
is_match(topic_id: TopicId) → bool[source]#
```

【中文翻译】检查给定的 topic_id 是否与订阅匹配。

参数：
topic_id (TopicId) – 要检查的 TopicId。

返回：
bool – 如果 topic_id 与订阅匹配，则为 True，否则为 False。

```python
map_to_agent(topic_id: TopicId) → AgentId[source]#
```

【中文翻译】将 topic_id 映射到代理。仅当给定 topic_id 的 `is_match` 返回 True 时才应调用。

参数：
topic_id (TopicId) – 要映射的 TopicId。

返回：
AgentId – 应处理 topic_id 的代理的 ID。

引发：
CantHandleException – 如果订阅无法处理 topic_id。

```python
class MessageContext(sender: AgentId | None, topic_id: TopicId | None, is_rpc: bool, cancellation_token: CancellationToken, message_id: str)[source]#
```

【中文翻译】基类：object

```python
sender: AgentId | None#
```

```python
topic_id: TopicId | None#
```

```python
is_rpc: bool#
```

```python
cancellation_token: CancellationToken#
```

```python
message_id: str#
```

```python
class AgentType(type: str)[source]#
```

【中文翻译】基类：object

```python
type: str#
```

【中文翻译】此代理类型的字符串表示形式。

```python
class SubscriptionInstantiationContext[source]#
```

【中文翻译】基类：object

```python
classmethod agent_type() → AgentType[source]#
```

```python
class MessageHandlerContext[source]#
```

【中文翻译】基类：object

```python
classmethod agent_id() → AgentId[source]#
```

```python
class MessageSerializer(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol[T]

```python
property data_content_type: str#
```

```python
property type_name: str#
```

```python
deserialize(payload: bytes) → T[source]#
```

```python
serialize(message: T) → bytes[source]#
```

```python
class UnknownPayload(type_name: str, data_content_type: str, payload: bytes)[source]#
```

【中文翻译】基类：object

```python
type_name: str#
```

```python
data_content_type: str#
```

```python
payload: bytes#
```

```python
class Image(image: Image)[source]#
```

【中文翻译】基类：object
表示一个图像。

示例
从 URL 加载图像：
```python
from autogen_core import Image
from PIL import Image as PILImage
import aiohttp
import asyncio


async def from_url(url: str) → Image:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            content = await response.read()
            return Image.from_pil(PILImage.open(content))


image = asyncio.run(from_url("https://example.com/image"))
```

```python
classmethod from_pil(pil_image: Image) → Image[source]#
```

```python
classmethod from_uri(uri: str) → Image[source]#
```

```python
classmethod from_base64(base64_str: str) → Image[source]#
```

```python
to_base64() → str[source]#
```

```python
classmethod from_file(file_path: Path) → Image[source]#
```

```python
property data_uri: str#
```

```python
to_openai_format(detail: Literal['auto', 'low', 'high'] = 'auto') → Dict[str, Any][source]#
```

```python
class RoutedAgent(description: str)[source]#
```

【中文翻译】基类：BaseAgent
一个基类，用于根据消息类型和可选的匹配函数将消息路由到处理程序的代理。
要创建路由代理，请子类化此类，并添加使用 `event()` 或 `rpc()` 装饰器修饰的方法作为消息处理程序。

示例：
```python
from dataclasses import dataclass
from autogen_core import MessageContext
from autogen_core import RoutedAgent, event, rpc


@dataclass
class Message:
    pass


@dataclass
class MessageWithContent:
    content: str


@dataclass
class Response:
    pass


class MyAgent(RoutedAgent):
    def __init__(self):
        super().__init__("MyAgent")

    @event
    async def handle_event_message(self, message: Message, ctx: MessageContext) -> None:
        assert ctx.topic_id is not None
        await self.publish_message(MessageWithContent("event handled"), ctx.topic_id)

    @rpc(match=lambda message, ctx: message.content == "special")  # type: ignore
    async def handle_special_rpc_message(self, message: MessageWithContent, ctx: MessageContext) -> Response:
        return Response()
```

```python
async on_message_impl(message: Any, ctx: MessageContext) → Any | None[source]#
```

【中文翻译】通过将消息路由到适当的消息处理程序来处理消息。
不要在子类中覆盖此方法。相反，请添加使用 `event()` 或 `rpc()` 装饰器修饰的方法作为消息处理程序。

```python
async on_unhandled_message(message: Any, ctx: MessageContext) → None[source]#
```

【中文翻译】当收到没有匹配消息处理程序的消息时调用。
默认实现会记录一条信息性消息。

```python
class ClosureAgent(description: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn')[source]#
```

【中文翻译】基类：BaseAgent, ClosureContext

```python
property metadata: AgentMetadata#
```

【中文翻译】代理的元数据。

```python
property id: AgentId#
```

【中文翻译】代理的 ID。

```python
property runtime: AgentRuntime#
```

```python
async on_message_impl(message: Any, ctx: MessageContext) → Any[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】闭包代理没有状态。因此，此方法始终返回一个空字典。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】闭包代理没有状态。因此，此方法不执行任何操作。

```python
async classmethod register_closure(runtime: AgentRuntime, type: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn', skip_direct_message_subscription: bool = False, description: str = '', subscriptions: Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None = None) → AgentType[source]#
```

【中文翻译】闭包代理允许您使用闭包或函数定义代理，而无需定义类。它允许从运行时提取值。
闭包可以定义预期的消息类型，或者可以使用 Any 来接受任何类型的消息。

示例：
```python
import asyncio
from autogen_core import SingleThreadedAgentRuntime, MessageContext, ClosureAgent, ClosureContext
from dataclasses import dataclass

from autogen_core._default_subscription import DefaultSubscription
from autogen_core._default_topic import DefaultTopicId


@dataclass
class MyMessage:
    content: str


async def main():
    queue = asyncio.Queue[MyMessage]()

    async def output_result(_ctx: ClosureContext, message: MyMessage, ctx: MessageContext) -> None:
        await queue.put(message)

    runtime = SingleThreadedAgentRuntime()
    await ClosureAgent.register_closure(
        runtime, "output_result", output_result, subscriptions=lambda: [DefaultSubscription()]
    )

    runtime.start()
    await runtime.publish_message(MyMessage("Hello, world!"), DefaultTopicId())
    await runtime.stop_when_idle()

    result = await queue.get()
    print(result)


asyncio.run(main())
```

参数：

runtime (AgentRuntime) – 要注册代理的运行时
type (str) – 已注册代理的代理类型
closure (Callable[[ClosureContext, T, MessageContext], Awaitable[Any]]) – 处理消息的闭包
unknown_type_policy (Literal["error", "warn", "ignore"], 可选) – 如果遇到与闭包类型不匹配的类型，该怎么办。默认为“warn”。
skip_direct_message_subscription (bool, 可选) – 不要为此代理添加直接消息订阅。默认为 False。
description (str, 可选) – 代理功能的描述。默认为“”。
subscriptions (Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None, 可选) – 此闭包代理的订阅列表。默认为 None。

返回：
AgentType – 已注册代理的类型

```python
class ClosureContext(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol

```python
property id: AgentId#
```

```python
async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

```python
async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]#
```

```python
message_handler(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]#
```

【中文翻译】通用消息处理程序的装饰器。
将此装饰器添加到 `RoutedAgent` 类中旨在处理事件和 RPC 消息的方法。
这些方法必须具有特定的签名才能有效：

该方法必须是异步方法。
该方法必须使用 `@message_handler` 装饰器进行修饰。

该方法必须正好有 3 个参数：
self
message：要处理的消息，必须使用其旨在处理的消息类型进行类型提示。
ctx：一个 `autogen_core.MessageContext` 对象。

该方法必须使用它可以作为响应返回的消息类型进行类型提示，如果它不返回任何内容，则可以返回 None。

处理程序可以通过接受消息类型的联合来处理多种消息类型。它还可以通过返回消息类型的联合来返回多种消息类型。

参数：

func – 要装饰的函数。
strict – 如果为 True，则如果消息类型或返回类型不在目标类型中，处理程序将引发异常。如果为 False，则会记录一条警告。
match – 一个接受消息和上下文作为参数并返回布尔值的函数。这用于在消息类型之后进行二次路由。对于处理相同消息类型的处理程序，匹配函数按处理程序的字母顺序应用，第一个匹配的处理程序将被调用，其余的将被跳过。如果为 None，则将调用按字母顺序排列的第一个匹配相同消息类型的处理程序。

```python
event(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]]], MessageHandler[AgentT, ReceivesT, None]] | MessageHandler[AgentT, ReceivesT, None][source]#
```

【中文翻译】事件消息处理程序的装饰器。
将此装饰器添加到 `RoutedAgent` 类中旨在处理事件消息的方法。
这些方法必须具有特定的签名才能有效：

该方法必须是异步方法。
该方法必须使用 `@message_handler` 装饰器进行修饰。

该方法必须正好有 3 个参数：
self
message：要处理的事件消息，必须使用其旨在处理的消息类型进行类型提示。
ctx：一个 `autogen_core.MessageContext` 对象。

该方法必须返回 None。

处理程序可以通过接受消息类型的联合来处理多种消息类型。

参数：

func – 要装饰的函数。
strict – 如果为 True，则如果消息类型不在目标类型中，处理程序将引发异常。如果为 False，则会记录一条警告。
match – 一个接受消息和上下文作为参数并返回布尔值的函数。这用于在消息类型之后进行二次路由。对于处理相同消息类型的处理程序，匹配函数按处理程序的字母顺序应用，第一个匹配的处理程序将被调用，其余的将被跳过。如果为 None，则将调用按字母顺序排列的第一个匹配相同消息类型的处理程序。

```python
rpc(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]#
```

【中文翻译】RPC 消息处理程序的装饰器。
将此装饰器添加到 `RoutedAgent` 类中旨在处理 RPC 消息的方法。
这些方法必须具有特定的签名才能有效：

该方法必须是异步方法。
该方法必须使用 `@message_handler` 装饰器进行修饰。

该方法必须正好有 3 个参数：
self
message：要处理的消息，必须使用其旨在处理的消息类型进行类型提示。
ctx：一个 `autogen_core.MessageContext` 对象。

该方法必须使用它可以作为响应返回的消息类型进行类型提示，如果它不返回任何内容，则可以返回 None。

处理程序可以通过接受消息类型的联合来处理多种消息类型。它还可以通过返回消息类型的联合来返回多种消息类型。

参数：

func – 要装饰的函数。
strict – 如果为 True，则如果消息类型或返回类型不在目标类型中，处理程序将引发异常。如果为 False，则会记录一条警告。
match – 一个接受消息和上下文作为参数并返回布尔值的函数。这用于在消息类型之后进行二次路由。对于处理相同消息类型的处理程序，匹配函数按处理程序的字母顺序应用，第一个匹配的处理程序将被调用，其余的将被跳过。如果为 None，则将调用按字母顺序排列的第一个匹配相同消息类型的处理程序。

```python
class FunctionCall(id: 'str', arguments: 'str', name: 'str')[source]#
```

【中文翻译】基类：object

```python
id: str#
```

```python
arguments: str#
```

```python
name: str#
```

```python
class TypeSubscription(topic_type: str, agent_type: str | AgentType, id: str | None = None)[source]#
```

【中文翻译】基类：Subscription
此订阅根据类型匹配主题，并使用主题的源作为代理键映射到代理。
此订阅导致每个源都有其自己的代理实例。

示例
```python
from autogen_core import TypeSubscription

subscription = TypeSubscription(topic_type="t1", agent_type="a1")
```

在这种情况下：

类型为 t1 且源为 s1 的 topic_id 将由类型为 a1 且键为 s1 的代理处理
类型为 t1 且源为 s2 的 topic_id 将由类型为 a1 且键为 s2 的代理处理。

参数：

topic_type (str) – 要匹配的主题类型
agent_type (str) – 处理此订阅的代理类型

```python
property id: str#
```

【中文翻译】获取订阅的 ID。
实现应返回订阅的唯一 ID。通常这是一个 UUID。

返回：
str – 订阅的 ID。

```python
property topic_type: str#
```

```python
property agent_type: str#
```

```python
is_match(topic_id: TopicId) → bool[source]#
```

【中文翻译】检查给定的 topic_id 是否与订阅匹配。

参数：
topic_id (TopicId) – 要检查的 TopicId。

返回：
bool – 如果 topic_id 与订阅匹配，则为 True，否则为 False。

```python
map_to_agent(topic_id: TopicId) → AgentId[source]#
```

【中文翻译】将 topic_id 映射到代理。仅当给定 topic_id 的 `is_match` 返回 True 时才应调用。

参数：
topic_id (TopicId) – 要映射的 TopicId。

返回：
AgentId – 应处理 topic_id 的代理的 ID。

引发：
CantHandleException – 如果订阅无法处理 topic_id。

```python
class DefaultSubscription(topic_type: str = 'default', agent_type: str | AgentType | None = None)[source]#
```

【中文翻译】基类：TypeSubscription
默认订阅旨在为只需要代理全局范围的应用程序提供合理的默认值。
默认情况下，此主题使用“default”主题类型，并尝试根据实例化上下文检测要使用的代理类型。

参数：

topic_type (str, 可选) – 要订阅的主题类型。默认为“default”。
agent_type (str, 可选) – 用于订阅的代理类型。默认为 None，在这种情况下，它将尝试根据实例化上下文检测代理类型。

```python
class DefaultTopicId(type: str = 'default', source: str | None = None)[source]#
```

【中文翻译】基类：TopicId
`DefaultTopicId` 为 `TopicId` 的 `topic_id` 和 `source` 字段提供了一个合理的默认值。
如果在消息处理程序的上下文中创建，则源将设置为消息处理程序的 `agent_id`，否则将设置为“default”。

参数：

type (str, 可选) – 要向其发布消息的主题类型。默认为“default”。
source (str | None, 可选) – 要向其发布消息的主题源。如果为 None，则如果在消息处理程序的上下文中，源将设置为消息处理程序的 `agent_id`，否则将设置为“default”。默认为 None。

```python
default_subscription(cls: Type[BaseAgentType] | None = None) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]] | Type[BaseAgentType][source]#
```

```python
type_subscription(topic_type: str) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]][source]#
```

```python
class TypePrefixSubscription(topic_type_prefix: str, agent_type: str | AgentType, id: str | None = None)[source]#
```

【中文翻译】基类：Subscription
此订阅根据类型的前缀匹配主题，并使用主题的源作为代理键映射到代理。
此订阅导致每个源都有其自己的代理实例。

示例
```python
from autogen_core import TypePrefixSubscription

subscription = TypePrefixSubscription(topic_type_prefix="t1", agent_type="a1")
```

在这种情况下：

类型为 t1 且源为 s1 的 topic_id 将由类型为 a1 且键为 s1 的代理处理
类型为 t1 且源为 s2 的 topic_id 将由类型为 a1 且键为 s2 的代理处理。
类型为 t1SUFFIX 且源为 s2 的 topic_id 将由类型为 a1 且键为 s2 的代理处理。

参数：

topic_type_prefix (str) – 要匹配的主题类型前缀
agent_type (str) – 处理此订阅的代理类型

```python
property id: str#
```

【中文翻译】获取订阅的 ID。
实现应返回订阅的唯一 ID。通常这是一个 UUID。

返回：
str – 订阅的 ID。

```python
property topic_type_prefix: str#
```

```python
property agent_type: str#
```

```python
is_match(topic_id: TopicId) → bool[source]#
```

【中文翻译】检查给定的 topic_id 是否与订阅匹配。

参数：
topic_id (TopicId) – 要检查的 TopicId。

返回：
bool – 如果 topic_id 与订阅匹配，则为 True，否则为 False。

```python
map_to_agent(topic_id: TopicId) → AgentId[source]#
```

【中文翻译】将 topic_id 映射到代理。仅当给定 topic_id 的 `is_match` 返回 True 时才应调用。

参数：
topic_id (TopicId) – 要映射的 TopicId。

返回：
AgentId – 应处理 topic_id 的代理的 ID。

引发：
CantHandleException – 如果订阅无法处理 topic_id。

```python
JSON_DATA_CONTENT_TYPE = 'application/json'#
```

【中文翻译】JSON 数据的内容类型。

```python
PROTOBUF_DATA_CONTENT_TYPE = 'application/x-protobuf'#
```

【中文翻译】Protobuf 数据的内容类型。

```python
class SingleThreadedAgentRuntime(*, intervention_handlers: List[InterventionHandler] | None = None, tracer_provider: TracerProvider | None = None, ignore_unhandled_exceptions: bool = True)[source]#
```

【中文翻译】基类：AgentRuntime
一个单线程代理运行时，它使用单个 asyncio 队列处理所有消息。
消息按接收顺序传递，运行时在单独的 asyncio 任务中并发处理每条消息。

注意
此运行时适用于开发和独立应用程序。
它不适用于高吞吐量或高并发场景。

参数：

intervention_handlers (List[InterventionHandler], 可选) – 一个干预处理程序列表，可以在发送或发布消息之前拦截消息。默认为 None。
tracer_provider (TracerProvider, 可选) – 用于跟踪的跟踪程序提供程序。默认为 None。
ignore_unhandled_exceptions (bool, 可选) – 是否忽略代理事件处理程序中发生的未处理异常。任何后台异常都将在下一次调用 `process_next` 或从等待的 `stop`、`stop_when_idle` 或 `stop_when` 时引发。注意，这不适用于 RPC 处理程序。默认为 True。

示例
创建运行时、注册代理、发送消息和停止运行时的简单示例：
```python
import asyncio
from dataclasses import dataclass

from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler


@dataclass
class MyMessage:
    content: str


class MyAgent(RoutedAgent):
    @message_handler
    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:
        print(f"Received message: {message.content}")


async def main() -> None:
    # 创建运行时并注册代理
    runtime = SingleThreadedAgentRuntime()
    await MyAgent.register(runtime, "my_agent", lambda: MyAgent("My agent"))

    # 启动运行时、发送消息并停止运行时
    runtime.start()
    await runtime.send_message(MyMessage("Hello, world!"), recipient=AgentId("my_agent", "default"))
    await runtime.stop()


asyncio.run(main())
```

创建运行时、注册代理、发布消息和停止运行时的示例：
```python
import asyncio
from dataclasses import dataclass

from autogen_core import (
    DefaultTopicId,
    MessageContext,
    RoutedAgent,
    SingleThreadedAgentRuntime,
    default_subscription,
    message_handler,
)


@dataclass
class MyMessage:
    content: str


# 代理订阅默认主题。
@default_subscription
class MyAgent(RoutedAgent):
    @message_handler
    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:
        print(f"Received message: {message.content}")


async def main() -> None:
    # 创建运行时并注册代理
    runtime = SingleThreadedAgentRuntime()
    await MyAgent.register(runtime, "my_agent", lambda: MyAgent("My agent"))

    # 启动运行时。
    runtime.start()
    # 向代理订阅的默认主题发布消息。
    await runtime.publish_message(MyMessage("Hello, world!"), DefaultTopicId())
    # 等待消息处理完毕，然后停止运行时。
    await runtime.stop_when_idle()


asyncio.run(main())
```

```python
property unprocessed_messages_count: int#
```

```python
async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

【中文翻译】向代理发送消息并获取响应。

参数：

message (Any) – 要发送的消息。
recipient (AgentId) – 要向其发送消息的代理。
sender (AgentId | None, 可选) – 发送消息的代理。如果此消息不是从任何代理发送的（例如直接从外部发送到运行时），则只能为 None。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。

引发：

CantHandleException – 如果接收方无法处理消息。
UndeliverableException – 如果消息无法传递。
Other – 接收方引发的任何其他异常。

返回：
Any – 来自代理的响应。

```python
async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]#
```

【中文翻译】向给定命名空间中的所有代理发布消息，如果未提供命名空间，则向发送方的命名空间发布消息。
发布预计不会有响应。

参数：

message (Any) – 要发布的消息。
topic_id (TopicId) – 要向其发布消息的主题。
sender (AgentId | None, 可选) – 发送消息的代理。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。
message_id (str | None, 可选) – 消息 ID。如果为 None，将生成新的消息 ID。默认为 None。此消息 ID 必须唯一，并且建议使用 UUID。

引发：
UndeliverableException – 如果消息无法传递。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存所有已实例化代理的状态。
此方法调用每个代理的 `save_state()` 方法，并返回一个将代理 ID 映射到其状态的字典。

注意
此方法目前不保存订阅状态。我们将在未来添加此功能。

返回：
一个将代理 ID 映射到其状态的字典。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载所有已实例化代理的状态。
此方法使用字典中提供的状态调用每个代理的 `load_state()` 方法。字典的键是代理 ID，值是 `save_state()` 方法返回的状态字典。

注意
此方法目前不加载订阅状态。我们将在未来添加此功能。

```python
async process_next() → None[source]#
```

【中文翻译】处理队列中的下一条消息。
如果后台任务中存在未处理的异常，将在此处引发。在引发未处理的异常后，无法再次调用 `process_next`。

```python
start() → None[source]#
```

【中文翻译】启动运行时消息处理循环。这在后台任务中运行。

示例：
```python
import asyncio
from autogen_core import SingleThreadedAgentRuntime


async def main() -> None:
    runtime = SingleThreadedAgentRuntime()
    runtime.start()

    # ... 执行其他操作 ...

    await runtime.stop()


asyncio.run(main())
```

```python
async close() → None[source]#
```

【中文翻译】如果适用，调用 `stop()`，并对所有实例化的代理调用 `Agent.close()` 方法

```python
async stop() → None[source]#
```

【中文翻译】立即停止运行时消息处理循环。当前正在处理的消息将完成，但其后的所有其他消息将被丢弃。

```python
async stop_when_idle() → None[source]#
```

【中文翻译】当没有正在处理或排队的未完成消息时，停止运行时消息处理循环。这是停止运行时的最常用方法。

```python
async stop_when(condition: Callable[[], bool]) → None[source]#
```

【中文翻译】当条件满足时停止运行时消息处理循环。

警告
不建议使用此方法，它仅用于遗留原因。它将产生一个繁忙的循环来持续检查条件。调用 `stop_when_idle` 或 `stop` 效率要高得多。如果需要根据条件停止运行时，请考虑使用后台任务和 `asyncio.Event` 来发出条件满足且后台任务应调用 `stop` 的信号。

```python
async agent_metadata(agent: AgentId) → AgentMetadata[source]#
```

【中文翻译】获取代理的元数据。

参数：
agent (AgentId) – 代理 ID。

返回：
AgentMetadata – 代理元数据。

```python
async agent_save_state(agent: AgentId) → Mapping[str, Any][source]#
```

【中文翻译】保存单个代理的状态。
状态的结构由实现定义，可以是任何可 JSON 序列化的对象。

参数：
agent (AgentId) – 代理 ID。

返回：
Mapping[str, Any] – 保存的状态。

```python
async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载单个代理的状态。

参数：

agent (AgentId) – 代理 ID。
state (Mapping[str, Any]) – 保存的状态。

```python
async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]#
```

【中文翻译】向与特定类型关联的运行时注册代理工厂。类型必须唯一。此 API 不添加任何订阅。

注意
这是一个低级 API，通常应改用代理类的 `register` 方法，因为这也会自动处理订阅。

示例：
```python
from dataclasses import dataclass

from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event
from autogen_core.models import UserMessage


@dataclass
class MyMessage:
    content: str


class MyAgent(RoutedAgent):
    def __init__(self) -> None:
        super().__init__("My core agent")

    @event
    async def handler(self, message: UserMessage, context: MessageContext) -> None:
        print("Event received: ", message.content)


async def my_agent_factory():
    return MyAgent()


async def main() -> None:
    runtime: AgentRuntime = ...  # type: ignore
    await runtime.register_factory("my_agent", lambda: MyAgent())


import asyncio

asyncio.run(main())
```

参数：

type (str) – 此工厂创建的代理类型。它与代理类名不同。类型参数用于区分不同的工厂函数而不是代理类。
agent_factory (Callable[[], T]) – 创建代理的工厂，其中 T 是具体的代理类型。在工厂内部，使用 `autogen_core.AgentInstantiationContext` 访问诸如当前运行时和代理 ID 之类的变量。
expected_class (type[T] | None, 可选) – 代理的预期类，用于工厂的运行时验证。默认为 None。如果为 None，则不执行验证。

```python
async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]#
```

【中文翻译】尝试按名称和命名空间获取基础代理实例。通常不鼓励这样做（因此名称很长），但在某些情况下可能很有用。
如果基础代理不可访问，则会引发异常。

参数：

id (AgentId) – 代理 ID。
type (Type[T], 可选) – 代理的预期类型。默认为 Agent。

返回：
T – 具体的代理实例。

引发：

LookupError – 如果未找到代理。
NotAccessibleError – 如果代理不可访问，例如它位于远程位置。
TypeError – 如果代理不是预期类型。

```python
async add_subscription(subscription: Subscription) → None[source]#
```

【中文翻译】添加一个新的订阅，运行时在处理已发布消息时应满足该订阅

参数：
subscription (Subscription) – 要添加的订阅

```python
async remove_subscription(id: str) → None[source]#
```

【中文翻译】从运行时中删除订阅

参数：
id (str) – 要删除的订阅的 ID

引发：
LookupError – 如果订阅不存在

```python
async get(id_or_type: AgentId | AgentType | str, /, key: str = 'default', *, lazy: bool = True) → AgentId[source]#
```

```python
add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]#
```

【中文翻译】向运行时添加新的消息序列化序列化器
注意：这将根据 `type_name` 和 `data_content_type` 属性对序列化器进行重复数据删除

参数：
serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – 要添加的序列化器

```python
ROOT_LOGGER_NAME = 'autogen_core'#
```

【中文翻译】根记录器的名称。

```python
EVENT_LOGGER_NAME = 'autogen_core.events'#
```

【中文翻译】用于结构化事件的记录器的名称。

```python
TRACE_LOGGER_NAME = 'autogen_core.trace'#
```

【中文翻译】用于开发人员意图跟踪日志记录的记录器名称。不应依赖此日志的内容和格式。

```python
class Component[source]#
```

【中文翻译】基类：ComponentFromConfig[ConfigT], ComponentSchemaType[ConfigT], Generic[ConfigT]
要创建组件类，请从此类继承具体类，并在接口上继承 `ComponentBase`。然后实现两个类变量：

`component_config_schema` - 表示组件配置的 Pydantic 模型类。这也是 `Component` 的类型参数。
`component_type` - 组件的逻辑类型是什么。

示例：
```python
from __future__ import annotations

from pydantic import BaseModel
from autogen_core import Component


class Config(BaseModel):
    value: str


class MyComponent(Component[Config]):
    component_type = "custom"
    component_config_schema = Config

    def __init__(self, value: str):
        self.value = value

    def _to_config(self) -> Config:
        return Config(value=self.value)

    @classmethod
    def _from_config(cls, config: Config) -> MyComponent:
        return cls(value=config.value)
```

```python
class ComponentBase[source]#
```

【中文翻译】基类：ComponentToConfig[ConfigT], ComponentLoader, Generic[ConfigT]

```python
class ComponentFromConfig[source]#
```

【中文翻译】基类：Generic[FromConfigT]

```python
classmethod _from_config(config: FromConfigT) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
classmethod _from_config_past_version(config: Dict[str, Any], version: int) → Self[source]#
```

【中文翻译】从配置对象的先前版本创建组件的新实例。
仅当配置对象的版本低于当前版本时才调用此方法，因为在这种情况下模式是未知的。

参数：

config (Dict[str, Any]) – 配置对象。
version (int) – 配置对象的版本。

返回：
Self – 组件的新实例。

```python
class ComponentLoader[source]#
```

【中文翻译】基类：object

```python
classmethod load_component(model: ComponentModel | Dict[str, Any], expected: None = None) → Self[source]#
```

【中文翻译】从模型加载组件。旨在与 `autogen_core.ComponentConfig.dump_component()` 的返回类型一起使用。

示例
```python
from autogen_core import ComponentModel
from autogen_core.models import ChatCompletionClient

component: ComponentModel = ...  # type: ignore

model_client = ChatCompletionClient.load_component(component)
```

参数：

model (ComponentModel) – 要从中加载组件的模型。
model – _description_
expected (Type[ExpectedType] | None, 可选) – 仅当直接在 `ComponentLoader` 上使用时才显式类型。默认为 None。

返回：
Self – 加载的组件。

引发：

ValueError – 如果提供程序字符串无效。
TypeError – 提供程序不是 `ComponentConfigImpl` 的子类，或者预期类型不匹配。

返回：
Self | ExpectedType – 加载的组件。

```python
pydantic model ComponentModel[source]#
```

【中文翻译】基类：BaseModel
组件的模型类。包含实例化组件所需的所有信息。

显示 JSON 架构
```json
{
   "title": "ComponentModel",
   "description": "Model class for a component. Contains all information required to instantiate a component.",
   "type": "object",
   "properties": {
      "provider": {
         "title": "Provider",
         "type": "string"
      },
      "component_type": {
         "anyOf": [
            {
               "enum": [
                  "model",
                  "agent",
                  "tool",
                  "termination",
                  "token_provider",
                  "workbench"
               ],
               "type": "string"
            },
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Component Type"
      },
      "version": {
         "anyOf": [
            {
               "type": "integer"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Version"
      },
      "component_version": {
         "anyOf": [
            {
               "type": "integer"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Component Version"
      },
      "description": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Description"
      },
      "label": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Label"
      },
      "config": {
         "title": "Config",
         "type": "object"
      }
   },
   "required": [
      "provider",
      "config"
   ]
}
```

字段：

component_type (Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str | None)
component_version (int | None)
config (dict[str, Any])
description (str | None)
label (str | None)
provider (str)
version (int | None)

```python
field provider: str [Required]#
```

【中文翻译】描述如何实例化组件。

```python
field component_type: ComponentType | None = None#
```

【中文翻译】组件的逻辑类型。如果缺失，组件将采用提供程序的默认类型。

```python
field version: int | None = None#
```

【中文翻译】组件规范的版本。如果缺失，组件将采用用于加载它的库的当前版本。这显然是危险的，应该用于用户编写的临时配置。对于所有其他配置，应指定版本。

```python
field component_version: int | None = None#
```

【中文翻译】组件的版本。如果缺失，组件将采用提供程序的默认版本。

```python
field description: str | None = None#
```

【中文翻译】组件的描述。

```python
field label: str | None = None#
```

【中文翻译】组件的人类可读标签。如果缺失，组件将采用提供程序的类名。

```python
field config: dict[str, Any] [Required]#
```

【中文翻译】模式验证的 `config` 字段将传递给给定类的 `autogen_core.ComponentConfigImpl._from_config()` 实现，以创建组件类的新实例。

```python
class ComponentSchemaType[source]#
```

【中文翻译】基类：Generic[ConfigT]

```python
component_config_schema: Type[ConfigT]#
```

【中文翻译】表示组件配置的 Pydantic 模型类。

```python
required_class_vars = ['component_config_schema', 'component_type']#
```

```python
class ComponentToConfig[source]#
```

【中文翻译】基类：Generic[ToConfigT]
一个类要成为组件必须实现的两个方法。

参数：
Protocol (ConfigT) –派生自 `pydantic.BaseModel` 的类型。

```python
component_type: ClassVar[Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str]#
```

【中文翻译】组件的逻辑类型。

```python
component_version: ClassVar[int] = 1#
```

【中文翻译】组件的版本，如果引入了模式不兼容性，则应更新此版本。

```python
component_provider_override: ClassVar[str | None] = None#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_description: ClassVar[str | None] = None#
```

【中文翻译】组件的描述。如果未提供，将使用类的文档字符串。

```python
component_label: ClassVar[str | None] = None#
```

【中文翻译】组件的人类可读标签。如果未提供，将使用组件类名。

```python
_to_config() → ToConfigT[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
dump_component() → ComponentModel[source]#
```

【中文翻译】将组件转储到可以加载回的模型中。

引发：
TypeError – 如果组件是本地类。

返回：
ComponentModel – 表示组件的模型。

```python
is_component_class(cls: type) → TypeGuard[Type[_ConcreteComponent[BaseModel]]][source]#
```

```python
is_component_instance(cls: Any) → TypeGuard[_ConcreteComponent[BaseModel]][source]#
```

```python
final class DropMessage[source]#
```

【中文翻译】基类：object
用于指示干预处理程序应丢弃消息的标记类型。该类型本身应从处理程序返回。

```python
class InterventionHandler(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol
干预处理程序是一个类，可用于修改、记录或丢弃由 `autogen_core.base.AgentRuntime` 处理的消息。
当消息提交到运行时时，将调用该处理程序。
目前唯一支持此功能的运行时是 `autogen_core.base.SingleThreadedAgentRuntime`。
注意：从任何干预处理程序方法返回 None 将导致发出警告并被视为“无更改”。如果您打算丢弃消息，则应显式返回 `DropMessage`。

示例：
```python
from autogen_core import DefaultInterventionHandler, MessageContext, AgentId, SingleThreadedAgentRuntime
from dataclasses import dataclass
from typing import Any


@dataclass
class MyMessage:
    content: str


class MyInterventionHandler(DefaultInterventionHandler):
    async def on_send(self, message: Any, *, message_context: MessageContext, recipient: AgentId) -> MyMessage:
        if isinstance(message, MyMessage):
            message.content = message.content.upper()
        return message


runtime = SingleThreadedAgentRuntime(intervention_handlers=[MyInterventionHandler()])
```

```python
async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.send_message()` 向 AgentRuntime 提交消息时调用。

```python
async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.publish_message()` 向 AgentRuntime 发布消息时调用。

```python
async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]#
```

【中文翻译】当 AgentRuntime 从 Agent 的消息处理程序接收到返回值时调用。

```python
class DefaultInterventionHandler(*args, **kwargs)[source]#
```

【中文翻译】基类：InterventionHandler
一个简单的类，为所有干预处理程序方法提供默认实现，该实现仅返回未更改的消息。允许轻松地进行子类化以仅覆盖所需的方法。

```python
async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.send_message()` 向 AgentRuntime 提交消息时调用。

```python
async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.publish_message()` 向 AgentRuntime 发布消息时调用。

```python
async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]#
```

【中文翻译】当 AgentRuntime 从 Agent 的消息处理程序接收到返回值时调用。

```python
ComponentType#
```

【中文翻译】Literal[‘model’, ‘agent’, ‘tool’, ‘termination’, ‘token_provider’, ‘workbench’] | str 的别名

【中文翻译】上一页

【中文翻译】autogen_agentchat.state

【中文翻译】下一页

【中文翻译】autogen_core.code_executor

### autogen_core {autogen_core}

**链接**: [https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html](https://microsoft.github.io/autogen/stable/reference/python/autogen_core.html)

```python
class Agent(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol

```python
property metadata: AgentMetadata#
```

【中文翻译】代理的元数据。

```python
property id: AgentId#
```

【中文翻译】代理的 ID。

```python
async on_message(message: Any, ctx: MessageContext) → Any[source]#
```

【中文翻译】代理的消息处理程序。此方法只能由运行时调用，不能由其他代理调用。

参数：

message (Any) – 收到的消息。类型是订阅中的类型之一。
ctx (MessageContext) – 消息的上下文。

返回：
Any – 对消息的响应。可以为 None。

引发：

CancelledError – 如果消息已取消。
CantHandleException – 如果代理无法处理消息。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理的状态。结果必须是可 JSON 序列化的。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载从 `save_state` 获取的代理状态。

参数：
state (Mapping[str, Any]) – 代理的状态。必须是可 JSON 序列化的。

```python
async close() → None[source]#
```

【中文翻译】当运行时关闭时调用

```python
class AgentId(type: str | AgentType, key: str)[source]#
```

【中文翻译】基类：object
Agent ID 在代理运行时（包括分布式运行时）中唯一标识代理实例。它是代理实例接收消息的“地址”。
有关更多信息，请参阅此处：代理身份和生命周期

```python
classmethod from_str(agent_id: str) → Self[source]#
```

【中文翻译】将格式为 `type/key` 的字符串转换为 `AgentId`

```python
property type: str#
```

【中文翻译】将代理与特定工厂函数关联的标识符。
字符串只能由字母数字字符 (a-z) 和 (0-9) 或下划线 (_) 组成。

```python
property key: str#
```

【中文翻译】代理实例标识符。
字符串只能由字母数字字符 (a-z) 和 (0-9) 或下划线 (_) 组成。

```python
class AgentProxy(agent: AgentId, runtime: AgentRuntime)[source]#
```

【中文翻译】基类：object
一个帮助程序类，允许您使用 `AgentId` 代替其关联的代理

```python
property id: AgentId#
```

【中文翻译】此代理的目标代理

```python
property metadata: Awaitable[AgentMetadata]#
```

【中文翻译】代理的元数据。

```python
async send_message(message: Any, *, sender: AgentId, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理的状态。结果必须是可 JSON 序列化的。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载从 `save_state` 获取的代理状态。

参数：
state (Mapping[str, Any]) – 代理的状态。必须是可 JSON 序列化的。

```python
class AgentMetadata[source]#
```

【中文翻译】基类：TypedDict

```python
type: str#
```

```python
key: str#
```

```python
description: str#
```

```python
class AgentRuntime(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol

```python
async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

【中文翻译】向代理发送消息并获取响应。

参数：

message (Any) – 要发送的消息。
recipient (AgentId) – 要向其发送消息的代理。
sender (AgentId | None, 可选) – 发送消息的代理。如果此消息不是从任何代理发送的（例如直接从外部发送到运行时），则只能为 None。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。

引发：

CantHandleException – 如果接收方无法处理消息。
UndeliverableException – 如果消息无法传递。
Other – 接收方引发的任何其他异常。

返回：
Any – 来自代理的响应。

```python
async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]#
```

【中文翻译】向给定命名空间中的所有代理发布消息，如果未提供命名空间，则向发送方的命名空间发布消息。
发布预计不会有响应。

参数：

message (Any) – 要发布的消息。
topic_id (TopicId) – 要向其发布消息的主题。
sender (AgentId | None, 可选) – 发送消息的代理。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。
message_id (str | None, 可选) – 消息 ID。如果为 None，将生成新的消息 ID。默认为 None。此消息 ID 必须唯一，并且建议使用 UUID。

引发：
UndeliverableException – 如果消息无法传递。

```python
async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]#
```

【中文翻译】向与特定类型关联的运行时注册代理工厂。类型必须唯一。此 API 不添加任何订阅。

注意
这是一个低级 API，通常应改用代理类的 `register` 方法，因为这也会自动处理订阅。

示例：
```python
from dataclasses import dataclass

from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event
from autogen_core.models import UserMessage


@dataclass
class MyMessage:
    content: str


class MyAgent(RoutedAgent):
    def __init__(self) -> None:
        super().__init__("My core agent")

    @event
    async def handler(self, message: UserMessage, context: MessageContext) -> None:
        print("Event received: ", message.content)


async def my_agent_factory():
    return MyAgent()


async def main() -> None:
    runtime: AgentRuntime = ...  # type: ignore
    await runtime.register_factory("my_agent", lambda: MyAgent())


import asyncio

asyncio.run(main())
```

参数：

type (str) – 此工厂创建的代理类型。它与代理类名不同。类型参数用于区分不同的工厂函数而不是代理类。
agent_factory (Callable[[], T]) – 创建代理的工厂，其中 T 是具体的代理类型。在工厂内部，使用 `autogen_core.AgentInstantiationContext` 访问诸如当前运行时和代理 ID 之类的变量。
expected_class (type[T] | None, 可选) – 代理的预期类，用于工厂的运行时验证。默认为 None。如果为 None，则不执行验证。

```python
async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]#
```

【中文翻译】尝试按名称和命名空间获取基础代理实例。通常不鼓励这样做（因此名称很长），但在某些情况下可能很有用。
如果基础代理不可访问，则会引发异常。

参数：

id (AgentId) – 代理 ID。
type (Type[T], 可选) – 代理的预期类型。默认为 Agent。

返回：
T – 具体的代理实例。

引发：

LookupError – 如果未找到代理。
NotAccessibleError – 如果代理不可访问，例如它位于远程位置。
TypeError – 如果代理不是预期类型。

```python
async get(id: AgentId, /, *, lazy: bool = True) → AgentId[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存整个运行时的状态，包括所有托管代理。恢复状态的唯一方法是将其传递给 `load_state()`。
状态的结构由实现定义，可以是任何可 JSON 序列化的对象。

返回：
Mapping[str, Any] – 保存的状态。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载整个运行时的状态，包括所有托管代理。状态应与 `save_state()` 返回的状态相同。

参数：
state (Mapping[str, Any]) – 保存的状态。

```python
async agent_metadata(agent: AgentId) → AgentMetadata[source]#
```

【中文翻译】获取代理的元数据。

参数：
agent (AgentId) – 代理 ID。

返回：
AgentMetadata – 代理元数据。

```python
async agent_save_state(agent: AgentId) → Mapping[str, Any][source]#
```

【中文翻译】保存单个代理的状态。
状态的结构由实现定义，可以是任何可 JSON 序列化的对象。

参数：
agent (AgentId) – 代理 ID。

返回：
Mapping[str, Any] – 保存的状态。

```python
async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载单个代理的状态。

参数：

agent (AgentId) – 代理 ID。
state (Mapping[str, Any]) – 保存的状态。

```python
async add_subscription(subscription: Subscription) → None[source]#
```

【中文翻译】添加一个新的订阅，运行时在处理已发布消息时应满足该订阅

参数：
subscription (Subscription) – 要添加的订阅

```python
async remove_subscription(id: str) → None[source]#
```

【中文翻译】从运行时中删除订阅

参数：
id (str) – 要删除的订阅的 ID

引发：
LookupError – 如果订阅不存在

```python
add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]#
```

【中文翻译】向运行时添加新的消息序列化序列化器
注意：这将根据 `type_name` 和 `data_content_type` 属性对序列化器进行重复数据删除

参数：
serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – 要添加的序列化器

```python
class BaseAgent(description: str)[source]#
```

【中文翻译】基类：ABC, Agent

```python
property metadata: AgentMetadata#
```

【中文翻译】代理的元数据。

```python
property type: str#
```

```python
property id: AgentId#
```

【中文翻译】代理的 ID。

```python
property runtime: AgentRuntime#
```

```python
final async on_message(message: Any, ctx: MessageContext) → Any[source]#
```

【中文翻译】代理的消息处理程序。此方法只能由运行时调用，不能由其他代理调用。

参数：

message (Any) – 收到的消息。类型是订阅中的类型之一。
ctx (MessageContext) – 消息的上下文。

返回：
Any – 对消息的响应。可以为 None。

引发：

CancelledError – 如果消息已取消。
CantHandleException – 如果代理无法处理消息。

```python
abstract async on_message_impl(message: Any, ctx: MessageContext) → Any[source]#
```

```python
async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

【中文翻译】有关更多信息，请参阅 `autogen_core.AgentRuntime.send_message()`。

```python
async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存代理的状态。结果必须是可 JSON 序列化的。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载从 `save_state` 获取的代理状态。

参数：
state (Mapping[str, Any]) – 代理的状态。必须是可 JSON 序列化的。

```python
async close() → None[source]#
```

【中文翻译】当运行时关闭时调用

```python
async classmethod register(runtime: AgentRuntime, type: str, factory: Callable[[], Self | Awaitable[Self]], *, skip_class_subscriptions: bool = False, skip_direct_message_subscription: bool = False) → AgentType[source]#
```

【中文翻译】注册 ABC 的虚拟子类。
返回子类，以允许用作类装饰器。

```python
class CacheStore[source]#
```

【中文翻译】基类：ABC, Generic[T], ComponentBase[BaseModel]
此协议定义了存储/缓存操作的基本接口。
子类应处理基础存储的生命周期。

```python
component_type: ClassVar[ComponentType] = 'cache_store'#
```

【中文翻译】组件的逻辑类型。

```python
abstract get(key: str, default: T | None = None) → T | None[source]#
```

【中文翻译】从存储中检索项目。

参数：

key – 存储中标识项目的键。
default (可选) – 如果未找到键，则返回的默认值。
默认为 None。

返回：
如果找到，则为与键关联的值，否则为默认值。

```python
abstract set(key: str, value: T) → None[source]#
```

【中文翻译】在存储中设置项目。

参数：

key – 要存储项目的键。
value – 要存储在存储中的值。

```python
class InMemoryStore[source]#
```

【中文翻译】基类：CacheStore[T], Component[InMemoryStoreConfig]

```python
component_provider_override: ClassVar[str | None] = 'autogen_core.InMemoryStore'#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_config_schema#
```

【中文翻译】InMemoryStoreConfig 的别名

```python
get(key: str, default: T | None = None) → T | None[source]#
```

【中文翻译】从存储中检索项目。

参数：

key – 存储中标识项目的键。
default (可选) – 如果未找到键，则返回的默认值。
默认为 None。

返回：
如果找到，则为与键关联的值，否则为默认值。

```python
set(key: str, value: T) → None[source]#
```

【中文翻译】在存储中设置项目。

参数：

key – 要存储项目的键。
value – 要存储在存储中的值。

```python
_to_config() → InMemoryStoreConfig[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
classmethod _from_config(config: InMemoryStoreConfig) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
class CancellationToken[source]#
```

【中文翻译】基类：object
用于取消挂起异步调用的令牌

```python
cancel() → None[source]#
```

【中文翻译】取消链接到此取消令牌的挂起异步调用。

```python
is_cancelled() → bool[source]#
```

【中文翻译】检查是否已使用 CancellationToken

```python
add_callback(callback: Callable[[], None]) → None[source]#
```

【中文翻译】附加一个在调用 cancel 时将调用的回调

```python
link_future(future: Future[Any]) → Future[Any][source]#
```

【中文翻译】将挂起的异步调用链接到令牌以允许其取消

```python
class AgentInstantiationContext[source]#
```

【中文翻译】基类：object
一个提供代理实例化上下文的静态类。
此静态类可用于在代理实例化期间（在工厂函数或代理的类构造函数内部）访问当前运行时和代理 ID。

示例
在工厂函数和代理的构造函数内部获取当前运行时和代理 ID：
```python
import asyncio
from dataclasses import dataclass

from autogen_core import (
    AgentId,
    AgentInstantiationContext,
    MessageContext,
    RoutedAgent,
    SingleThreadedAgentRuntime,
    message_handler,
)


@dataclass
class TestMessage:
    content: str


class TestAgent(RoutedAgent):
    def __init__(self, description: str):
        super().__init__(description)
        # 获取当前运行时——我们在这里不使用它，但它是可用的。
        _ = AgentInstantiationContext.current_runtime()
        # 获取当前代理 ID。
        agent_id = AgentInstantiationContext.current_agent_id()
        print(f"Current AgentID from constructor: {agent_id}")

    @message_handler
    async def handle_test_message(self, message: TestMessage, ctx: MessageContext) -> None:
        print(f"Received message: {message.content}")


def test_agent_factory() -> TestAgent:
    # 获取当前运行时——我们在这里不使用它，但它是可用的。
    _ = AgentInstantiationContext.current_runtime()
    # 获取当前代理 ID。
    agent_id = AgentInstantiationContext.current_agent_id()
    print(f"Current AgentID from factory: {agent_id}")
    return TestAgent(description="Test agent")


async def main() -> None:
    # 创建一个 SingleThreadedAgentRuntime 实例。
    runtime = SingleThreadedAgentRuntime()

    # 启动运行时。
    runtime.start()

    # 使用工厂函数注册代理类型。
    await runtime.register_factory("test_agent", test_agent_factory)

    # 向代理发送消息。运行时将实例化代理并调用消息处理程序。
    await runtime.send_message(TestMessage(content="Hello, world!"), AgentId("test_agent", "default"))

    # 停止运行时。
    await runtime.stop()


asyncio.run(main())
```

```python
classmethod current_runtime() → AgentRuntime[source]#
```

```python
classmethod current_agent_id() → AgentId[source]#
```

```python
class TopicId(type: str, source: str)[source]#
```

【中文翻译】基类：object
TopicId 定义广播消息的范围。本质上，代理运行时通过其广播 API 实现发布-订阅模型：发布消息时，必须指定主题。
有关更多信息，请参阅此处：主题

```python
type: str#
```

【中文翻译】此 topic_id 包含的事件类型。遵守云事件规范。
必须匹配模式：^[w-.:=]+Z
在此处了解更多信息：cloudevents/spec

```python
source: str#
```

【中文翻译】标识事件发生的上下文。遵守云事件规范。
在此处了解更多信息：cloudevents/spec

```python
classmethod from_str(topic_id: str) → Self[source]#
```

【中文翻译】将格式为 `type/source` 的字符串转换为 `TopicId`

```python
class Subscription(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol
订阅定义代理感兴趣的主题。

```python
property id: str#
```

【中文翻译】获取订阅的 ID。
实现应返回订阅的唯一 ID。通常这是一个 UUID。

返回：
str – 订阅的 ID。

```python
is_match(topic_id: TopicId) → bool[source]#
```

【中文翻译】检查给定的 topic_id 是否与订阅匹配。

参数：
topic_id (TopicId) – 要检查的 TopicId。

返回：
bool – 如果 topic_id 与订阅匹配，则为 True，否则为 False。

```python
map_to_agent(topic_id: TopicId) → AgentId[source]#
```

【中文翻译】将 topic_id 映射到代理。仅当给定 topic_id 的 `is_match` 返回 True 时才应调用。

参数：
topic_id (TopicId) – 要映射的 TopicId。

返回：
AgentId – 应处理 topic_id 的代理的 ID。

引发：
CantHandleException – 如果订阅无法处理 topic_id。

```python
class MessageContext(sender: AgentId | None, topic_id: TopicId | None, is_rpc: bool, cancellation_token: CancellationToken, message_id: str)[source]#
```

【中文翻译】基类：object

```python
sender: AgentId | None#
```

```python
topic_id: TopicId | None#
```

```python
is_rpc: bool#
```

```python
cancellation_token: CancellationToken#
```

```python
message_id: str#
```

```python
class AgentType(type: str)[source]#
```

【中文翻译】基类：object

```python
type: str#
```

【中文翻译】此代理类型的字符串表示形式。

```python
class SubscriptionInstantiationContext[source]#
```

【中文翻译】基类：object

```python
classmethod agent_type() → AgentType[source]#
```

```python
class MessageHandlerContext[source]#
```

【中文翻译】基类：object

```python
classmethod agent_id() → AgentId[source]#
```

```python
class MessageSerializer(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol[T]

```python
property data_content_type: str#
```

```python
property type_name: str#
```

```python
deserialize(payload: bytes) → T[source]#
```

```python
serialize(message: T) → bytes[source]#
```

```python
class UnknownPayload(type_name: str, data_content_type: str, payload: bytes)[source]#
```

【中文翻译】基类：object

```python
type_name: str#
```

```python
data_content_type: str#
```

```python
payload: bytes#
```

```python
class Image(image: Image)[source]#
```

【中文翻译】基类：object
表示一个图像。

示例
从 URL 加载图像：
```python
from autogen_core import Image
from PIL import Image as PILImage
import aiohttp
import asyncio


async def from_url(url: str) → Image:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            content = await response.read()
            return Image.from_pil(PILImage.open(content))


image = asyncio.run(from_url("https://example.com/image"))
```

```python
classmethod from_pil(pil_image: Image) → Image[source]#
```

```python
classmethod from_uri(uri: str) → Image[source]#
```

```python
classmethod from_base64(base64_str: str) → Image[source]#
```

```python
to_base64() → str[source]#
```

```python
classmethod from_file(file_path: Path) → Image[source]#
```

```python
property data_uri: str#
```

```python
to_openai_format(detail: Literal['auto', 'low', 'high'] = 'auto') → Dict[str, Any][source]#
```

```python
class RoutedAgent(description: str)[source]#
```

【中文翻译】基类：BaseAgent
一个基类，用于根据消息类型和可选的匹配函数将消息路由到处理程序的代理。
要创建路由代理，请子类化此类，并添加使用 `event()` 或 `rpc()` 装饰器修饰的方法作为消息处理程序。

示例：
```python
from dataclasses import dataclass
from autogen_core import MessageContext
from autogen_core import RoutedAgent, event, rpc


@dataclass
class Message:
    pass


@dataclass
class MessageWithContent:
    content: str


@dataclass
class Response:
    pass


class MyAgent(RoutedAgent):
    def __init__(self):
        super().__init__("MyAgent")

    @event
    async def handle_event_message(self, message: Message, ctx: MessageContext) -> None:
        assert ctx.topic_id is not None
        await self.publish_message(MessageWithContent("event handled"), ctx.topic_id)

    @rpc(match=lambda message, ctx: message.content == "special")  # type: ignore
    async def handle_special_rpc_message(self, message: MessageWithContent, ctx: MessageContext) -> Response:
        return Response()
```

```python
async on_message_impl(message: Any, ctx: MessageContext) → Any | None[source]#
```

【中文翻译】通过将消息路由到适当的消息处理程序来处理消息。
不要在子类中覆盖此方法。相反，请添加使用 `event()` 或 `rpc()` 装饰器修饰的方法作为消息处理程序。

```python
async on_unhandled_message(message: Any, ctx: MessageContext) → None[source]#
```

【中文翻译】当收到没有匹配消息处理程序的消息时调用。
默认实现会记录一条信息性消息。

```python
class ClosureAgent(description: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn')[source]#
```

【中文翻译】基类：BaseAgent, ClosureContext

```python
property metadata: AgentMetadata#
```

【中文翻译】代理的元数据。

```python
property id: AgentId#
```

【中文翻译】代理的 ID。

```python
property runtime: AgentRuntime#
```

```python
async on_message_impl(message: Any, ctx: MessageContext) → Any[source]#
```

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】闭包代理没有状态。因此，此方法始终返回一个空字典。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】闭包代理没有状态。因此，此方法不执行任何操作。

```python
async classmethod register_closure(runtime: AgentRuntime, type: str, closure: Callable[[ClosureContext, T, MessageContext], Awaitable[Any]], *, unknown_type_policy: Literal['error', 'warn', 'ignore'] = 'warn', skip_direct_message_subscription: bool = False, description: str = '', subscriptions: Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None = None) → AgentType[source]#
```

【中文翻译】闭包代理允许您使用闭包或函数定义代理，而无需定义类。它允许从运行时提取值。
闭包可以定义预期的消息类型，或者可以使用 Any 来接受任何类型的消息。

示例：
```python
import asyncio
from autogen_core import SingleThreadedAgentRuntime, MessageContext, ClosureAgent, ClosureContext
from dataclasses import dataclass

from autogen_core._default_subscription import DefaultSubscription
from autogen_core._default_topic import DefaultTopicId


@dataclass
class MyMessage:
    content: str


async def main():
    queue = asyncio.Queue[MyMessage]()

    async def output_result(_ctx: ClosureContext, message: MyMessage, ctx: MessageContext) -> None:
        await queue.put(message)

    runtime = SingleThreadedAgentRuntime()
    await ClosureAgent.register_closure(
        runtime, "output_result", output_result, subscriptions=lambda: [DefaultSubscription()]
    )

    runtime.start()
    await runtime.publish_message(MyMessage("Hello, world!"), DefaultTopicId())
    await runtime.stop_when_idle()

    result = await queue.get()
    print(result)


asyncio.run(main())
```

参数：

runtime (AgentRuntime) – 要注册代理的运行时
type (str) – 已注册代理的代理类型
closure (Callable[[ClosureContext, T, MessageContext], Awaitable[Any]]) – 处理消息的闭包
unknown_type_policy (Literal["error", "warn", "ignore"], 可选) – 如果遇到与闭包类型不匹配的类型，该怎么办。默认为“warn”。
skip_direct_message_subscription (bool,好的，这是剩余的翻译内容：

【中文翻译】默认为 False。
description (str, 可选) – 代理功能的描述。默认为“”。
subscriptions (Callable[[], list[Subscription] | Awaitable[list[Subscription]]] | None, 可选) – 此闭包代理的订阅列表。默认为 None。

返回：
AgentType – 已注册代理的类型

```python
class ClosureContext(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol

```python
property id: AgentId#
```

```python
async send_message(message: Any, recipient: AgentId, *, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

```python
async publish_message(message: Any, topic_id: TopicId, *, cancellation_token: CancellationToken | None = None) → None[source]#
```

```python
message_handler(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]#
```

【中文翻译】通用消息处理程序的装饰器。
将此装饰器添加到 `RoutedAgent` 类中旨在处理事件和 RPC 消息的方法。
这些方法必须具有特定的签名才能有效：

该方法必须是异步方法。
该方法必须使用 `@message_handler` 装饰器进行修饰。

该方法必须正好有 3 个参数：
self
message：要处理的消息，必须使用其旨在处理的消息类型进行类型提示。
ctx：一个 `autogen_core.MessageContext` 对象。

该方法必须使用它可以作为响应返回的消息类型进行类型提示，如果它不返回任何内容，则可以返回 None。

处理程序可以通过接受消息类型的联合来处理多种消息类型。它还可以通过返回消息类型的联合来返回多种消息类型。

参数：

func – 要装饰的函数。
strict – 如果为 True，则如果消息类型或返回类型不在目标类型中，处理程序将引发异常。如果为 False，则会记录一条警告。
match – 一个接受消息和上下文作为参数并返回布尔值的函数。这用于在消息类型之后进行二次路由。对于处理相同消息类型的处理程序，匹配函数按处理程序的字母顺序应用，第一个匹配的处理程序将被调用，其余的将被跳过。如果为 None，则将调用按字母顺序排列的第一个匹配相同消息类型的处理程序。

```python
event(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, None]]], MessageHandler[AgentT, ReceivesT, None]] | MessageHandler[AgentT, ReceivesT, None][source]#
```

【中文翻译】事件消息处理程序的装饰器。
将此装饰器添加到 `RoutedAgent` 类中旨在处理事件消息的方法。
这些方法必须具有特定的签名才能有效：

该方法必须是异步方法。
该方法必须使用 `@message_handler` 装饰器进行修饰。

该方法必须正好有 3 个参数：
self
message：要处理的事件消息，必须使用其旨在处理的消息类型进行类型提示。
ctx：一个 `autogen_core.MessageContext` 对象。

该方法必须返回 None。

处理程序可以通过接受消息类型的联合来处理多种消息类型。

参数：

func – 要装饰的函数。
strict – 如果为 True，则如果消息类型不在目标类型中，处理程序将引发异常。如果为 False，则会记录一条警告。
match – 一个接受消息和上下文作为参数并返回布尔值的函数。这用于在消息类型之后进行二次路由。对于处理相同消息类型的处理程序，匹配函数按处理程序的字母顺序应用，第一个匹配的处理程序将被调用，其余的将被跳过。如果为 None，则将调用按字母顺序排列的第一个匹配相同消息类型的处理程序。

```python
rpc(func: None | Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]] = None, *, strict: bool = True, match: None | Callable[[ReceivesT, MessageContext], bool] = None) → Callable[[Callable[[AgentT, ReceivesT, MessageContext], Coroutine[Any, Any, ProducesT]]], MessageHandler[AgentT, ReceivesT, ProducesT]] | MessageHandler[AgentT, ReceivesT, ProducesT][source]#
```

【中文翻译】RPC 消息处理程序的装饰器。
将此装饰器添加到 `RoutedAgent` 类中旨在处理 RPC 消息的方法。
这些方法必须具有特定的签名才能有效：

该方法必须是异步方法。
该方法必须使用 `@message_handler` 装饰器进行修饰。

该方法必须正好有 3 个参数：
self
message：要处理的消息，必须使用其旨在处理的消息类型进行类型提示。
ctx：一个 `autogen_core.MessageContext` 对象。

该方法必须使用它可以作为响应返回的消息类型进行类型提示，如果它不返回任何内容，则可以返回 None。

处理程序可以通过接受消息类型的联合来处理多种消息类型。它还可以通过返回消息类型的联合来返回多种消息类型。

参数：

func – 要装饰的函数。
strict – 如果为 True，则如果消息类型或返回类型不在目标类型中，处理程序将引发异常。如果为 False，则会记录一条警告。
match – 一个接受消息和上下文作为参数并返回布尔值的函数。这用于在消息类型之后进行二次路由。对于处理相同消息类型的处理程序，匹配函数按处理程序的字母顺序应用，第一个匹配的处理程序将被调用，其余的将被跳过。如果为 None，则将调用按字母顺序排列的第一个匹配相同消息类型的处理程序。

```python
class FunctionCall(id: 'str', arguments: 'str', name: 'str')[source]#
```

【中文翻译】基类：object

```python
id: str#
```

```python
arguments: str#
```

```python
name: str#
```

```python
class TypeSubscription(topic_type: str, agent_type: str | AgentType, id: str | None = None)[source]#
```

【中文翻译】基类：Subscription
此订阅根据类型匹配主题，并使用主题的源作为代理键映射到代理。
此订阅导致每个源都有其自己的代理实例。

示例
```python
from autogen_core import TypeSubscription

subscription = TypeSubscription(topic_type="t1", agent_type="a1")
```

在这种情况下：

类型为 t1 且源为 s1 的 topic_id 将由类型为 a1 且键为 s1 的代理处理
类型为 t1 且源为 s2 的 topic_id 将由类型为 a1 且键为 s2 的代理处理。

参数：

topic_type (str) – 要匹配的主题类型
agent_type (str) – 处理此订阅的代理类型

```python
property id: str#
```

【中文翻译】获取订阅的 ID。
实现应返回订阅的唯一 ID。通常这是一个 UUID。

返回：
str – 订阅的 ID。

```python
property topic_type: str#
```

```python
property agent_type: str#
```

```python
is_match(topic_id: TopicId) → bool[source]#
```

【中文翻译】检查给定的 topic_id 是否与订阅匹配。

参数：
topic_id (TopicId) – 要检查的 TopicId。

返回：
bool – 如果 topic_id 与订阅匹配，则为 True，否则为 False。

```python
map_to_agent(topic_id: TopicId) → AgentId[source]#
```

【中文翻译】将 topic_id 映射到代理。仅当给定 topic_id 的 `is_match` 返回 True 时才应调用。

参数：
topic_id (TopicId) – 要映射的 TopicId。

返回：
AgentId – 应处理 topic_id 的代理的 ID。

引发：
CantHandleException – 如果订阅无法处理 topic_id。

```python
class DefaultSubscription(topic_type: str = 'default', agent_type: str | AgentType | None = None)[source]#
```

【中文翻译】基类：TypeSubscription
默认订阅旨在为只需要代理全局范围的应用程序提供合理的默认值。
默认情况下，此主题使用“default”主题类型，并尝试根据实例化上下文检测要使用的代理类型。

参数：

topic_type (str, 可选) – 要订阅的主题类型。默认为“default”。
agent_type (str, 可选) – 用于订阅的代理类型。默认为 None，在这种情况下，它将尝试根据实例化上下文检测代理类型。

```python
class DefaultTopicId(type: str = 'default', source: str | None = None)[source]#
```

【中文翻译】基类：TopicId
`DefaultTopicId` 为 `TopicId` 的 `topic_id` 和 `source` 字段提供了一个合理的默认值。
如果在消息处理程序的上下文中创建，则源将设置为消息处理程序的 `agent_id`，否则将设置为“default”。

参数：

type (str, 可选) – 要向其发布消息的主题类型。默认为“default”。
source (str | None, 可选) – 要向其发布消息的主题源。如果为 None，则如果在消息处理程序的上下文中，源将设置为消息处理程序的 `agent_id`，否则将设置为“default”。默认为 None。

```python
default_subscription(cls: Type[BaseAgentType] | None = None) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]] | Type[BaseAgentType][source]#
```

```python
type_subscription(topic_type: str) → Callable[[Type[BaseAgentType]], Type[BaseAgentType]][source]#
```

```python
class TypePrefixSubscription(topic_type_prefix: str, agent_type: str | AgentType, id: str | None = None)[source]#
```

【中文翻译】基类：Subscription
此订阅根据类型的前缀匹配主题，并使用主题的源作为代理键映射到代理。
此订阅导致每个源都有其自己的代理实例。

示例
```python
from autogen_core import TypePrefixSubscription

subscription = TypePrefixSubscription(topic_type_prefix="t1", agent_type="a1")
```

在这种情况下：

类型为 t1 且源为 s1 的 topic_id 将由类型为 a1 且键为 s1 的代理处理
类型为 t1 且源为 s2 的 topic_id 将由类型为 a1 且键为 s2 的代理处理。
类型为 t1SUFFIX 且源为 s2 的 topic_id 将由类型为 a1 且键为 s2 的代理处理。

参数：

topic_type_prefix (str) – 要匹配的主题类型前缀
agent_type (str) – 处理此订阅的代理类型

```python
property id: str#
```

【中文翻译】获取订阅的 ID。
实现应返回订阅的唯一 ID。通常这是一个 UUID。

返回：
str – 订阅的 ID。

```python
property topic_type_prefix: str#
```

```python
property agent_type: str#
```

```python
is_match(topic_id: TopicId) → bool[source]#
```

【中文翻译】检查给定的 topic_id 是否与订阅匹配。

参数：
topic_id (TopicId) – 要检查的 TopicId。

返回：
bool – 如果 topic_id 与订阅匹配，则为 True，否则为 False。

```python
map_to_agent(topic_id: TopicId) → AgentId[source]#
```

【中文翻译】将 topic_id 映射到代理。仅当给定 topic_id 的 `is_match` 返回 True 时才应调用。

参数：
topic_id (TopicId) – 要映射的 TopicId。

返回：
AgentId – 应处理 topic_id 的代理的 ID。

引发：
CantHandleException – 如果订阅无法处理 topic_id。

```python
JSON_DATA_CONTENT_TYPE = 'application/json'#
```

【中文翻译】JSON 数据的内容类型。

```python
PROTOBUF_DATA_CONTENT_TYPE = 'application/x-protobuf'#
```

【中文翻译】Protobuf 数据的内容类型。

```python
class SingleThreadedAgentRuntime(*, intervention_handlers: List[InterventionHandler] | None = None, tracer_provider: TracerProvider | None = None, ignore_unhandled_exceptions: bool = True)[source]#
```

【中文翻译】基类：AgentRuntime
一个单线程代理运行时，它使用单个 asyncio 队列处理所有消息。
消息按接收顺序传递，运行时在单独的 asyncio 任务中并发处理每条消息。

注意
此运行时适用于开发和独立应用程序。
它不适用于高吞吐量或高并发场景。

参数：

intervention_handlers (List[InterventionHandler], 可选) – 一个干预处理程序列表，可以在发送或发布消息之前拦截消息。默认为 None。
tracer_provider (TracerProvider, 可选) – 用于跟踪的跟踪程序提供程序。默认为 None。
ignore_unhandled_exceptions (bool, 可选) – 是否忽略代理事件处理程序中发生的未处理异常。任何后台异常都将在下一次调用 `process_next` 或从等待的 `stop`、`stop_when_idle` 或 `stop_when` 时引发。注意，这不适用于 RPC 处理程序。默认为 True。

示例
创建运行时、注册代理、发送消息和停止运行时的简单示例：
```python
import asyncio
from dataclasses import dataclass

from autogen_core import AgentId, MessageContext, RoutedAgent, SingleThreadedAgentRuntime, message_handler


@dataclass
class MyMessage:
    content: str


class MyAgent(RoutedAgent):
    @message_handler
    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:
        print(f"Received message: {message.content}")


async def main() -> None:
    # 创建运行时并注册代理
    runtime = SingleThreadedAgentRuntime()
    await MyAgent.register(runtime, "my_agent", lambda: MyAgent("My agent"))

    # 启动运行时、发送消息并停止运行时
    runtime.start()
    await runtime.send_message(MyMessage("Hello, world!"), recipient=AgentId("my_agent", "default"))
    await runtime.stop()


asyncio.run(main())
```

创建运行时、注册代理、发布消息和停止运行时的示例：
```python
import asyncio
from dataclasses import dataclass

from autogen_core import (
    DefaultTopicId,
    MessageContext,
    RoutedAgent,
    SingleThreadedAgentRuntime,
    default_subscription,
    message_handler,
)


@dataclass
class MyMessage:
    content: str


# 代理订阅默认主题。
@default_subscription
class MyAgent(RoutedAgent):
    @message_handler
    async def handle_my_message(self, message: MyMessage, ctx: MessageContext) -> None:
        print(f"Received message: {message.content}")


async def main() -> None:
    # 创建运行时并注册代理
    runtime = SingleThreadedAgentRuntime()
    await MyAgent.register(runtime, "my_agent", lambda: MyAgent("My agent"))

    # 启动运行时。
    runtime.start()
    # 向代理订阅的默认主题发布消息。
    await runtime.publish_message(MyMessage("Hello, world!"), DefaultTopicId())
    # 等待消息处理完毕，然后停止运行时。
    await runtime.stop_when_idle()


asyncio.run(main())
```

```python
property unprocessed_messages_count: int#
```

```python
async send_message(message: Any, recipient: AgentId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → Any[source]#
```

【中文翻译】向代理发送消息并获取响应。

参数：

message (Any) – 要发送的消息。
recipient (AgentId) – 要向其发送消息的代理。
sender (AgentId | None, 可选) – 发送消息的代理。如果此消息不是从任何代理发送的（例如直接从外部发送到运行时），则只能为 None。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。

引发：

CantHandleException – 如果接收方无法处理消息。
UndeliverableException – 如果消息无法传递。
Other – 接收方引发的任何其他异常。

返回：
Any – 来自代理的响应。

```python
async publish_message(message: Any, topic_id: TopicId, *, sender: AgentId | None = None, cancellation_token: CancellationToken | None = None, message_id: str | None = None) → None[source]#
```

【中文翻译】向给定命名空间中的所有代理发布消息，如果未提供命名空间，则向发送方的命名空间发布消息。
发布预计不会有响应。

参数：

message (Any) – 要发布的消息。
topic_id (TopicId) – 要向其发布消息的主题。
sender (AgentId | None, 可选) – 发送消息的代理。默认为 None。
cancellation_token (CancellationToken | None, 可选) – 用于取消正在进行的任务的令牌。默认为 None。
message_id (str | None, 可选) – 消息 ID。如果为 None，将生成新的消息 ID。默认为 None。此消息 ID 必须唯一，并且建议使用 UUID。

引发：
UndeliverableException – 如果消息无法传递。

```python
async save_state() → Mapping[str, Any][source]#
```

【中文翻译】保存所有已实例化代理的状态。
此方法调用每个代理的 `save_state()` 方法，并返回一个将代理 ID 映射到其状态的字典。

注意
此方法目前不保存订阅状态。我们将在未来添加此功能。

返回：
一个将代理 ID 映射到其状态的字典。

```python
async load_state(state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载所有已实例化代理的状态。
此方法使用字典中提供的状态调用每个代理的 `load_state()` 方法。字典的键是代理 ID，值是 `save_state()` 方法返回的状态字典。

注意
此方法目前不加载订阅状态。我们将在未来添加此功能。

```python
async process_next() → None[source]#
```

【中文翻译】处理队列中的下一条消息。
如果后台任务中存在未处理的异常，将在此处引发。在引发未处理的异常后，无法再次调用 `process_next`。

```python
start() → None[source]#
```

【中文翻译】启动运行时消息处理循环。这在后台任务中运行。

示例：
```python
import asyncio
from autogen_core import SingleThreadedAgentRuntime


async def main() -> None:
    runtime = SingleThreadedAgentRuntime()
    runtime.start()

    # ... 执行其他操作 ...

    await runtime.stop()


asyncio.run(main())
```

```python
async close() → None[source]#
```

【中文翻译】如果适用，调用 `stop()`，并对所有实例化的代理调用 `Agent.close()` 方法

```python
async stop() → None[source]#
```

【中文翻译】立即停止运行时消息处理循环。当前正在处理的消息将完成，但其后的所有其他消息将被丢弃。

```python
async stop_when_idle() → None[source]#
```

【中文翻译】当没有正在处理或排队的未完成消息时，停止运行时消息处理循环。这是停止运行时的最常用方法。

```python
async stop_when(condition: Callable[[], bool]) → None[source]#
```

【中文翻译】当条件满足时停止运行时消息处理循环。

警告
不建议使用此方法，它仅用于遗留原因。它将产生一个繁忙的循环来持续检查条件。调用 `stop_when_idle` 或 `stop` 效率要高得多。如果需要根据条件停止运行时，请考虑使用后台任务和 `asyncio.Event` 来发出条件满足且后台任务应调用 `stop` 的信号。

```python
async agent_metadata(agent: AgentId) → AgentMetadata[source]#
```

【中文翻译】获取代理的元数据。

参数：
agent (AgentId) – 代理 ID。

返回：
AgentMetadata – 代理元数据。

```python
async agent_save_state(agent: AgentId) → Mapping[str, Any][source]#
```

【中文翻译】保存单个代理的状态。
状态的结构由实现定义，可以是任何可 JSON 序列化的对象。

参数：
agent (AgentId) – 代理 ID。

返回：
Mapping[str, Any] – 保存的状态。

```python
async agent_load_state(agent: AgentId, state: Mapping[str, Any]) → None[source]#
```

【中文翻译】加载单个代理的状态。

参数：

agent (AgentId) – 代理 ID。
state (Mapping[str, Any]) – 保存的状态。

```python
async register_factory(type: str | AgentType, agent_factory: Callable[[], T | Awaitable[T]], *, expected_class: type[T] | None = None) → AgentType[source]#
```

【中文翻译】向与特定类型关联的运行时注册代理工厂。类型必须唯一。此 API 不添加任何订阅。

注意
这是一个低级 API，通常应改用代理类的 `register` 方法，因为这也会自动处理订阅。

示例：
```python
from dataclasses import dataclass

from autogen_core import AgentRuntime, MessageContext, RoutedAgent, event
from autogen_core.models import UserMessage


@dataclass
class MyMessage:
    content: str


class MyAgent(RoutedAgent):
    def __init__(self) -> None:
        super().__init__("My core agent")

    @event
    async def handler(self, message: UserMessage, context: MessageContext) -> None:
        print("Event received: ", message.content)


async def my_agent_factory():
    return MyAgent()


async def main() -> None:
    runtime: AgentRuntime = ...  # type: ignore
    await runtime.register_factory("my_agent", lambda: MyAgent())


import asyncio

asyncio.run(main())
```

参数：

type (str) – 此工厂创建的代理类型。它与代理类名不同。类型参数用于区分不同的工厂函数而不是代理类。
agent_factory (Callable[[], T]) – 创建代理的工厂，其中 T 是具体的代理类型。在工厂内部，使用 `autogen_core.AgentInstantiationContext` 访问诸如当前运行时和代理 ID 之类的变量。
expected_class (type[T] | None, 可选) – 代理的预期类，用于工厂的运行时验证。默认为 None。如果为 None，则不执行验证。

```python
async try_get_underlying_agent_instance(id: AgentId, type: Type[T] = Agent) → T[source]#
```

【中文翻译】尝试按名称和命名空间获取基础代理实例。通常不鼓励这样做（因此名称很长），但在某些情况下可能很有用。
如果基础代理不可访问，则会引发异常。

参数：

id (AgentId) – 代理 ID。
type (Type[T], 可选) – 代理的预期类型。默认为 Agent。

返回：
T – 具体的代理实例。

引发：

LookupError – 如果未找到代理。
NotAccessibleError – 如果代理不可访问，例如它位于远程位置。
TypeError – 如果代理不是预期类型。

```python
async add_subscription(subscription: Subscription) → None[source]#
```

【中文翻译】添加一个新的订阅，运行时在处理已发布消息时应满足该订阅

参数：
subscription (Subscription) – 要添加的订阅

```python
async remove_subscription(id: str) → None[source]#
```

【中文翻译】从运行时中删除订阅

参数：
id (str) – 要删除的订阅的 ID

引发：
LookupError – 如果订阅不存在

```python
async get(id_or_type: AgentId | AgentType | str, /, key: str = 'default', *, lazy: bool = True) → AgentId[source]#
```

```python
add_message_serializer(serializer: MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) → None[source]#
```

【中文翻译】向运行时添加新的消息序列化序列化器
注意：这将根据 `type_name` 和 `data_content_type` 属性对序列化器进行重复数据删除

参数：
serializer (MessageSerializer[Any] | Sequence[MessageSerializer[Any]]) – 要添加的序列化器

```python
ROOT_LOGGER_NAME = 'autogen_core'#
```

【中文翻译】根记录器的名称。

```python
EVENT_LOGGER_NAME = 'autogen_core.events'#
```

【中文翻译】用于结构化事件的记录器的名称。

```python
TRACE_LOGGER_NAME = 'autogen_core.trace'#
```

【中文翻译】用于开发人员意图跟踪日志记录的记录器名称。不应依赖此日志的内容和格式。

```python
class Component[source]#
```

【中文翻译】基类：ComponentFromConfig[ConfigT], ComponentSchemaType[ConfigT], Generic[ConfigT]
要创建组件类，请从此类继承具体类，并在接口上继承 `ComponentBase`。然后实现两个类变量：

`component_config_schema` - 表示组件配置的 Pydantic 模型类。这也是 `Component` 的类型参数。
`component_type` - 组件的逻辑类型是什么。

示例：
```python
from __future__ import annotations

from pydantic import BaseModel
from autogen_core import Component


class Config(BaseModel):
    value: str


class MyComponent(Component[Config]):
    component_type = "custom"
    component_config_schema = Config

    def __init__(self, value: str):
        self.value = value

    def _to_config(self) -> Config:
        return Config(value=self.value)

    @classmethod
    def _from_config(cls, config: Config) -> MyComponent:
        return cls(value=config.value)
```

```python
class ComponentBase[source]#
```

【中文翻译】基类：ComponentToConfig[ConfigT], ComponentLoader, Generic[ConfigT]

```python
class ComponentFromConfig[source]#
```

【中文翻译】基类：Generic[FromConfigT]

```python
classmethod _from_config(config: FromConfigT) → Self[source]#
```

【中文翻译】从配置对象创建组件的新实例。

参数：
config (T) – 配置对象。

返回：
Self – 组件的新实例。

```python
classmethod _from_config_past_version(config: Dict[str, Any], version: int) → Self[source]#
```

【中文翻译】从配置对象的先前版本创建组件的新实例。
仅当配置对象的版本低于当前版本时才调用此方法，因为在这种情况下模式是未知的。

参数：

config (Dict[str, Any]) – 配置对象。
version (int) – 配置对象的版本。

返回：
Self – 组件的新实例。

```python
class ComponentLoader[source]#
```

【中文翻译】基类：object

```python
classmethod load_component(model: ComponentModel | Dict[str, Any], expected: None = None) → Self[source]#
```

【中文翻译】从模型加载组件。旨在与 `autogen_core.ComponentConfig.dump_component()` 的返回类型一起使用。

示例```python
from autogen_core import ComponentModel
from autogen_core.models import ChatCompletionClient

component: ComponentModel = ...  # type: ignore

model_client = ChatCompletionClient.load_component(component)
```

参数：

model (ComponentModel) – 要从中加载组件的模型。
model – _description_
expected (Type[ExpectedType] | None, 可选) – 仅当直接在 `ComponentLoader` 上使用时才显式类型。默认为 None。

返回：
Self – 加载的组件。

引发：

ValueError – 如果提供程序字符串无效。
TypeError – 提供程序不是 `ComponentConfigImpl` 的子类，或者预期类型不匹配。

返回：
Self | ExpectedType – 加载的组件。

```python
pydantic model ComponentModel[source]#
```

【中文翻译】基类：BaseModel
组件的模型类。包含实例化组件所需的所有信息。

显示 JSON 架构
```json
{
   "title": "ComponentModel",
   "description": "Model class for a component. Contains all information required to instantiate a component.",
   "type": "object",
   "properties": {
      "provider": {
         "title": "Provider",
         "type": "string"
      },
      "component_type": {
         "anyOf": [
            {
               "enum": [
                  "model",
                  "agent",
                  "tool",
                  "termination",
                  "token_provider",
                  "workbench"
               ],
               "type": "string"
            },
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Component Type"
      },
      "version": {
         "anyOf": [
            {
               "type": "integer"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Version"
      },
      "component_version": {
         "anyOf": [
            {
               "type": "integer"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Component Version"
      },
      "description": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Description"
      },
      "label": {
         "anyOf": [
            {
               "type": "string"
            },
            {
               "type": "null"
            }
         ],
         "default": null,
         "title": "Label"
      },
      "config": {
         "title": "Config",
         "type": "object"
      }
   },
   "required": [
      "provider",
      "config"
   ]
}
```

字段：

component_type (Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str | None)
component_version (int | None)
config (dict[str, Any])
description (str | None)
label (str | None)
provider (str)
version (int | None)

```python
field provider: str [Required]#
```

【中文翻译】描述如何实例化组件。

```python
field component_type: ComponentType | None = None#
```

【中文翻译】组件的逻辑类型。如果缺失，组件将采用提供程序的默认类型。

```python
field version: int | None = None#
```

【中文翻译】组件规范的版本。如果缺失，组件将采用用于加载它的库的当前版本。这显然是危险的，应该用于用户编写的临时配置。对于所有其他配置，应指定版本。

```python
field component_version: int | None = None#
```

【中文翻译】组件的版本。如果缺失，组件将采用提供程序的默认版本。

```python
field description: str | None = None#
```

【中文翻译】组件的描述。

```python
field label: str | None = None#
```

【中文翻译】组件的人类可读标签。如果缺失，组件将采用提供程序的类名。

```python
field config: dict[str, Any] [Required]#
```

【中文翻译】模式验证的 `config` 字段将传递给给定类的 `autogen_core.ComponentConfigImpl._from_config()` 实现，以创建组件类的新实例。

```python
class ComponentSchemaType[source]#
```

【中文翻译】基类：Generic[ConfigT]

```python
component_config_schema: Type[ConfigT]#
```

【中文翻译】表示组件配置的 Pydantic 模型类。

```python
required_class_vars = ['component_config_schema', 'component_type']#
```

```python
class ComponentToConfig[source]#
```

【中文翻译】基类：Generic[ToConfigT]
一个类要成为组件必须实现的两个方法。

参数：
Protocol (ConfigT) –派生自 `pydantic.BaseModel` 的类型。

```python
component_type: ClassVar[Literal['model', 'agent', 'tool', 'termination', 'token_provider', 'workbench'] | str]#
```

【中文翻译】组件的逻辑类型。

```python
component_version: ClassVar[int] = 1#
```

【中文翻译】组件的版本，如果引入了模式不兼容性，则应更新此版本。

```python
component_provider_override: ClassVar[str | None] = None#
```

【中文翻译】覆盖组件的提供程序字符串。这应该用于防止内部模块名称成为模块名称的一部分。

```python
component_description: ClassVar[str | None] = None#
```

【中文翻译】组件的描述。如果未提供，将使用类的文档字符串。

```python
component_label: ClassVar[str | None] = None#
```

【中文翻译】组件的人类可读标签。如果未提供，将使用组件类名。

```python
_to_config() → ToConfigT[source]#
```

【中文翻译】转储创建与此实例配置匹配的组件新实例所需的配置。

返回：
T – 组件的配置。

```python
dump_component() → ComponentModel[source]#
```

【中文翻译】将组件转储到可以加载回的模型中。

引发：
TypeError – 如果组件是本地类。

返回：
ComponentModel – 表示组件的模型。

```python
is_component_class(cls: type) → TypeGuard[Type[_ConcreteComponent[BaseModel]]][source]#
```

```python
is_component_instance(cls: Any) → TypeGuard[_ConcreteComponent[BaseModel]][source]#
```

```python
final class DropMessage[source]#
```

【中文翻译】基类：object
用于指示干预处理程序应丢弃消息的标记类型。该类型本身应从处理程序返回。

```python
class InterventionHandler(*args, **kwargs)[source]#
```

【中文翻译】基类：Protocol
干预处理程序是一个类，可用于修改、记录或丢弃由 `autogen_core.base.AgentRuntime` 处理的消息。
当消息提交到运行时时，将调用该处理程序。
目前唯一支持此功能的运行时是 `autogen_core.base.SingleThreadedAgentRuntime`。
注意：从任何干预处理程序方法返回 None 将导致发出警告并被视为“无更改”。如果您打算丢弃消息，则应显式返回 `DropMessage`。

示例：
```python
from autogen_core import DefaultInterventionHandler, MessageContext, AgentId, SingleThreadedAgentRuntime
from dataclasses import dataclass
from typing import Any


@dataclass
class MyMessage:
    content: str


class MyInterventionHandler(DefaultInterventionHandler):
    async def on_send(self, message: Any, *, message_context: MessageContext, recipient: AgentId) -> MyMessage:
        if isinstance(message, MyMessage):
            message.content = message.content.upper()
        return message


runtime = SingleThreadedAgentRuntime(intervention_handlers=[MyInterventionHandler()])
```

```python
async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.send_message()` 向 AgentRuntime 提交消息时调用。

```python
async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.publish_message()` 向 AgentRuntime 发布消息时调用。

```python
async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]#
```

【中文翻译】当 AgentRuntime 从 Agent 的消息处理程序接收到返回值时调用。

```python
class DefaultInterventionHandler(*args, **kwargs)[source]#
```

【中文翻译】基类：InterventionHandler
一个简单的类，为所有干预处理程序方法提供默认实现，该实现仅返回未更改的消息。允许轻松地进行子类化以仅覆盖所需的方法。

```python
async on_send(message: Any, *, message_context: MessageContext, recipient: AgentId) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.send_message()` 向 AgentRuntime 提交消息时调用。

```python
async on_publish(message: Any, *, message_context: MessageContext) → Any | type[DropMessage][source]#
```

【中文翻译】当使用 `autogen_core.base.AgentRuntime.publish_message()` 向 AgentRuntime 发布消息时调用。

```python
async on_response(message: Any, *, sender: AgentId, recipient: AgentId | None) → Any | type[DropMessage][source]#
```

【中文翻译】当 AgentRuntime 从 Agent 的消息处理程序接收到返回值时调用。

```python
ComponentType#
```

【中文翻译】Literal[‘model’, ‘agent’, ‘tool’, ‘termination’, ‘token_provider’, ‘workbench’] | str 的别名

【中文翻译】上一页

【中文翻译】autogen_agentchat.state

【中文翻译】下一页

【中文翻译】autogen_core.code_executor

--- END OF FILE autogen_api_reference_zh.md ---